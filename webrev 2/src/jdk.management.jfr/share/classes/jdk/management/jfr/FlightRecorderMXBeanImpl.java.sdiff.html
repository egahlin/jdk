<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DiskRepository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MBeanUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.StringReader;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
<span class="line-removed"> 33 import java.security.AccessControlContext;</span>
<span class="line-removed"> 34 import java.security.AccessController;</span>
<span class="line-removed"> 35 import java.security.PrivilegedAction;</span>
 36 import java.text.ParseException;
 37 import java.time.Instant;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Objects;
 45 import java.util.concurrent.ConcurrentHashMap;
 46 import java.util.concurrent.CopyOnWriteArrayList;
 47 import java.util.concurrent.atomic.AtomicLong;
 48 import java.util.function.Consumer;
 49 import java.util.function.Function;
 50 import java.util.function.Predicate;
 51 
 52 import javax.management.AttributeChangeNotification;
 53 import javax.management.AttributeNotFoundException;
 54 import javax.management.ListenerNotFoundException;
 55 import javax.management.MBeanException;
 56 import javax.management.MBeanNotificationInfo;
 57 import javax.management.Notification;
 58 import javax.management.NotificationBroadcasterSupport;
 59 import javax.management.NotificationEmitter;
 60 import javax.management.NotificationFilter;
 61 import javax.management.NotificationListener;
 62 import javax.management.ObjectName;
 63 import javax.management.ReflectionException;
 64 import javax.management.StandardEmitterMBean;
 65 
 66 import jdk.jfr.Configuration;
 67 import jdk.jfr.EventType;
 68 import jdk.jfr.FlightRecorder;
 69 import jdk.jfr.FlightRecorderListener;
<span class="line-removed"> 70 import jdk.jfr.FlightRecorderPermission;</span>
 71 import jdk.jfr.Recording;
 72 import jdk.jfr.RecordingState;
 73 import jdk.jfr.internal.management.ManagementSupport;
 74 import jdk.jfr.internal.management.StreamManager;
 75 
 76 // Instantiated by service provider
 77 final class FlightRecorderMXBeanImpl extends StandardEmitterMBean implements FlightRecorderMXBean, NotificationEmitter {
 78 
 79     final class MXBeanListener implements FlightRecorderListener {
 80         private final NotificationListener listener;
 81         private final NotificationFilter filter;
 82         private final Object handback;
<span class="line-removed"> 83         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed"> 84         private final AccessControlContext context;</span>
 85 
 86         @SuppressWarnings(&quot;removal&quot;)
 87         public MXBeanListener(NotificationListener listener, NotificationFilter filter, Object handback) {
<span class="line-removed"> 88             this.context = AccessController.getContext();</span>
 89             this.listener = listener;
 90             this.filter = filter;
 91             this.handback = handback;
 92         }
 93 
 94         @SuppressWarnings(&quot;removal&quot;)
 95         public void recordingStateChanged(Recording recording) {
<span class="line-modified"> 96             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-removed"> 97                 @Override</span>
<span class="line-removed"> 98                 public Void run() {</span>
<span class="line-removed"> 99                     sendNotification(createNotification(recording));</span>
<span class="line-removed">100                     return null;</span>
<span class="line-removed">101                 }</span>
<span class="line-removed">102             }, context);</span>
103         }
104     }
105 
106     private static final String ATTRIBUTE_RECORDINGS = &quot;Recordings&quot;;
107     private static final String OPTION_MAX_SIZE = &quot;maxSize&quot;;
108     private static final String OPTION_MAX_AGE = &quot;maxAge&quot;;
109     private static final String OPTION_NAME = &quot;name&quot;;
110     private static final String OPTION_DISK = &quot;disk&quot;;
111     private static final String OPTION_DUMP_ON_EXIT = &quot;dumpOnExit&quot;;
112     private static final String OPTION_DURATION = &quot;duration&quot;;
113     private static final String OPTION_DESTINATION = &quot;destination&quot;;
114     private static final List&lt;String&gt; OPTIONS = Arrays.asList(OPTION_DUMP_ON_EXIT, OPTION_DURATION, OPTION_NAME, OPTION_MAX_AGE, OPTION_MAX_SIZE, OPTION_DISK, OPTION_DESTINATION);
115     private final StreamManager streamHandler = new StreamManager();
116     private final Map&lt;Long, Object&gt; changes = new ConcurrentHashMap&lt;&gt;();
117     private final AtomicLong sequenceNumber = new AtomicLong();
118     private final List&lt;MXBeanListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
119     private FlightRecorder recorder;
120 
121     FlightRecorderMXBeanImpl() {
122         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
123     }
124 
125     @Override
126     public void startRecording(long id) {
<span class="line-removed">127         MBeanUtils.checkControl();</span>
128         getExistingRecording(id).start();
129     }
130 
131     @Override
132     public boolean stopRecording(long id) {
<span class="line-removed">133         MBeanUtils.checkControl();</span>
134         return getExistingRecording(id).stop();
135     }
136 
137     @Override
138     public void closeRecording(long id) {
<span class="line-removed">139         MBeanUtils.checkControl();</span>
140         getExistingRecording(id).close();
141     }
142 
143     @Override
144     public long openStream(long id, Map&lt;String, String&gt; options) throws IOException {
<span class="line-removed">145         MBeanUtils.checkControl();</span>
146         if (!FlightRecorder.isInitialized()) {
147             throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
148         }
149         // Make local copy to prevent concurrent modification
150         Map&lt;String, String&gt; s = options == null ? new HashMap&lt;&gt;() : new HashMap&lt;&gt;(options);
151         Instant starttime = MBeanUtils.parseTimestamp(s.get(&quot;startTime&quot;), Instant.MIN);
152         Instant endtime = MBeanUtils.parseTimestamp(s.get(&quot;endTime&quot;), Instant.MAX);
153         int blockSize = MBeanUtils.parseBlockSize(s.get(&quot;blockSize&quot;), StreamManager.DEFAULT_BLOCK_SIZE);
154         String version = s.get(&quot;streamVersion&quot;);
155         if (version != null) {
156             if (&quot;1.0&quot;.equals(version)) {
157                 Recording r = getRecording(id);
158                 return streamHandler.createOngoing(r, blockSize, starttime, endtime).getId();
159             }
160             throw new IllegalArgumentException(&quot;Unsupported stream version &quot; + version);
161         }
162 
163         InputStream is = getExistingRecording(id).getStream(starttime, endtime);
164         if (is == null) {
165             throw new IOException(&quot;No recording data available&quot;);
166         }
167         return streamHandler.create(is, blockSize).getId();
168     }
169 
170     @Override
171     public void closeStream(long streamIdentifier) throws IOException {
<span class="line-removed">172         MBeanUtils.checkControl();</span>
173         streamHandler.getStream(streamIdentifier).close();
174     }
175 
176     @Override
177     public byte[] readStream(long streamIdentifier) throws IOException {
<span class="line-removed">178         MBeanUtils.checkMonitor();</span>
179         return streamHandler.getStream(streamIdentifier).read();
180     }
181 
182     @Override
183     public List&lt;RecordingInfo&gt; getRecordings() {
<span class="line-removed">184         MBeanUtils.checkMonitor();</span>
185         if (!FlightRecorder.isInitialized()) {
186             return Collections.emptyList();
187         }
188         return MBeanUtils.transformList(getRecorder().getRecordings(), RecordingInfo::new);
189     }
190 
191     @Override
192     public List&lt;ConfigurationInfo&gt; getConfigurations() {
<span class="line-removed">193         MBeanUtils.checkMonitor();</span>
194         return MBeanUtils.transformList(Configuration.getConfigurations(), ConfigurationInfo::new);
195     }
196 
197     @Override
198     public List&lt;EventTypeInfo&gt; getEventTypes() {
<span class="line-modified">199         MBeanUtils.checkMonitor();</span>
<span class="line-removed">200         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">201         List&lt;EventType&gt; eventTypes = AccessController.doPrivileged(new PrivilegedAction&lt;List&lt;EventType&gt;&gt;() {</span>
<span class="line-removed">202             @Override</span>
<span class="line-removed">203             public List&lt;EventType&gt; run() {</span>
<span class="line-removed">204                 return ManagementSupport.getEventTypes();</span>
<span class="line-removed">205             }</span>
<span class="line-removed">206         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));</span>
<span class="line-removed">207 </span>
<span class="line-removed">208         return MBeanUtils.transformList(eventTypes, EventTypeInfo::new);</span>
209     }
210 
211     @Override
212     public Map&lt;String, String&gt; getRecordingSettings(long recording) throws IllegalArgumentException {
<span class="line-removed">213         MBeanUtils.checkMonitor();</span>
214         return getExistingRecording(recording).getSettings();
215     }
216 
217     @Override
218     public void setRecordingSettings(long recording, Map&lt;String, String&gt; settings) throws IllegalArgumentException {
219         Objects.requireNonNull(settings, &quot;settings&quot;);
<span class="line-removed">220         MBeanUtils.checkControl();</span>
221         getExistingRecording(recording).setSettings(settings);
222     }
223 
<span class="line-removed">224     @SuppressWarnings(&quot;removal&quot;)</span>
225     @Override
226     public long newRecording() {
<span class="line-removed">227         MBeanUtils.checkControl();</span>
228         getRecorder(); // ensure notification listener is setup
<span class="line-modified">229         return AccessController.doPrivileged(new PrivilegedAction&lt;Recording&gt;() {</span>
<span class="line-removed">230             @Override</span>
<span class="line-removed">231             public Recording run() {</span>
<span class="line-removed">232                 return new Recording();</span>
<span class="line-removed">233             }</span>
<span class="line-removed">234         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;)).getId();</span>
235     }
236 
237     @Override
238     public long takeSnapshot() {
<span class="line-removed">239         MBeanUtils.checkControl();</span>
240         return getRecorder().takeSnapshot().getId();
241     }
242 
243     @Override
244     public void setConfiguration(long recording, String contents) throws IllegalArgumentException {
245         Objects.requireNonNull(contents, &quot;contents&quot;);
<span class="line-removed">246         MBeanUtils.checkControl();</span>
247         try {
248             Configuration c = Configuration.create(new StringReader(contents));
249             getExistingRecording(recording).setSettings(c.getSettings());
250         } catch (IOException | ParseException e) {
251             throw new IllegalArgumentException(&quot;Could not parse configuration&quot;, e);
252         }
253     }
254 
255     @Override
256     public void setPredefinedConfiguration(long recording, String configurationName) throws IllegalArgumentException {
257         Objects.requireNonNull(configurationName, &quot;configurationName&quot;);
<span class="line-removed">258         MBeanUtils.checkControl();</span>
259         Recording r = getExistingRecording(recording);
260         for (Configuration c : Configuration.getConfigurations()) {
261             if (c.getName().equals(configurationName)) {
262                 r.setSettings(c.getSettings());
263                 return;
264             }
265         }
266         throw new IllegalArgumentException(&quot;Could not find configuration with name &quot; + configurationName);
267     }
268 
269     @Override
270     public void copyTo(long recording, String outputFile) throws IOException {
271         Objects.requireNonNull(outputFile, &quot;outputFile&quot;);
<span class="line-removed">272         MBeanUtils.checkControl();</span>
273         getExistingRecording(recording).dump(Paths.get(outputFile));
274     }
275 
276     @Override
277     public void setRecordingOptions(long recording, Map&lt;String, String&gt; options) throws IllegalArgumentException {
278         Objects.requireNonNull(options, &quot;options&quot;);
<span class="line-removed">279         MBeanUtils.checkControl();</span>
280         // Make local copy to prevent concurrent modification
281         Map&lt;String, String&gt; ops = new HashMap&lt;String, String&gt;(options);
282         for (Map.Entry&lt;String, String&gt; entry : ops.entrySet()) {
283             Object key = entry.getKey();
284             Object value = entry.getValue();
285             // Keys and values may be sent over the network
286             if (!(key instanceof String)) {
287                 throw new IllegalArgumentException(&quot;Option key must not be null, or other type than &quot; + String.class);
288             }
289             if (!OPTIONS.contains(key)) {
290                 throw new IllegalArgumentException(&quot;Unknown recording option: &quot; + key + &quot;. Valid options are &quot; + OPTIONS + &quot;.&quot;);
291             }
292             if (value != null &amp;&amp; !(value instanceof String)) {
293                 throw new IllegalArgumentException(&quot;Incorrect value for option &quot; + key + &quot;. Values must be of type &quot; + String.class + &quot; .&quot;);
294             }
295         }
296 
297         Recording r = getExistingRecording(recording);
298         validateOption(ops, OPTION_DUMP_ON_EXIT, MBeanUtils::booleanValue);
299         validateOption(ops, OPTION_DISK, MBeanUtils::booleanValue);
300         validateOption(ops, OPTION_NAME, Function.identity());
301         validateOption(ops, OPTION_MAX_AGE, MBeanUtils::duration);
302         validateOption(ops, OPTION_MAX_SIZE, MBeanUtils::size);
303         validateOption(ops, OPTION_DURATION, MBeanUtils::duration);
304         validateOption(ops, OPTION_DESTINATION, x -&gt; MBeanUtils.destination(r, x));
305 
306         // All OK, now set them
307         setOption(ops, OPTION_DUMP_ON_EXIT, &quot;false&quot;, MBeanUtils::booleanValue, r::setDumpOnExit);
308         setOption(ops, OPTION_DISK, &quot;true&quot;, MBeanUtils::booleanValue, r::setToDisk);
309         setOption(ops, OPTION_NAME, String.valueOf(r.getId()), Function.identity(), r::setName);
310         setOption(ops, OPTION_MAX_AGE, null, MBeanUtils::duration, r::setMaxAge);
311         setOption(ops, OPTION_MAX_SIZE, &quot;0&quot;, MBeanUtils::size, r::setMaxSize);
312         setOption(ops, OPTION_DURATION, null, MBeanUtils::duration, r::setDuration);
313         setOption(ops, OPTION_DESTINATION, null, x -&gt; MBeanUtils.destination(r, x), x -&gt; setOptionDestination(r, x));
314     }
315 
316     @Override
317     public Map&lt;String, String&gt; getRecordingOptions(long recording) throws IllegalArgumentException {
<span class="line-removed">318         MBeanUtils.checkMonitor();</span>
319         Recording r = getExistingRecording(recording);
320         Map&lt;String, String&gt; options = HashMap.newHashMap(10);
321         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
322         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
323         options.put(OPTION_NAME, String.valueOf(r.getName()));
324         options.put(OPTION_MAX_AGE, ManagementSupport.formatTimespan(r.getMaxAge(), &quot; &quot;));
325         Long maxSize = r.getMaxSize();
326         options.put(OPTION_MAX_SIZE, String.valueOf(maxSize == null ? &quot;0&quot; : maxSize.toString()));
327         options.put(OPTION_DURATION, ManagementSupport.formatTimespan(r.getDuration(), &quot; &quot;));
328         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));
329         return options;
330     }
331 
332     @Override
<span class="line-modified">333     public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {</span>
<span class="line-removed">334         MBeanUtils.checkControl();</span>
335         return getRecording(id).copy(stop).getId();
336     }
337 
338     @Override
339     public ObjectName getObjectName() {
340         return MBeanUtils.createObjectName();
341     }
342 
343     private Recording getExistingRecording(long id) {
344         if (FlightRecorder.isInitialized()) {
345             Recording recording = getRecording(id);
346             if (recording != null) {
347                 return recording;
348             }
349         }
350         throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
351     }
352 
353     private Recording getRecording(long id) {
354         List&lt;Recording&gt; recs = getRecorder().getRecordings();
</pre>
<hr />
<pre>
380         } catch (IOException e) {
381             IllegalArgumentException iae = new IllegalArgumentException(&quot;Not a valid destination &quot; + destination);
382             iae.addSuppressed(e);
383             throw iae;
384         }
385     }
386 
387     private static &lt;T, U&gt; void validateOption(Map&lt;String, String&gt; options, String name, Function&lt;String, U&gt; validator) {
388         try {
389             String v = options.get(name);
390             if (v == null) {
391                 return; // OK, will set default
392             }
393             validator.apply(v);
394         } catch (IllegalArgumentException iae) {
395             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
396         }
397     }
398 
399     @SuppressWarnings(&quot;removal&quot;)
<span class="line-modified">400     private FlightRecorder getRecorder() throws SecurityException {</span>
401         // Synchronize on some private object that is always available
402         synchronized (streamHandler) {
403             if (recorder == null) {
<span class="line-modified">404                 recorder = AccessController.doPrivileged(new PrivilegedAction&lt;FlightRecorder&gt;() {</span>
<span class="line-removed">405                     @Override</span>
<span class="line-removed">406                     public FlightRecorder run() {</span>
<span class="line-removed">407                         return FlightRecorder.getFlightRecorder();</span>
<span class="line-removed">408                     }</span>
<span class="line-removed">409                 }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));</span>
410             }
411             return recorder;
412         }
413     }
414 
415     private static MBeanNotificationInfo[] createNotificationInfo() {
416         String[] types = new String[] { AttributeChangeNotification.ATTRIBUTE_CHANGE };
417         String name = AttributeChangeNotification.class.getName();
418         String description = &quot;Notifies if the RecordingState has changed for one of the recordings, for example if a recording starts or stops&quot;;
419         MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
420         return new MBeanNotificationInfo[] { info };
421     }
422 
423     @SuppressWarnings(&quot;removal&quot;)
424     @Override
425     public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) {
426         MXBeanListener mxbeanListener = new MXBeanListener(listener, filter, handback);
427         listeners.add(mxbeanListener);
<span class="line-modified">428         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-removed">429             @Override</span>
<span class="line-removed">430             public Void run(){</span>
<span class="line-removed">431                 FlightRecorder.addListener(mxbeanListener);</span>
<span class="line-removed">432                 return null;</span>
<span class="line-removed">433             }</span>
<span class="line-removed">434         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));</span>
435         super.addNotificationListener(listener, filter, handback);
436     }
437 
438     @Override
439     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
440         removeListeners( x -&gt; listener == x.listener);
441         super.removeNotificationListener(listener);
442     }
443 
444     @Override
445     public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException {
446         removeListeners( x -&gt; listener == x.listener &amp;&amp; filter == x.filter &amp;&amp; handback == x.handback);
447         super.removeNotificationListener(listener, filter, handback);
448     }
449 
450     private void removeListeners(Predicate&lt;MXBeanListener&gt; p) {
451         List&lt;MXBeanListener&gt; toBeRemoved = new ArrayList&lt;&gt;(listeners.size());
452         for (MXBeanListener l : listeners) {
453             if (p.test(l)) {
454                 toBeRemoved.add(l);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.StringReader;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;



 33 import java.text.ParseException;
 34 import java.time.Instant;
 35 import java.util.ArrayList;
 36 import java.util.Arrays;
 37 import java.util.Collections;
 38 import java.util.HashMap;
 39 import java.util.List;
 40 import java.util.Map;
 41 import java.util.Objects;
 42 import java.util.concurrent.ConcurrentHashMap;
 43 import java.util.concurrent.CopyOnWriteArrayList;
 44 import java.util.concurrent.atomic.AtomicLong;
 45 import java.util.function.Consumer;
 46 import java.util.function.Function;
 47 import java.util.function.Predicate;
 48 
 49 import javax.management.AttributeChangeNotification;
 50 import javax.management.AttributeNotFoundException;
 51 import javax.management.ListenerNotFoundException;
 52 import javax.management.MBeanException;
 53 import javax.management.MBeanNotificationInfo;
 54 import javax.management.Notification;
 55 import javax.management.NotificationBroadcasterSupport;
 56 import javax.management.NotificationEmitter;
 57 import javax.management.NotificationFilter;
 58 import javax.management.NotificationListener;
 59 import javax.management.ObjectName;
 60 import javax.management.ReflectionException;
 61 import javax.management.StandardEmitterMBean;
 62 
 63 import jdk.jfr.Configuration;
 64 import jdk.jfr.EventType;
 65 import jdk.jfr.FlightRecorder;
 66 import jdk.jfr.FlightRecorderListener;

 67 import jdk.jfr.Recording;
 68 import jdk.jfr.RecordingState;
 69 import jdk.jfr.internal.management.ManagementSupport;
 70 import jdk.jfr.internal.management.StreamManager;
 71 
 72 // Instantiated by service provider
 73 final class FlightRecorderMXBeanImpl extends StandardEmitterMBean implements FlightRecorderMXBean, NotificationEmitter {
 74 
 75     final class MXBeanListener implements FlightRecorderListener {
 76         private final NotificationListener listener;
 77         private final NotificationFilter filter;
 78         private final Object handback;


 79 
 80         @SuppressWarnings(&quot;removal&quot;)
 81         public MXBeanListener(NotificationListener listener, NotificationFilter filter, Object handback) {

 82             this.listener = listener;
 83             this.filter = filter;
 84             this.handback = handback;
 85         }
 86 
 87         @SuppressWarnings(&quot;removal&quot;)
 88         public void recordingStateChanged(Recording recording) {
<span class="line-modified"> 89             sendNotification(createNotification(recording));</span>






 90         }
 91     }
 92 
 93     private static final String ATTRIBUTE_RECORDINGS = &quot;Recordings&quot;;
 94     private static final String OPTION_MAX_SIZE = &quot;maxSize&quot;;
 95     private static final String OPTION_MAX_AGE = &quot;maxAge&quot;;
 96     private static final String OPTION_NAME = &quot;name&quot;;
 97     private static final String OPTION_DISK = &quot;disk&quot;;
 98     private static final String OPTION_DUMP_ON_EXIT = &quot;dumpOnExit&quot;;
 99     private static final String OPTION_DURATION = &quot;duration&quot;;
100     private static final String OPTION_DESTINATION = &quot;destination&quot;;
101     private static final List&lt;String&gt; OPTIONS = Arrays.asList(OPTION_DUMP_ON_EXIT, OPTION_DURATION, OPTION_NAME, OPTION_MAX_AGE, OPTION_MAX_SIZE, OPTION_DISK, OPTION_DESTINATION);
102     private final StreamManager streamHandler = new StreamManager();
103     private final Map&lt;Long, Object&gt; changes = new ConcurrentHashMap&lt;&gt;();
104     private final AtomicLong sequenceNumber = new AtomicLong();
105     private final List&lt;MXBeanListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
106     private FlightRecorder recorder;
107 
108     FlightRecorderMXBeanImpl() {
109         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
110     }
111 
112     @Override
113     public void startRecording(long id) {

114         getExistingRecording(id).start();
115     }
116 
117     @Override
118     public boolean stopRecording(long id) {

119         return getExistingRecording(id).stop();
120     }
121 
122     @Override
123     public void closeRecording(long id) {

124         getExistingRecording(id).close();
125     }
126 
127     @Override
128     public long openStream(long id, Map&lt;String, String&gt; options) throws IOException {

129         if (!FlightRecorder.isInitialized()) {
130             throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
131         }
132         // Make local copy to prevent concurrent modification
133         Map&lt;String, String&gt; s = options == null ? new HashMap&lt;&gt;() : new HashMap&lt;&gt;(options);
134         Instant starttime = MBeanUtils.parseTimestamp(s.get(&quot;startTime&quot;), Instant.MIN);
135         Instant endtime = MBeanUtils.parseTimestamp(s.get(&quot;endTime&quot;), Instant.MAX);
136         int blockSize = MBeanUtils.parseBlockSize(s.get(&quot;blockSize&quot;), StreamManager.DEFAULT_BLOCK_SIZE);
137         String version = s.get(&quot;streamVersion&quot;);
138         if (version != null) {
139             if (&quot;1.0&quot;.equals(version)) {
140                 Recording r = getRecording(id);
141                 return streamHandler.createOngoing(r, blockSize, starttime, endtime).getId();
142             }
143             throw new IllegalArgumentException(&quot;Unsupported stream version &quot; + version);
144         }
145 
146         InputStream is = getExistingRecording(id).getStream(starttime, endtime);
147         if (is == null) {
148             throw new IOException(&quot;No recording data available&quot;);
149         }
150         return streamHandler.create(is, blockSize).getId();
151     }
152 
153     @Override
154     public void closeStream(long streamIdentifier) throws IOException {

155         streamHandler.getStream(streamIdentifier).close();
156     }
157 
158     @Override
159     public byte[] readStream(long streamIdentifier) throws IOException {

160         return streamHandler.getStream(streamIdentifier).read();
161     }
162 
163     @Override
164     public List&lt;RecordingInfo&gt; getRecordings() {

165         if (!FlightRecorder.isInitialized()) {
166             return Collections.emptyList();
167         }
168         return MBeanUtils.transformList(getRecorder().getRecordings(), RecordingInfo::new);
169     }
170 
171     @Override
172     public List&lt;ConfigurationInfo&gt; getConfigurations() {

173         return MBeanUtils.transformList(Configuration.getConfigurations(), ConfigurationInfo::new);
174     }
175 
176     @Override
177     public List&lt;EventTypeInfo&gt; getEventTypes() {
<span class="line-modified">178         return MBeanUtils.transformList(ManagementSupport.getEventTypes(), EventTypeInfo::new);</span>









179     }
180 
181     @Override
182     public Map&lt;String, String&gt; getRecordingSettings(long recording) throws IllegalArgumentException {

183         return getExistingRecording(recording).getSettings();
184     }
185 
186     @Override
187     public void setRecordingSettings(long recording, Map&lt;String, String&gt; settings) throws IllegalArgumentException {
188         Objects.requireNonNull(settings, &quot;settings&quot;);

189         getExistingRecording(recording).setSettings(settings);
190     }
191 

192     @Override
193     public long newRecording() {

194         getRecorder(); // ensure notification listener is setup
<span class="line-modified">195         return new Recording().getId();</span>





196     }
197 
198     @Override
199     public long takeSnapshot() {

200         return getRecorder().takeSnapshot().getId();
201     }
202 
203     @Override
204     public void setConfiguration(long recording, String contents) throws IllegalArgumentException {
205         Objects.requireNonNull(contents, &quot;contents&quot;);

206         try {
207             Configuration c = Configuration.create(new StringReader(contents));
208             getExistingRecording(recording).setSettings(c.getSettings());
209         } catch (IOException | ParseException e) {
210             throw new IllegalArgumentException(&quot;Could not parse configuration&quot;, e);
211         }
212     }
213 
214     @Override
215     public void setPredefinedConfiguration(long recording, String configurationName) throws IllegalArgumentException {
216         Objects.requireNonNull(configurationName, &quot;configurationName&quot;);

217         Recording r = getExistingRecording(recording);
218         for (Configuration c : Configuration.getConfigurations()) {
219             if (c.getName().equals(configurationName)) {
220                 r.setSettings(c.getSettings());
221                 return;
222             }
223         }
224         throw new IllegalArgumentException(&quot;Could not find configuration with name &quot; + configurationName);
225     }
226 
227     @Override
228     public void copyTo(long recording, String outputFile) throws IOException {
229         Objects.requireNonNull(outputFile, &quot;outputFile&quot;);

230         getExistingRecording(recording).dump(Paths.get(outputFile));
231     }
232 
233     @Override
234     public void setRecordingOptions(long recording, Map&lt;String, String&gt; options) throws IllegalArgumentException {
235         Objects.requireNonNull(options, &quot;options&quot;);

236         // Make local copy to prevent concurrent modification
237         Map&lt;String, String&gt; ops = new HashMap&lt;String, String&gt;(options);
238         for (Map.Entry&lt;String, String&gt; entry : ops.entrySet()) {
239             Object key = entry.getKey();
240             Object value = entry.getValue();
241             // Keys and values may be sent over the network
242             if (!(key instanceof String)) {
243                 throw new IllegalArgumentException(&quot;Option key must not be null, or other type than &quot; + String.class);
244             }
245             if (!OPTIONS.contains(key)) {
246                 throw new IllegalArgumentException(&quot;Unknown recording option: &quot; + key + &quot;. Valid options are &quot; + OPTIONS + &quot;.&quot;);
247             }
248             if (value != null &amp;&amp; !(value instanceof String)) {
249                 throw new IllegalArgumentException(&quot;Incorrect value for option &quot; + key + &quot;. Values must be of type &quot; + String.class + &quot; .&quot;);
250             }
251         }
252 
253         Recording r = getExistingRecording(recording);
254         validateOption(ops, OPTION_DUMP_ON_EXIT, MBeanUtils::booleanValue);
255         validateOption(ops, OPTION_DISK, MBeanUtils::booleanValue);
256         validateOption(ops, OPTION_NAME, Function.identity());
257         validateOption(ops, OPTION_MAX_AGE, MBeanUtils::duration);
258         validateOption(ops, OPTION_MAX_SIZE, MBeanUtils::size);
259         validateOption(ops, OPTION_DURATION, MBeanUtils::duration);
260         validateOption(ops, OPTION_DESTINATION, x -&gt; MBeanUtils.destination(r, x));
261 
262         // All OK, now set them
263         setOption(ops, OPTION_DUMP_ON_EXIT, &quot;false&quot;, MBeanUtils::booleanValue, r::setDumpOnExit);
264         setOption(ops, OPTION_DISK, &quot;true&quot;, MBeanUtils::booleanValue, r::setToDisk);
265         setOption(ops, OPTION_NAME, String.valueOf(r.getId()), Function.identity(), r::setName);
266         setOption(ops, OPTION_MAX_AGE, null, MBeanUtils::duration, r::setMaxAge);
267         setOption(ops, OPTION_MAX_SIZE, &quot;0&quot;, MBeanUtils::size, r::setMaxSize);
268         setOption(ops, OPTION_DURATION, null, MBeanUtils::duration, r::setDuration);
269         setOption(ops, OPTION_DESTINATION, null, x -&gt; MBeanUtils.destination(r, x), x -&gt; setOptionDestination(r, x));
270     }
271 
272     @Override
273     public Map&lt;String, String&gt; getRecordingOptions(long recording) throws IllegalArgumentException {

274         Recording r = getExistingRecording(recording);
275         Map&lt;String, String&gt; options = HashMap.newHashMap(10);
276         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
277         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
278         options.put(OPTION_NAME, String.valueOf(r.getName()));
279         options.put(OPTION_MAX_AGE, ManagementSupport.formatTimespan(r.getMaxAge(), &quot; &quot;));
280         Long maxSize = r.getMaxSize();
281         options.put(OPTION_MAX_SIZE, String.valueOf(maxSize == null ? &quot;0&quot; : maxSize.toString()));
282         options.put(OPTION_DURATION, ManagementSupport.formatTimespan(r.getDuration(), &quot; &quot;));
283         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));
284         return options;
285     }
286 
287     @Override
<span class="line-modified">288     public long cloneRecording(long id, boolean stop) throws IllegalStateException {</span>

289         return getRecording(id).copy(stop).getId();
290     }
291 
292     @Override
293     public ObjectName getObjectName() {
294         return MBeanUtils.createObjectName();
295     }
296 
297     private Recording getExistingRecording(long id) {
298         if (FlightRecorder.isInitialized()) {
299             Recording recording = getRecording(id);
300             if (recording != null) {
301                 return recording;
302             }
303         }
304         throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
305     }
306 
307     private Recording getRecording(long id) {
308         List&lt;Recording&gt; recs = getRecorder().getRecordings();
</pre>
<hr />
<pre>
334         } catch (IOException e) {
335             IllegalArgumentException iae = new IllegalArgumentException(&quot;Not a valid destination &quot; + destination);
336             iae.addSuppressed(e);
337             throw iae;
338         }
339     }
340 
341     private static &lt;T, U&gt; void validateOption(Map&lt;String, String&gt; options, String name, Function&lt;String, U&gt; validator) {
342         try {
343             String v = options.get(name);
344             if (v == null) {
345                 return; // OK, will set default
346             }
347             validator.apply(v);
348         } catch (IllegalArgumentException iae) {
349             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
350         }
351     }
352 
353     @SuppressWarnings(&quot;removal&quot;)
<span class="line-modified">354     private FlightRecorder getRecorder() {</span>
355         // Synchronize on some private object that is always available
356         synchronized (streamHandler) {
357             if (recorder == null) {
<span class="line-modified">358                 recorder = FlightRecorder.getFlightRecorder();</span>





359             }
360             return recorder;
361         }
362     }
363 
364     private static MBeanNotificationInfo[] createNotificationInfo() {
365         String[] types = new String[] { AttributeChangeNotification.ATTRIBUTE_CHANGE };
366         String name = AttributeChangeNotification.class.getName();
367         String description = &quot;Notifies if the RecordingState has changed for one of the recordings, for example if a recording starts or stops&quot;;
368         MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
369         return new MBeanNotificationInfo[] { info };
370     }
371 
372     @SuppressWarnings(&quot;removal&quot;)
373     @Override
374     public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) {
375         MXBeanListener mxbeanListener = new MXBeanListener(listener, filter, handback);
376         listeners.add(mxbeanListener);
<span class="line-modified">377         FlightRecorder.addListener(mxbeanListener);</span>






378         super.addNotificationListener(listener, filter, handback);
379     }
380 
381     @Override
382     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
383         removeListeners( x -&gt; listener == x.listener);
384         super.removeNotificationListener(listener);
385     }
386 
387     @Override
388     public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException {
389         removeListeners( x -&gt; listener == x.listener &amp;&amp; filter == x.filter &amp;&amp; handback == x.handback);
390         super.removeNotificationListener(listener, filter, handback);
391     }
392 
393     private void removeListeners(Predicate&lt;MXBeanListener&gt; p) {
394         List&lt;MXBeanListener&gt; toBeRemoved = new ArrayList&lt;&gt;(listeners.size());
395         for (MXBeanListener l : listeners) {
396             if (p.test(l)) {
397                 toBeRemoved.add(l);
</pre>
</td>
</tr>
</table>
<center><a href="DiskRepository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MBeanUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>