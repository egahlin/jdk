diff a/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java b/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
--- a/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
+++ b/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,13 +28,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.text.ParseException;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -65,11 +62,10 @@
 
 import jdk.jfr.Configuration;
 import jdk.jfr.EventType;
 import jdk.jfr.FlightRecorder;
 import jdk.jfr.FlightRecorderListener;
-import jdk.jfr.FlightRecorderPermission;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.internal.management.ManagementSupport;
 import jdk.jfr.internal.management.StreamManager;
 
@@ -78,30 +74,21 @@
 
     final class MXBeanListener implements FlightRecorderListener {
         private final NotificationListener listener;
         private final NotificationFilter filter;
         private final Object handback;
-        @SuppressWarnings("removal")
-        private final AccessControlContext context;
 
         @SuppressWarnings("removal")
         public MXBeanListener(NotificationListener listener, NotificationFilter filter, Object handback) {
-            this.context = AccessController.getContext();
             this.listener = listener;
             this.filter = filter;
             this.handback = handback;
         }
 
         @SuppressWarnings("removal")
         public void recordingStateChanged(Recording recording) {
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                @Override
-                public Void run() {
-                    sendNotification(createNotification(recording));
-                    return null;
-                }
-            }, context);
+            sendNotification(createNotification(recording));
         }
     }
 
     private static final String ATTRIBUTE_RECORDINGS = "Recordings";
     private static final String OPTION_MAX_SIZE = "maxSize";
@@ -122,29 +109,25 @@
         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
     }
 
     @Override
     public void startRecording(long id) {
-        MBeanUtils.checkControl();
         getExistingRecording(id).start();
     }
 
     @Override
     public boolean stopRecording(long id) {
-        MBeanUtils.checkControl();
         return getExistingRecording(id).stop();
     }
 
     @Override
     public void closeRecording(long id) {
-        MBeanUtils.checkControl();
         getExistingRecording(id).close();
     }
 
     @Override
     public long openStream(long id, Map<String, String> options) throws IOException {
-        MBeanUtils.checkControl();
         if (!FlightRecorder.isInitialized()) {
             throw new IllegalArgumentException("No recording available with id " + id);
         }
         // Make local copy to prevent concurrent modification
         Map<String, String> s = options == null ? new HashMap<>() : new HashMap<>(options);
@@ -167,85 +150,61 @@
         return streamHandler.create(is, blockSize).getId();
     }
 
     @Override
     public void closeStream(long streamIdentifier) throws IOException {
-        MBeanUtils.checkControl();
         streamHandler.getStream(streamIdentifier).close();
     }
 
     @Override
     public byte[] readStream(long streamIdentifier) throws IOException {
-        MBeanUtils.checkMonitor();
         return streamHandler.getStream(streamIdentifier).read();
     }
 
     @Override
     public List<RecordingInfo> getRecordings() {
-        MBeanUtils.checkMonitor();
         if (!FlightRecorder.isInitialized()) {
             return Collections.emptyList();
         }
         return MBeanUtils.transformList(getRecorder().getRecordings(), RecordingInfo::new);
     }
 
     @Override
     public List<ConfigurationInfo> getConfigurations() {
-        MBeanUtils.checkMonitor();
         return MBeanUtils.transformList(Configuration.getConfigurations(), ConfigurationInfo::new);
     }
 
     @Override
     public List<EventTypeInfo> getEventTypes() {
-        MBeanUtils.checkMonitor();
-        @SuppressWarnings("removal")
-        List<EventType> eventTypes = AccessController.doPrivileged(new PrivilegedAction<List<EventType>>() {
-            @Override
-            public List<EventType> run() {
-                return ManagementSupport.getEventTypes();
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder"));
-
-        return MBeanUtils.transformList(eventTypes, EventTypeInfo::new);
+        return MBeanUtils.transformList(ManagementSupport.getEventTypes(), EventTypeInfo::new);
     }
 
     @Override
     public Map<String, String> getRecordingSettings(long recording) throws IllegalArgumentException {
-        MBeanUtils.checkMonitor();
         return getExistingRecording(recording).getSettings();
     }
 
     @Override
     public void setRecordingSettings(long recording, Map<String, String> settings) throws IllegalArgumentException {
         Objects.requireNonNull(settings, "settings");
-        MBeanUtils.checkControl();
         getExistingRecording(recording).setSettings(settings);
     }
 
-    @SuppressWarnings("removal")
     @Override
     public long newRecording() {
-        MBeanUtils.checkControl();
         getRecorder(); // ensure notification listener is setup
-        return AccessController.doPrivileged(new PrivilegedAction<Recording>() {
-            @Override
-            public Recording run() {
-                return new Recording();
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder")).getId();
+        return new Recording().getId();
     }
 
     @Override
     public long takeSnapshot() {
-        MBeanUtils.checkControl();
         return getRecorder().takeSnapshot().getId();
     }
 
     @Override
     public void setConfiguration(long recording, String contents) throws IllegalArgumentException {
         Objects.requireNonNull(contents, "contents");
-        MBeanUtils.checkControl();
         try {
             Configuration c = Configuration.create(new StringReader(contents));
             getExistingRecording(recording).setSettings(c.getSettings());
         } catch (IOException | ParseException e) {
             throw new IllegalArgumentException("Could not parse configuration", e);
@@ -253,11 +212,10 @@
     }
 
     @Override
     public void setPredefinedConfiguration(long recording, String configurationName) throws IllegalArgumentException {
         Objects.requireNonNull(configurationName, "configurationName");
-        MBeanUtils.checkControl();
         Recording r = getExistingRecording(recording);
         for (Configuration c : Configuration.getConfigurations()) {
             if (c.getName().equals(configurationName)) {
                 r.setSettings(c.getSettings());
                 return;
@@ -267,18 +225,16 @@
     }
 
     @Override
     public void copyTo(long recording, String outputFile) throws IOException {
         Objects.requireNonNull(outputFile, "outputFile");
-        MBeanUtils.checkControl();
         getExistingRecording(recording).dump(Paths.get(outputFile));
     }
 
     @Override
     public void setRecordingOptions(long recording, Map<String, String> options) throws IllegalArgumentException {
         Objects.requireNonNull(options, "options");
-        MBeanUtils.checkControl();
         // Make local copy to prevent concurrent modification
         Map<String, String> ops = new HashMap<String, String>(options);
         for (Map.Entry<String, String> entry : ops.entrySet()) {
             Object key = entry.getKey();
             Object value = entry.getValue();
@@ -313,11 +269,10 @@
         setOption(ops, OPTION_DESTINATION, null, x -> MBeanUtils.destination(r, x), x -> setOptionDestination(r, x));
     }
 
     @Override
     public Map<String, String> getRecordingOptions(long recording) throws IllegalArgumentException {
-        MBeanUtils.checkMonitor();
         Recording r = getExistingRecording(recording);
         Map<String, String> options = HashMap.newHashMap(10);
         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
         options.put(OPTION_NAME, String.valueOf(r.getName()));
@@ -328,12 +283,11 @@
         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));
         return options;
     }
 
     @Override
-    public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {
-        MBeanUtils.checkControl();
+    public long cloneRecording(long id, boolean stop) throws IllegalStateException {
         return getRecording(id).copy(stop).getId();
     }
 
     @Override
     public ObjectName getObjectName() {
@@ -395,20 +349,15 @@
             throw new IllegalArgumentException("Not a valid value for option '" + name + "'. " + iae.getMessage());
         }
     }
 
     @SuppressWarnings("removal")
-    private FlightRecorder getRecorder() throws SecurityException {
+    private FlightRecorder getRecorder() {
         // Synchronize on some private object that is always available
         synchronized (streamHandler) {
             if (recorder == null) {
-                recorder = AccessController.doPrivileged(new PrivilegedAction<FlightRecorder>() {
-                    @Override
-                    public FlightRecorder run() {
-                        return FlightRecorder.getFlightRecorder();
-                    }
-                }, null, new FlightRecorderPermission("accessFlightRecorder"));
+                recorder = FlightRecorder.getFlightRecorder();
             }
             return recorder;
         }
     }
 
@@ -423,17 +372,11 @@
     @SuppressWarnings("removal")
     @Override
     public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) {
         MXBeanListener mxbeanListener = new MXBeanListener(listener, filter, handback);
         listeners.add(mxbeanListener);
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run(){
-                FlightRecorder.addListener(mxbeanListener);
-                return null;
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder"));
+        FlightRecorder.addListener(mxbeanListener);
         super.addNotificationListener(listener, filter, handback);
     }
 
     @Override
     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
