<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.lang.invoke.MethodHandle;
 29 import java.lang.invoke.MethodHandles;
 30 import java.util.ArrayList;
 31 import java.util.HashSet;
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.Set;
 35 
 36 import jdk.internal.module.Checks;
 37 import jdk.jfr.internal.EventClassBuilder;
 38 import jdk.jfr.internal.JVMSupport;
 39 import jdk.jfr.internal.MetadataRepository;
<a name="2" id="anc2"></a>
 40 import jdk.jfr.internal.Type;
 41 import jdk.jfr.internal.util.Utils;
 42 
 43 /**
 44  * Class for defining an event at runtime.
 45  * &lt;p&gt;
 46  * It&#39;s highly recommended that the event is defined at compile time, if the
 47  * field layout is known, so the Java Virtual Machine (JVM) can optimize the
 48  * code, possibly remove all instrumentation if Flight Recorder is inactive or
 49  * if the enabled setting for this event is set to {@code false}.
 50  * &lt;p&gt;
 51  * To define an event at compile time, see {@link Event}.
 52  * &lt;p&gt;
 53  * The following example shows how to implement a dynamic {@code Event} class.
 54  *
 55  * {@snippet class=&quot;Snippets&quot; region=&quot;EventFactoryOverview&quot;}
 56  *
 57  * @since 9
 58  */
 59 public final class EventFactory {
 60 
 61     private static final long REGISTERED_ID = Type.getTypeId(Registered.class);
 62 
 63     private final Class&lt;? extends Event&gt; eventClass;
 64     private final MethodHandle constructorHandle;
 65     private final List&lt;AnnotationElement&gt; sanitizedAnnotation;
 66     private final List&lt;ValueDescriptor&gt; sanitizedFields;
 67 
 68     private EventFactory(Class&lt;? extends Event&gt; eventClass, List&lt;AnnotationElement&gt; sanitizedAnnotation, List&lt;ValueDescriptor&gt; sanitizedFields) throws IllegalAccessException, NoSuchMethodException, SecurityException {
 69         this.constructorHandle = MethodHandles.lookup().unreflectConstructor(eventClass.getConstructor());
 70         this.eventClass = eventClass;
 71         this.sanitizedAnnotation = sanitizedAnnotation;
 72         this.sanitizedFields = sanitizedFields;
 73     }
 74 
 75     /**
 76      * Creates an {@code EventFactory} object.
 77      * &lt;p&gt;
 78      * The order of the value descriptors specifies the index to use when setting
 79      * event values.
 80      *
 81      * @param annotationElements list of annotation elements that describes the
 82      *        annotations on the event, not {@code null}
 83      *
 84      * @param fields list of descriptors that describes the fields of the event, not
 85      *        {@code null}
 86      *
 87      * @return event factory, not {@code null}
 88      *
 89      * @throws IllegalArgumentException if the input is not valid. For example,
 90      *         input might not be valid if the field type or name is not valid in
 91      *         the Java language or an annotation element references a type that
 92      *         can&#39;t be found.
 93      *
 94      * @see Event#set(int, Object)
 95      */
 96     public static EventFactory create(List&lt;AnnotationElement&gt; annotationElements, List&lt;ValueDescriptor&gt; fields) {
 97         Objects.requireNonNull(annotationElements, &quot;annotationElements&quot;);
 98         Objects.requireNonNull(fields, &quot;fields&quot;);
 99         JVMSupport.ensureWithInternalError();
100 
<a name="3" id="anc3"></a>

101         List&lt;AnnotationElement&gt; sanitizedAnnotation = Utils.sanitizeNullFreeList(annotationElements, AnnotationElement.class);
102         List&lt;ValueDescriptor&gt; sanitizedFields = Utils.sanitizeNullFreeList(fields, ValueDescriptor.class);
103         Set&lt;String&gt; nameSet = HashSet.newHashSet(sanitizedFields.size());
104         for (ValueDescriptor v : sanitizedFields) {
105             String name = v.getName();
106             if (v.isArray()) {
107                 throw new IllegalArgumentException(&quot;Array types are not allowed for fields&quot;);
108             }
109             if (!Type.isValidJavaFieldType(v.getTypeName())) {
110                 throw new IllegalArgumentException(v.getTypeName() + &quot; is not a valid type for an event field&quot;);
111             }
112             if (!Checks.isJavaIdentifier(v.getName())) {
113                 throw new IllegalArgumentException(name + &quot; is not a valid name for an event field&quot;);
114             }
115             if (nameSet.contains(name)) {
116                 throw new IllegalArgumentException(&quot;Name of fields must be unique. Found two instances of &quot; + name);
117             }
118             nameSet.add(name);
119         }
120 
121         // Prevent event from being registered in &lt;clinit&gt;
122         // and only use annotations that can be resolved (those in boot class loader)
123         boolean needRegister = true;
124         List&lt;AnnotationElement&gt; bootAnnotations = new ArrayList&lt;&gt;();
125         for (AnnotationElement ae : sanitizedAnnotation) {
126             long id = ae.getTypeId();
127             if (ae.isInBoot()) {
128                 if (id == REGISTERED_ID) {
129                     if (Boolean.FALSE.equals(ae.getValue(&quot;value&quot;))) {
130                         needRegister = false;
131                     }
132                 } else {
133                     bootAnnotations.add(ae);
134                 }
135             }
136         }
137         bootAnnotations.add(new AnnotationElement(Registered.class, false));
138 
139         EventClassBuilder ecb = new EventClassBuilder(bootAnnotations, sanitizedFields);
140         Class&lt;? extends Event&gt; eventClass = ecb.build();
141 
142         if (needRegister) {
143             MetadataRepository.getInstance().register(eventClass, sanitizedAnnotation, sanitizedFields);
144         }
145         try {
146             return new EventFactory(eventClass, sanitizedAnnotation, sanitizedFields);
147         } catch (IllegalAccessException e) {
148             throw new IllegalAccessError(&quot;Could not access constructor of generated event class, &quot; + e.getMessage());
149         } catch (NoSuchMethodException e) {
150             throw new InternalError(&quot;Could not find constructor in generated event class, &quot; + e.getMessage());
151         }
152     }
153 
154     /**
155      * Instantiates an event, so it can be populated with data and written to the
156      * Flight Recorder system.
157      * &lt;p&gt;
158      * Use the {@link Event#set(int, Object)} method to set a value.
159      *
160      * @return an event instance, not {@code null}
161      */
162     public Event newEvent() {
163         try {
164             return (Event) constructorHandle.invoke();
165         } catch (Throwable e) {
166             throw new InstantiationError(&quot;Could not instantiate dynamically generated event class &quot; + eventClass.getName() + &quot;. &quot; + e.getMessage());
167         }
168     }
169 
170     /**
171      * Returns the event type that is associated with this event factory.
172      *
173      * @return event type that is associated with this event factory, not
174      *         {@code null}
175      *
176      * @throws java.lang.IllegalStateException if the event factory is created with
177      *         the {@code Registered(false)} annotation and the event class is not
178      *         manually registered before the invocation of this method
179      */
180     public EventType getEventType() {
181         return EventType.getEventType(eventClass);
182     }
183 
184     /**
185      * Registers an unregistered event.
186      * &lt;p&gt;
187      * By default, the event class associated with this event factory is registered
188      * when the event factory is created, unless the event has the
189      * {@link Registered} annotation.
190      * &lt;p&gt;
191      * A registered event class can write data to Flight Recorder and event metadata
192      * can be obtained by invoking {@link FlightRecorder#getEventTypes()}.
193      * &lt;p&gt;
194      * If the event class associated with this event factory is already registered,
195      * the call to this method is ignored.
196      *
197      * @see Registered
198      * @see FlightRecorder#register(Class)
199      */
200     public void register() {
201         MetadataRepository.getInstance().register(eventClass, sanitizedAnnotation, sanitizedFields);
202     }
203 
204     /**
205      * Unregisters the event that is associated with this event factory.
206      * &lt;p&gt;
207      * A unregistered event class can&#39;t write data to Flight Recorder and event
208      * metadata can&#39;t be obtained by invoking
209      * {@link FlightRecorder#getEventTypes()}.
210      * &lt;p&gt;
211      * If the event class associated with this event factory is not already
212      * registered, the call to this method is ignored.
213      *
214      * @see Registered
215      * @see FlightRecorder#unregister(Class)
216      */
217     public void unregister() {
218         MetadataRepository.getInstance().unregister(eventClass);
219     }
220 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>