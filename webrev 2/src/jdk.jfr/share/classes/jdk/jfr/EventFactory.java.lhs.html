<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.lang.invoke.MethodHandle;
 29 import java.lang.invoke.MethodHandles;
 30 import java.util.ArrayList;
 31 import java.util.HashSet;
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.Set;
 35 
 36 import jdk.internal.module.Checks;
 37 import jdk.jfr.internal.EventClassBuilder;
 38 import jdk.jfr.internal.JVMSupport;
 39 import jdk.jfr.internal.MetadataRepository;
<a name="2" id="anc2"></a><span class="line-removed"> 40 import jdk.jfr.internal.SecuritySupport;</span>
 41 import jdk.jfr.internal.Type;
 42 import jdk.jfr.internal.util.Utils;
 43 
 44 /**
 45  * Class for defining an event at runtime.
 46  * &lt;p&gt;
 47  * It&#39;s highly recommended that the event is defined at compile time, if the
 48  * field layout is known, so the Java Virtual Machine (JVM) can optimize the
 49  * code, possibly remove all instrumentation if Flight Recorder is inactive or
 50  * if the enabled setting for this event is set to {@code false}.
 51  * &lt;p&gt;
 52  * To define an event at compile time, see {@link Event}.
 53  * &lt;p&gt;
 54  * The following example shows how to implement a dynamic {@code Event} class.
 55  *
 56  * {@snippet class=&quot;Snippets&quot; region=&quot;EventFactoryOverview&quot;}
 57  *
 58  * @since 9
 59  */
 60 public final class EventFactory {
 61 
 62     private static final long REGISTERED_ID = Type.getTypeId(Registered.class);
 63 
 64     private final Class&lt;? extends Event&gt; eventClass;
 65     private final MethodHandle constructorHandle;
 66     private final List&lt;AnnotationElement&gt; sanitizedAnnotation;
 67     private final List&lt;ValueDescriptor&gt; sanitizedFields;
 68 
 69     private EventFactory(Class&lt;? extends Event&gt; eventClass, List&lt;AnnotationElement&gt; sanitizedAnnotation, List&lt;ValueDescriptor&gt; sanitizedFields) throws IllegalAccessException, NoSuchMethodException, SecurityException {
 70         this.constructorHandle = MethodHandles.lookup().unreflectConstructor(eventClass.getConstructor());
 71         this.eventClass = eventClass;
 72         this.sanitizedAnnotation = sanitizedAnnotation;
 73         this.sanitizedFields = sanitizedFields;
 74     }
 75 
 76     /**
 77      * Creates an {@code EventFactory} object.
 78      * &lt;p&gt;
 79      * The order of the value descriptors specifies the index to use when setting
 80      * event values.
 81      *
 82      * @param annotationElements list of annotation elements that describes the
 83      *        annotations on the event, not {@code null}
 84      *
 85      * @param fields list of descriptors that describes the fields of the event, not
 86      *        {@code null}
 87      *
 88      * @return event factory, not {@code null}
 89      *
 90      * @throws IllegalArgumentException if the input is not valid. For example,
 91      *         input might not be valid if the field type or name is not valid in
 92      *         the Java language or an annotation element references a type that
 93      *         can&#39;t be found.
 94      *
 95      * @see Event#set(int, Object)
 96      */
 97     public static EventFactory create(List&lt;AnnotationElement&gt; annotationElements, List&lt;ValueDescriptor&gt; fields) {
 98         Objects.requireNonNull(annotationElements, &quot;annotationElements&quot;);
 99         Objects.requireNonNull(fields, &quot;fields&quot;);
100         JVMSupport.ensureWithInternalError();
101 
<a name="3" id="anc3"></a><span class="line-removed">102         SecuritySupport.checkRegisterPermission();</span>
<span class="line-removed">103 </span>
104         List&lt;AnnotationElement&gt; sanitizedAnnotation = Utils.sanitizeNullFreeList(annotationElements, AnnotationElement.class);
105         List&lt;ValueDescriptor&gt; sanitizedFields = Utils.sanitizeNullFreeList(fields, ValueDescriptor.class);
106         Set&lt;String&gt; nameSet = HashSet.newHashSet(sanitizedFields.size());
107         for (ValueDescriptor v : sanitizedFields) {
108             String name = v.getName();
109             if (v.isArray()) {
110                 throw new IllegalArgumentException(&quot;Array types are not allowed for fields&quot;);
111             }
112             if (!Type.isValidJavaFieldType(v.getTypeName())) {
113                 throw new IllegalArgumentException(v.getTypeName() + &quot; is not a valid type for an event field&quot;);
114             }
115             if (!Checks.isJavaIdentifier(v.getName())) {
116                 throw new IllegalArgumentException(name + &quot; is not a valid name for an event field&quot;);
117             }
118             if (nameSet.contains(name)) {
119                 throw new IllegalArgumentException(&quot;Name of fields must be unique. Found two instances of &quot; + name);
120             }
121             nameSet.add(name);
122         }
123 
124         // Prevent event from being registered in &lt;clinit&gt;
125         // and only use annotations that can be resolved (those in boot class loader)
126         boolean needRegister = true;
127         List&lt;AnnotationElement&gt; bootAnnotations = new ArrayList&lt;&gt;();
128         for (AnnotationElement ae : sanitizedAnnotation) {
129             long id = ae.getTypeId();
130             if (ae.isInBoot()) {
131                 if (id == REGISTERED_ID) {
132                     if (Boolean.FALSE.equals(ae.getValue(&quot;value&quot;))) {
133                         needRegister = false;
134                     }
135                 } else {
136                     bootAnnotations.add(ae);
137                 }
138             }
139         }
140         bootAnnotations.add(new AnnotationElement(Registered.class, false));
141 
142         EventClassBuilder ecb = new EventClassBuilder(bootAnnotations, sanitizedFields);
143         Class&lt;? extends Event&gt; eventClass = ecb.build();
144 
145         if (needRegister) {
146             MetadataRepository.getInstance().register(eventClass, sanitizedAnnotation, sanitizedFields);
147         }
148         try {
149             return new EventFactory(eventClass, sanitizedAnnotation, sanitizedFields);
150         } catch (IllegalAccessException e) {
151             throw new IllegalAccessError(&quot;Could not access constructor of generated event class, &quot; + e.getMessage());
152         } catch (NoSuchMethodException e) {
153             throw new InternalError(&quot;Could not find constructor in generated event class, &quot; + e.getMessage());
154         }
155     }
156 
157     /**
158      * Instantiates an event, so it can be populated with data and written to the
159      * Flight Recorder system.
160      * &lt;p&gt;
161      * Use the {@link Event#set(int, Object)} method to set a value.
162      *
163      * @return an event instance, not {@code null}
164      */
165     public Event newEvent() {
166         try {
167             return (Event) constructorHandle.invoke();
168         } catch (Throwable e) {
169             throw new InstantiationError(&quot;Could not instantiate dynamically generated event class &quot; + eventClass.getName() + &quot;. &quot; + e.getMessage());
170         }
171     }
172 
173     /**
174      * Returns the event type that is associated with this event factory.
175      *
176      * @return event type that is associated with this event factory, not
177      *         {@code null}
178      *
179      * @throws java.lang.IllegalStateException if the event factory is created with
180      *         the {@code Registered(false)} annotation and the event class is not
181      *         manually registered before the invocation of this method
182      */
183     public EventType getEventType() {
184         return EventType.getEventType(eventClass);
185     }
186 
187     /**
188      * Registers an unregistered event.
189      * &lt;p&gt;
190      * By default, the event class associated with this event factory is registered
191      * when the event factory is created, unless the event has the
192      * {@link Registered} annotation.
193      * &lt;p&gt;
194      * A registered event class can write data to Flight Recorder and event metadata
195      * can be obtained by invoking {@link FlightRecorder#getEventTypes()}.
196      * &lt;p&gt;
197      * If the event class associated with this event factory is already registered,
198      * the call to this method is ignored.
199      *
200      * @see Registered
201      * @see FlightRecorder#register(Class)
202      */
203     public void register() {
204         MetadataRepository.getInstance().register(eventClass, sanitizedAnnotation, sanitizedFields);
205     }
206 
207     /**
208      * Unregisters the event that is associated with this event factory.
209      * &lt;p&gt;
210      * A unregistered event class can&#39;t write data to Flight Recorder and event
211      * metadata can&#39;t be obtained by invoking
212      * {@link FlightRecorder#getEventTypes()}.
213      * &lt;p&gt;
214      * If the event class associated with this event factory is not already
215      * registered, the call to this method is ignored.
216      *
217      * @see Registered
218      * @see FlightRecorder#unregister(Class)
219      */
220     public void unregister() {
221         MetadataRepository.getInstance().unregister(eventClass);
222     }
223 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>