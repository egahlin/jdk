<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/jfr/support/jfrResolution.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EventFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.reflect.Method;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 import java.util.Set;
 38 import java.util.StringJoiner;
 39 
<span class="line-removed"> 40 import jdk.jfr.internal.SecuritySupport;</span>
 41 import jdk.jfr.internal.Type;
 42 import jdk.jfr.internal.TypeLibrary;
 43 import jdk.jfr.internal.util.Utils;
 44 
 45 /**
 46  * Describes event metadata, such as labels, descriptions and units.
 47  * &lt;p&gt;
 48  * The following example shows how {@code AnnotationElement} can be used to dynamically define events.
 49  *
 50  * {@snippet class=&quot;Snippets&quot; region=&quot;AnnotationElementOverview&quot;}
 51  *
 52  * @since 9
 53  */
 54 public final class AnnotationElement {
 55     private final Type type;
 56     private final List&lt;Object&gt; annotationValues;
 57     private final boolean inBootClassLoader;
 58 
 59     // package private
 60     AnnotationElement(Type type, List&lt;Object&gt; objects, boolean boot) {
</pre>
<hr />
<pre>
 98      * and {@code String}. Enums, arrays and classes, are not supported.
 99      * &lt;p&gt;
100      * If {@code annotationType} has annotations (directly present, indirectly
101      * present, or associated), then those annotation are recursively included.
102      * However, both the {@code annotationType} and any annotation found recursively
103      * must have the {@link MetadataDefinition} annotation.
104      * &lt;p&gt;
105      * To statically define events, see {@link Event} class.
106      *
107      * @param annotationType interface extending
108      *        {@code java.lang.annotation.Annotation}, not {@code null}
109      * @param values a {@code Map} with keys that match method names of the specified
110      *        annotation interface
111      * @throws IllegalArgumentException if value/key is {@code null}, an unsupported
112      *         value type is used, or a value/key is used that doesn&#39;t match the
113      *         signatures in the {@code annotationType}
114      */
115     public AnnotationElement(Class&lt;? extends Annotation&gt; annotationType, Map&lt;String, Object&gt; values) {
116         Objects.requireNonNull(annotationType, &quot;annotationType&quot;);
117         Objects.requireNonNull(values, &quot;values&quot;);
<span class="line-removed">118         SecuritySupport.checkRegisterPermission();</span>
119         // copy values to avoid modification after validation
120         HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(values);
121         for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
122             if (entry.getKey() == null) {
123                 throw new NullPointerException(&quot;Name of annotation method can&#39;t be null&quot;);
124             }
125             if (entry.getValue() == null) {
126                 throw new NullPointerException(&quot;Return value for annotation method can&#39;t be null&quot;);
127             }
128         }
129 
130         if (AnnotationElement.class.isAssignableFrom(annotationType) &amp;&amp; annotationType.isInterface()) {
131             throw new IllegalArgumentException(&quot;Must be interface extending &quot; + Annotation.class.getName());
132         }
133         if (!isKnownJFRAnnotation(annotationType) &amp;&amp; annotationType.getAnnotation(MetadataDefinition.class) == null) {
134             throw new IllegalArgumentException(&quot;Annotation class must be annotated with jdk.jfr.MetadataDefinition to be valid&quot;);
135         }
136         if (isKnownJFRAnnotation(annotationType)) {
137             this.type = new Type(annotationType.getCanonicalName(), Type.SUPER_TYPE_ANNOTATION, Type.getTypeId(annotationType));
138         } else {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.reflect.Method;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 import java.util.Set;
 38 import java.util.StringJoiner;
 39 

 40 import jdk.jfr.internal.Type;
 41 import jdk.jfr.internal.TypeLibrary;
 42 import jdk.jfr.internal.util.Utils;
 43 
 44 /**
 45  * Describes event metadata, such as labels, descriptions and units.
 46  * &lt;p&gt;
 47  * The following example shows how {@code AnnotationElement} can be used to dynamically define events.
 48  *
 49  * {@snippet class=&quot;Snippets&quot; region=&quot;AnnotationElementOverview&quot;}
 50  *
 51  * @since 9
 52  */
 53 public final class AnnotationElement {
 54     private final Type type;
 55     private final List&lt;Object&gt; annotationValues;
 56     private final boolean inBootClassLoader;
 57 
 58     // package private
 59     AnnotationElement(Type type, List&lt;Object&gt; objects, boolean boot) {
</pre>
<hr />
<pre>
 97      * and {@code String}. Enums, arrays and classes, are not supported.
 98      * &lt;p&gt;
 99      * If {@code annotationType} has annotations (directly present, indirectly
100      * present, or associated), then those annotation are recursively included.
101      * However, both the {@code annotationType} and any annotation found recursively
102      * must have the {@link MetadataDefinition} annotation.
103      * &lt;p&gt;
104      * To statically define events, see {@link Event} class.
105      *
106      * @param annotationType interface extending
107      *        {@code java.lang.annotation.Annotation}, not {@code null}
108      * @param values a {@code Map} with keys that match method names of the specified
109      *        annotation interface
110      * @throws IllegalArgumentException if value/key is {@code null}, an unsupported
111      *         value type is used, or a value/key is used that doesn&#39;t match the
112      *         signatures in the {@code annotationType}
113      */
114     public AnnotationElement(Class&lt;? extends Annotation&gt; annotationType, Map&lt;String, Object&gt; values) {
115         Objects.requireNonNull(annotationType, &quot;annotationType&quot;);
116         Objects.requireNonNull(values, &quot;values&quot;);

117         // copy values to avoid modification after validation
118         HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(values);
119         for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
120             if (entry.getKey() == null) {
121                 throw new NullPointerException(&quot;Name of annotation method can&#39;t be null&quot;);
122             }
123             if (entry.getValue() == null) {
124                 throw new NullPointerException(&quot;Return value for annotation method can&#39;t be null&quot;);
125             }
126         }
127 
128         if (AnnotationElement.class.isAssignableFrom(annotationType) &amp;&amp; annotationType.isInterface()) {
129             throw new IllegalArgumentException(&quot;Must be interface extending &quot; + Annotation.class.getName());
130         }
131         if (!isKnownJFRAnnotation(annotationType) &amp;&amp; annotationType.getAnnotation(MetadataDefinition.class) == null) {
132             throw new IllegalArgumentException(&quot;Annotation class must be annotated with jdk.jfr.MetadataDefinition to be valid&quot;);
133         }
134         if (isKnownJFRAnnotation(annotationType)) {
135             this.type = new Type(annotationType.getCanonicalName(), Type.SUPER_TYPE_ANNOTATION, Type.getTypeId(annotationType));
136         } else {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/jfr/support/jfrResolution.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EventFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>