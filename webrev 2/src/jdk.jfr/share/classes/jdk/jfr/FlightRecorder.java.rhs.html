<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogLevel.INFO;
 30 import static jdk.jfr.internal.LogTag.JFR;
 31 
<a name="2" id="anc2"></a>

 32 import java.util.ArrayList;
 33 import java.util.Collections;
 34 import java.util.List;
 35 import java.util.Objects;
 36 
 37 import jdk.jfr.internal.JVM;
 38 import jdk.jfr.internal.JVMSupport;
 39 import jdk.jfr.internal.Logger;
 40 import jdk.jfr.internal.MetadataRepository;
 41 import jdk.jfr.internal.Options;
 42 import jdk.jfr.internal.PlatformRecorder;
 43 import jdk.jfr.internal.PlatformRecording;
 44 import jdk.jfr.internal.Repository;
<a name="3" id="anc3"></a>
 45 import jdk.jfr.internal.util.Utils;
 46 import jdk.jfr.internal.periodic.PeriodicEvents;
 47 
 48 /**
 49  * Class for accessing, controlling, and managing Flight Recorder.
 50  * &lt;p&gt;
 51  * This class provides the methods necessary for creating, starting, stopping,
 52  * and destroying recordings.
 53  *
 54  * @since 9
 55  */
 56 public final class FlightRecorder {
 57     private static volatile FlightRecorder platformRecorder;
 58     private static volatile boolean initialized;
 59     private final PlatformRecorder internal;
 60 
 61     private FlightRecorder(PlatformRecorder internal) {
 62         this.internal = internal;
 63     }
 64 
 65     /**
 66      * Returns an immutable list of the available recordings.
 67      * &lt;p&gt;
 68      * A recording becomes available when it is created. It becomes unavailable when it
 69      * is in the {@code CLOSED} state, typically after a call to
 70      * {@link Recording#close()}.
 71      *
 72      * @return a list of recordings, not {@code null}
 73      */
 74     public List&lt;Recording&gt; getRecordings() {
 75         List&lt;Recording&gt; recs = new ArrayList&lt;&gt;();
 76         for (PlatformRecording r : internal.getRecordings()) {
 77             recs.add(r.getRecording());
 78         }
 79         return Collections.unmodifiableList(recs);
 80     }
 81 
 82     /**
 83      * Creates a snapshot of all available recorded data.
 84      * &lt;p&gt;
 85      * A snapshot is a synthesized recording in a {@code STOPPED} state. If no data is
 86      * available, a recording with size {@code 0} is returned.
 87      * &lt;p&gt;
 88      * A snapshot provides stable access to data for later operations (for example,
 89      * operations to change the interval or to reduce the data size).
 90      * &lt;p&gt;
 91      * The following example shows how to create a snapshot and write a subset of the data to a file.
 92      *
 93      * {@snippet class=&quot;Snippets&quot; region=&quot;FlightRecorderTakeSnapshot&quot;}
 94      *
 95      * The caller must close the recording when access to the data is no longer
 96      * needed.
 97      *
 98      * @return a snapshot of all available recording data, not {@code null}
 99      */
100     public Recording takeSnapshot() {
101         Recording snapshot = new Recording();
102         snapshot.setName(&quot;Snapshot&quot;);
103         internal.fillWithRecordedData(snapshot.getInternal(), null);
104         return snapshot;
105     }
106 
107     /**
108      * Registers an event class.
109      * &lt;p&gt;
110      * If the event class is already registered, then the invocation of this method is
111      * ignored.
112      *
113      * @param eventClass the event class to register, not {@code null}
114      *
115      * @throws IllegalArgumentException if class is abstract or not a subclass
116      *         of {@link Event}
117      */
118     public static void register(Class&lt;? extends Event&gt; eventClass) {
119         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
120         if (JVMSupport.isNotAvailable()) {
121             return;
122         }
123         Utils.ensureValidEventSubclass(eventClass);
124         MetadataRepository.getInstance().register(eventClass);
125     }
126 
127     /**
128      * Unregisters an event class.
129      * &lt;p&gt;
130      * If the event class is not registered, then the invocation of this method is
131      * ignored.
132      *
133      * @param eventClass the event class to unregistered, not {@code null}
134      * @throws IllegalArgumentException if a class is abstract or not a subclass
135      *         of {@link Event}
136      */
137     public static void unregister(Class&lt;? extends Event&gt; eventClass) {
138         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
139         if (JVMSupport.isNotAvailable()) {
140             return;
141         }
142         Utils.ensureValidEventSubclass(eventClass);
143         MetadataRepository.getInstance().unregister(eventClass);
144     }
145 
146     /**
147      * Returns the Flight Recorder for the platform.
148      *
149      * @return a Flight Recorder instance, not {@code null}
150      *
151      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
152      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
153      *         support, or if the file repository can&#39;t be created or accessed)
154      */
155     public static FlightRecorder getFlightRecorder() throws IllegalStateException {
156         synchronized (PlatformRecorder.class) {
<a name="4" id="anc4"></a>
157             JVMSupport.ensureWithIllegalStateException();
158             if (platformRecorder == null) {
159                 try {
160                     platformRecorder = new FlightRecorder(new PlatformRecorder());
161                 } catch (IllegalStateException ise) {
162                     throw ise;
163                 } catch (Exception e) {
164                     throw new IllegalStateException(&quot;Can&#39;t create Flight Recorder. &quot; + e.getMessage(), e);
165                 }
166                 // Must be in synchronized block to prevent instance leaking out
167                 // before initialization is done
168                 initialized = true;
169                 Logger.log(JFR, INFO, &quot;Flight Recorder initialized&quot;);
170                 if (Logger.shouldLog(JFR, DEBUG)) {
171                     Logger.log(JFR, DEBUG, &quot;maxchunksize: &quot; + Options.getMaxChunkSize()+ &quot; bytes&quot;);
172                     Logger.log(JFR, DEBUG, &quot;memorysize: &quot; + Options.getMemorySize()+ &quot; bytes&quot;);
173                     Logger.log(JFR, DEBUG, &quot;globalbuffersize: &quot; + Options.getGlobalBufferSize()+ &quot; bytes&quot;);
174                     Logger.log(JFR, DEBUG, &quot;globalbuffercount: &quot; + Options.getGlobalBufferCount());
175                     Logger.log(JFR, DEBUG, &quot;dumppath: &quot; + Options.getDumpPath());
176                     Logger.log(JFR, DEBUG, &quot;stackdepth: &quot; + Options.getStackDepth());
177                     Logger.log(JFR, DEBUG, &quot;threadbuffersize: &quot; + Options.getThreadBufferSize());
178                 }
179                 if (Logger.shouldLog(JFR, INFO)) {
180                     Logger.log(JFR, INFO, &quot;Repository base directory: &quot; + Repository.getRepository().getBaseLocation());
181                 }
182                 PlatformRecorder.notifyRecorderInitialized(platformRecorder);
183             }
184         }
185         return platformRecorder;
186     }
187 
188     /**
189      * Adds a hook for a periodic event.
190      * &lt;p&gt;
191      * The implementation of the hook should return as soon as possible, to
192      * avoid blocking other Flight Recorder operations. The hook should emit
193      * one or more events of the specified type. When a hook is added, the
194      * interval at which the call is invoked is configurable using the
195      * {@code &quot;period&quot;} setting.
196      *
197      * @param eventClass the class that the hook should run for, not {@code null}
198      * @param hook the hook, not {@code null}
199      * @throws IllegalArgumentException if a class is not a subclass of
200      *         {@link Event}, is abstract, or the hook is already added
201      * @throws IllegalStateException if the event class has the
202      *         {@code Registered(false)} annotation and is not registered manually
203      */
204     public static void addPeriodicEvent(Class&lt;? extends Event&gt; eventClass, Runnable hook) {
205         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
206         Objects.requireNonNull(hook, &quot;hook&quot;);
207         if (JVMSupport.isNotAvailable()) {
208             return;
209         }
210 
211         Utils.ensureValidEventSubclass(eventClass);
<a name="5" id="anc5"></a><span class="line-modified">212         PeriodicEvents.addJavaEvent(eventClass, hook);</span>



213     }
214 
215     /**
216      * Removes a hook for a periodic event.
217      *
218      * @param hook the hook to remove, not {@code null}
219      * @return {@code true} if hook is removed, {@code false} otherwise
220      */
221     public static boolean removePeriodicEvent(Runnable hook) {
222         Objects.requireNonNull(hook, &quot;hook&quot;);
<a name="6" id="anc6"></a>
223         if (JVMSupport.isNotAvailable()) {
224             return false;
225         }
226         return PeriodicEvents.removeEvent(hook);
227     }
228 
229     /**
230      * Returns an immutable list that contains all currently registered events.
231      * &lt;p&gt;
232      * By default, events are registered when they are first used, typically
233      * when an event object is allocated. To ensure an event is visible early,
234      * registration can be triggered by invoking the
235      * {@link FlightRecorder#register(Class)} method.
236      *
237      * @return list of events, not {@code null}
238      */
239     public List&lt;EventType&gt; getEventTypes() {
240         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
241     }
242 
243     /**
<a name="7" id="anc7"></a><span class="line-modified">244      * Adds a recorder listener.</span>

245      * &lt;p&gt;
246      * If Flight Recorder is already initialized when the listener is added, then the method
247      * {@link FlightRecorderListener#recorderInitialized(FlightRecorder)} method is
248      * invoked before returning from this method.
249      *
250      * @param changeListener the listener to add, not {@code null}
251      */
252     public static void addListener(FlightRecorderListener changeListener) {
253         Objects.requireNonNull(changeListener, &quot;changeListener&quot;);
<a name="8" id="anc8"></a>
254         if (JVMSupport.isNotAvailable()) {
255             return;
256         }
257         PlatformRecorder.addListener(changeListener);
258     }
259 
260     /**
261      * Removes a recorder listener.
262      * &lt;p&gt;
263      * If the same listener is added multiple times, only one instance is
264      * removed.
265      *
266      * @param changeListener listener to remove, not {@code null}
267      *
268      * @return {@code true}, if the listener could be removed, {@code false}
269      *         otherwise
270      */
271     public static boolean removeListener(FlightRecorderListener changeListener) {
272         Objects.requireNonNull(changeListener, &quot;changeListener&quot;);
<a name="9" id="anc9"></a>
273         if (JVMSupport.isNotAvailable()) {
274             return false;
275         }
276 
277         return PlatformRecorder.removeListener(changeListener);
278     }
279 
280     /**
281      * Returns {@code true} if the Java Virtual Machine (JVM) has Flight Recorder capabilities.
282      * &lt;p&gt;
283      * This method can quickly check whether Flight Recorder can be
284      * initialized, without actually doing the initialization work. The value may
285      * change during runtime and it is not safe to cache it.
286      *
287      * @return {@code true}, if Flight Recorder is available, {@code false}
288      *         otherwise
289      *
290      * @see FlightRecorderListener for callback when Flight Recorder is
291      *      initialized
292      */
293     public static boolean isAvailable() {
294         if (JVMSupport.isNotAvailable()) {
295             return false;
296         }
297         return JVM.isAvailable();
298     }
299 
300     /**
301      * Returns {@code true} if Flight Recorder is initialized.
302      *
303      * @return {@code true}, if Flight Recorder is initialized,
304      *         {@code false} otherwise
305      *
306      * @see FlightRecorderListener for callback when Flight Recorder is
307      *      initialized
308      */
309     public static boolean isInitialized() {
310         return initialized;
311     }
312 
313     PlatformRecorder getInternal() {
314         return internal;
315     }
316 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>