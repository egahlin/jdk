<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/ValueDescriptor.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Objects;
 32 
 33 import jdk.jfr.internal.AnnotationConstruct;
<a name="2" id="anc2"></a>
 34 import jdk.jfr.internal.Type;
 35 import jdk.jfr.internal.util.Utils;
 36 
 37 /**
 38  * Describes the event fields and annotation elements.
 39  * &lt;p&gt;
 40  * The following example shows how the {@code ValueDescriptor} class can
 41  * be used to list field information of all types.
 42  *
 43  * {@snippet class=&quot;Snippets&quot; region=&quot;ValueDescriptorOverview&quot;}
 44  *
 45  * @since 9
 46  */
 47 public final class ValueDescriptor {
 48     private static final String UNKNOWN = new String();
 49     private final AnnotationConstruct annotationConstruct;
 50     private final Type type;
 51     private final String name;
 52     private final boolean isArray;
 53     private final boolean constantPool;
 54     private final String javaFieldName;
 55     private String label = UNKNOWN;
 56     private String contentType = UNKNOWN;
 57 
 58     // package private, invoked by jdk.internal.
 59     ValueDescriptor(Type type, String name, List&lt;AnnotationElement&gt; annotations, int dimension, boolean constantPool, String fieldName) {
 60         Objects.requireNonNull(annotations);
 61         if (dimension &lt; 0) {
 62             throw new IllegalArgumentException(&quot;Dimension must be positive&quot;);
 63         }
 64         this.name = Objects.requireNonNull(name, &quot;Name of value descriptor can&#39;t be null&quot;);
 65         this.type = Objects.requireNonNull(type);
 66         this.isArray = dimension &gt; 0;
 67         this.constantPool = constantPool;
 68         this.annotationConstruct = new AnnotationConstruct(annotations);
 69         this.javaFieldName = fieldName;
 70     }
 71 
 72     /**
 73      * &lt;p&gt;
 74      * Constructs a value descriptor, useful for dynamically creating event types and
 75      * annotations.
 76      * &lt;P&gt;
 77      * The following types are supported:
 78      * &lt;ul&gt;
 79      * &lt;li&gt;{@code byte.class}
 80      * &lt;li&gt;{@code short.class}
 81      * &lt;li&gt;{@code int.class}
 82      * &lt;li&gt;{@code long.class}
 83      * &lt;li&gt;{@code char.class}
 84      * &lt;li&gt;{@code float.class}
 85      * &lt;li&gt;{@code double.class}
 86      * &lt;li&gt;{@code boolean.class}
 87      * &lt;li&gt;{@code String.class}
 88      * &lt;li&gt;{@code Class.class}
 89      * &lt;li&gt;{@code Thread.class}
 90      * &lt;/ul&gt;
 91      *
 92      * &lt;p&gt;
 93      * The name must be a valid Java identifier (for example, {@code &quot;maxThroughput&quot;}). See
 94      * section 3.8 and 3.9 of the Java Language Specification for more information.
 95      *
 96      * @param type the type, not {@code null}
 97      * @param name the name, not {@code null}
 98      *
 99      * @throws IllegalArgumentException if the name is not a valid Java identifier
100      */
101     public ValueDescriptor(Class&lt;?&gt; type, String name) {
102         this(type, name, Collections.&lt;AnnotationElement&gt; emptyList());
103     }
104 
105     /**
106      * &lt;p&gt;
107      * Constructs a value descriptor, useful for dynamically creating event types and
108      * annotations.
109      * &lt;P&gt;
110      * The following types are supported:
111      * &lt;ul&gt;
112      * &lt;li&gt;{@code byte.class}
113      * &lt;li&gt;{@code short.class}
114      * &lt;li&gt;{@code int.class}
115      * &lt;li&gt;{@code long.class}
116      * &lt;li&gt;{@code char.class}
117      * &lt;li&gt;{@code float.class}
118      * &lt;li&gt;{@code double.class}
119      * &lt;li&gt;{@code boolean.class}
120      * &lt;li&gt;{@code String.class}
121      * &lt;li&gt;{@code Class.class}
122      * &lt;li&gt;{@code Thread.class}
123      * &lt;/ul&gt;
124      *
125      * &lt;p&gt;
126      * The name must be a valid Java identifier (for example, {@code &quot;maxThroughput&quot;}). See
127      * section 3.8 and 3.9 of the Java Language Specification for more information.
128      *
129      * @param type the type, not {@code null}
130      * @param name the name, not {@code null}
131      * @param annotations the annotations on the value descriptors, not
132      *        {@code null}
133      *
134      * @throws IllegalArgumentException if the name is not a valid Java identifier
135      */
136     public ValueDescriptor(Class&lt;?&gt; type, String name, List&lt;AnnotationElement&gt; annotations) {
137         this(type, name, List.copyOf(annotations), false);
138     }
139 
140 
141     ValueDescriptor(Class&lt;?&gt; type, String name, List&lt;AnnotationElement&gt; annotations, boolean allowArray) {
142         Objects.requireNonNull(type, &quot;type&quot;);
143         Objects.requireNonNull(name, &quot;name&quot;);
144         Objects.requireNonNull(annotations, &quot;annotations&quot;);
<a name="3" id="anc3"></a>
145         if (!allowArray) {
146             if (type.isArray()) {
147                 throw new IllegalArgumentException(&quot;Array types are not allowed&quot;);
148             }
149         }
150         this.name = Objects.requireNonNull(name, &quot;Name of value descriptor can&#39;t be null&quot;);
151         Utils.ensureJavaIdentifier(name);
152         this.type = Objects.requireNonNull(Utils.getValidType(Objects.requireNonNull(type), Objects.requireNonNull(name)));
153         this.annotationConstruct = new AnnotationConstruct(annotations);
154         this.javaFieldName = name; // Needed for dynamic events
155         this.isArray = type.isArray();
156         // Assume we always want to store String and Thread in constant pool
157         this.constantPool = type == Class.class || type == Thread.class;
158     }
159 
160     /**
161      * Returns a human-readable name that describes the value (for example,
162      * {@code &quot;Maximum Throughput&quot;}).
163      *
164      * @return a human-readable name, or {@code null} if doesn&#39;t exist
165      */
166     public String getLabel() {
167         if (label == UNKNOWN) {
168             label = annotationConstruct.getLabel();;
169         }
170         return label;
171     }
172 
173     /**
174      * Returns the name of the value (for example, {@code &quot;maxThroughput&quot;}).
175      *
176      * @return the name, not {@code null}
177      */
178     public String getName() {
179         return name;
180     }
181 
182     /**
183      * Returns a sentence describing the value (for example, {@code &quot;Maximum
184      * throughput in the transaction system. Value is reset after each new
185      * batch.&quot;}).
186      *
187      * @return the description, or {@code null} if doesn&#39;t exist
188      */
189     public String getDescription() {
190         return annotationConstruct.getDescription();
191     }
192 
193     /**
194      * Returns a textual identifier that specifies how a value represented by
195      * this {@link ValueDescriptor} is interpreted or formatted.
196      * &lt;p&gt;
197      * For example, if the value descriptor&#39;s type is {@code float} and the
198      * event value is {@code 0.5f}, a content type of
199      * {@code &quot;jdk.jfr.Percentage&quot;} hints to a client that the value is a
200      * percentage and that it should be rendered as {@code &quot;50%&quot;}.
201      * &lt;p&gt;
202      * The JDK provides the following predefined content types:
203      * &lt;ul&gt;
204      * &lt;li&gt;jdk.jfr.Percentage&lt;/li&gt;
205      * &lt;li&gt;jdk.jfr.Timespan&lt;/li&gt;
206      * &lt;li&gt;jdk.jfr.Timestamp&lt;/li&gt;
207      * &lt;li&gt;jdk.jfr.Frequency&lt;/li&gt;
208      * &lt;li&gt;jdk.jfr.Flag&lt;/li&gt;
209      * &lt;li&gt;jdk.jfr.MemoryAddress&lt;/li&gt;
210      * &lt;li&gt;jdk.jfr.DataAmount&lt;/li&gt;
211      * &lt;li&gt;jdk.jfr.NetworkAddress&lt;/li&gt;
212      * &lt;/ul&gt;
213      * &lt;p&gt;
214      * User-defined content types can be created by using the {@link ContentType} class.
215      *
216      * @return the content type, or {@code null} if doesn&#39;t exist
217      *
218      * @see ContentType
219      */
220     public String getContentType() {
221         if (contentType == UNKNOWN) {
222             for (AnnotationElement anno : getAnnotationElements()) {
223                 for (AnnotationElement meta : anno.getAnnotationElements()) {
224                     if (meta.getTypeName().equals(ContentType.class.getName())) {
225                         contentType = anno.getTypeName();
226                         return contentType;
227                     }
228                 }
229             }
230             contentType = null;
231         }
232         return contentType;
233     }
234 
235     /**
236      * Returns the fully qualified class name of the type that is associated with
237      * this value descriptor.
238      *
239      * @return the type name, not {@code null}
240      *
241      * @see ValueDescriptor#getTypeId()
242      */
243     public String getTypeName() {
244         if (type.isSimpleType()) {
245             return type.getFields().getFirst().getTypeName();
246         }
247         return type.getName();
248     }
249 
250     /**
251      * Returns a unique ID for the type in the Java virtual Machine (JVM).
252      *
253      * The ID might not be the same between JVM instances.
254      *
255      * @return the type ID, not negative
256      */
257     public long getTypeId() {
258         return type.getId();
259     }
260 
261     /**
262      * Returns if this value descriptor is an array type.
263      *
264      * @return {@code true} if it is an array type, {@code false} otherwise
265      */
266     public boolean isArray() {
267         return isArray;
268     }
269 
270     /**
271      * Returns the first annotation for the specified type if an annotation
272      * element with the same name is directly present for this value descriptor,
273      * {@code null} otherwise.
274      *
275      * @param &lt;A&gt; the type of the annotation to query for and return if present
276      * @param annotationType the Class object that corresponds to the annotation
277      *        type, not {@code null}
278      * @return this element&#39;s annotation for the specified annotation type if
279      *         directly present, else {@code null}
280      */
281     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
282         Objects.requireNonNull(annotationType, &quot;annotationType&quot;);
283         return annotationConstruct.getAnnotation(annotationType);
284     }
285 
286     /**
287      * Returns an immutable list of annotation elements for this value
288      * descriptor.
289      *
290      * @return a list of annotations, not {@code null}
291      */
292     public List&lt;AnnotationElement&gt; getAnnotationElements() {
293         return annotationConstruct.getUnmodifiableAnnotationElements();
294     }
295 
296     /**
297      * Returns an immutable list of value descriptors if the type is complex,
298      * else an empty list.
299      *
300      * @return a list of value descriptors, not {@code null}
301      */
302     public List&lt;ValueDescriptor&gt; getFields() {
303         if (type.isSimpleType()) {
304             return List.of();
305         }
306         return type.getFields();
307     }
308 
309     // package private
310     Type getType() {
311         return type;
312     }
313 
314     // package private
315     void setAnnotations(List&lt;AnnotationElement&gt; anno) {
316         annotationConstruct.setAnnotationElements(anno);
317     }
318 
319     // package private
320     boolean isConstantPool() {
321         return constantPool;
322     }
323 
324     // package private
325     String getJavaFieldName() {
326         return javaFieldName;
327     }
328 
329     // package private
330     boolean isUnsigned() {
331         return annotationConstruct.hasUnsigned();
332     }
333 
334 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>