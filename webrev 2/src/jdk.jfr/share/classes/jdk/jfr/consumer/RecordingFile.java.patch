diff a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,11 +41,10 @@
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;
 import jdk.jfr.internal.consumer.ParserFilter;
 import jdk.jfr.internal.consumer.ChunkHeader;
 import jdk.jfr.internal.consumer.ChunkParser;
-import jdk.jfr.internal.consumer.FileAccess;
 import jdk.jfr.internal.consumer.ParserState;
 import jdk.jfr.internal.consumer.RecordingInput;
 import jdk.jfr.internal.consumer.filter.ChunkWriter;
 
 /**
@@ -79,11 +78,11 @@
      * @throws NoSuchFileException if the {@code file} can't be located
      */
     public RecordingFile(Path file) throws IOException {
         Objects.requireNonNull(file, "file");
         this.file = file.toFile();
-        this.input = new RecordingInput(this.file, FileAccess.UNPRIVILEGED);
+        this.input = new RecordingInput(this.file);
         this.chunkWriter = null;
         findNext();
     }
 
     // Only used by RecordingFile::write(Path, Predicate<RecordedEvent>)
@@ -144,11 +143,11 @@
     public List<EventType> readEventTypes() throws IOException {
         ensureOpen();
         MetadataDescriptor previous = null;
         List<EventType> types = new ArrayList<>();
         HashSet<Long> foundIds = new HashSet<>();
-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput ri = new RecordingInput(file)) {
             ChunkHeader ch = new ChunkHeader(ri);
             aggregateEventTypeForChunk(ch, null, types, foundIds);
             while (!ch.isLastChunk()) {
                 ch = ch.nextHeader();
                 previous = aggregateEventTypeForChunk(ch, previous, types, foundIds);
@@ -160,11 +159,11 @@
     List<Type> readTypes() throws IOException  {
         ensureOpen();
         MetadataDescriptor previous = null;
         List<Type> types = new ArrayList<>(200);
         HashSet<Long> foundIds = HashSet.newHashSet(types.size());
-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput ri = new RecordingInput(file)) {
             ChunkHeader ch = new ChunkHeader(ri);
             ch.awaitFinished();
             aggregateTypeForChunk(ch, null, types, foundIds);
             while (!ch.isLastChunk()) {
                 ch = ch.nextHeader();
