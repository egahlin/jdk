<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.time.Duration;
 31 import java.time.Instant;
 32 import java.util.Collections;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.function.Consumer;
 37 
 38 import jdk.jfr.Configuration;
 39 import jdk.jfr.Event;
 40 import jdk.jfr.EventSettings;
 41 import jdk.jfr.EventType;
 42 import jdk.jfr.Recording;
 43 import jdk.jfr.RecordingState;
 44 import jdk.jfr.internal.PlatformRecording;
 45 import jdk.jfr.internal.PrivateAccess;
 46 import jdk.jfr.internal.util.Utils;
 47 import jdk.jfr.internal.consumer.EventDirectoryStream;
 48 import jdk.jfr.internal.management.StreamBarrier;
 49 
 50 /**
 51  * A recording stream produces events from the current JVM (Java Virtual
 52  * Machine).
 53  * &lt;p&gt;
 54  * The following example shows how to record events using the default
 55  * configuration and print the Garbage Collection, CPU Load and JVM Information
 56  * event to standard out.
 57  *
 58  * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamOverview&quot;}
 59  *
 60  * @since 14
 61  */
 62 public final class RecordingStream implements AutoCloseable, EventStream {
 63 
 64     static final class ChunkConsumer implements Consumer&lt;Long&gt; {
 65 
 66         private final Recording recording;
 67 
 68         ChunkConsumer(Recording recording) {
 69             this.recording = recording;
 70         }
 71 
 72         @Override
 73         public void accept(Long endNanos) {
 74             Instant t = Utils.epochNanosToInstant(endNanos);
 75             PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);
 76             p.removeBefore(t);
 77         }
 78     }
 79 
 80     private final Recording recording;
 81     private final Instant creationTime;
 82     private final EventDirectoryStream directoryStream;
 83     private long maxSize;
 84     private Duration maxAge;
 85 
 86     /**
 87      * Creates an event stream for the current JVM (Java Virtual Machine).
 88      *
 89      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
 90      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
 91      *         support, or if the file repository can&#39;t be created or accessed)
 92      */
 93     public RecordingStream() {
 94         this(Map.of());
 95     }
 96 
 97     private RecordingStream(Map&lt;String, String&gt; settings) {
 98         this.recording = new Recording();
 99         this.creationTime = Instant.now();
100         this.recording.setName(&quot;Recording Stream: &quot; + creationTime);
101         try {
102             PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
103             this.directoryStream = new EventDirectoryStream(
104                 null,
105                 pr,
106                 configurations(),
107                 false
108             );
109         } catch (IOException ioe) {
110             this.recording.close();
111             throw new IllegalStateException(ioe.getMessage());
112         }
113         if (!settings.isEmpty()) {
114             recording.setSettings(settings);
115         }
116     }
117 
118     private List&lt;Configuration&gt; configurations() {
119         try {
120             return Configuration.getConfigurations();
121         } catch (Exception e) {
122             return Collections.emptyList();
123         }
124     }
125 
126     /**
127      * Creates a recording stream using settings from a configuration.
128      * &lt;p&gt;
129      * The following example shows how to create a recording stream that uses a
130      * predefined configuration.
131      *
132      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamConstructor&quot;}
133      *
134      * @param configuration configuration that contains the settings to use,
135      *        not {@code null}
136      *
137      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
138      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
139      *         support, or if the file repository can&#39;t be created or accessed)
140      *
141      * @see Configuration
142      */
143     public RecordingStream(Configuration configuration) {
144         this(Objects.requireNonNull(configuration, &quot;configuration&quot;).getSettings());
145     }
146 
147     /**
148      * Enables the event with the specified name.
149      * &lt;p&gt;
150      * If multiple events have the same name (for example, the same class is
151      * loaded in different class loaders), then all events that match the name
152      * are enabled. To enable a specific class, use the {@link #enable(Class)}
153      * method or a {@code String} representation of the event type ID.
154      *
155      * @param name the settings for the event, not {@code null}
156      *
157      * @return an event setting for further configuration, not {@code null}
158      *
159      * @see EventType
160      */
161     public EventSettings enable(String name) {
162         return recording.enable(name);
163     }
164 
165     /**
166      * Replaces all settings for this recording stream.
167      * &lt;p&gt;
168      * The following example records 20 seconds using the &quot;default&quot; configuration
169      * and then changes settings to the &quot;profile&quot; configuration.
170      *
171      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamSetSettings&quot;}
172      *
173      * @param settings the settings to set, not {@code null}
174      *
175      * @see Recording#setSettings(Map)
176      */
177     public void setSettings(Map&lt;String, String&gt; settings) {
178         recording.setSettings(settings);
179     };
180 
181     /**
182      * Enables event.
183      *
184      * @param eventClass the event to enable, not {@code null}
185      *
186      * @throws IllegalArgumentException if {@code eventClass} is an abstract
187      *         class or not a subclass of {@link Event}
188      *
189      * @return an event setting for further configuration, not {@code null}
190      */
191     public EventSettings enable(Class&lt;? extends Event&gt; eventClass) {
192         return recording.enable(eventClass);
193     }
194 
195     /**
196      * Disables event with the specified name.
197      * &lt;p&gt;
198      * If multiple events with same name (for example, the same class is loaded
199      * in different class loaders), then all events that match the name are
200      * disabled. To disable a specific class, use the {@link #disable(Class)}
201      * method or a {@code String} representation of the event type ID.
202      *
203      * @param name the settings for the event, not {@code null}
204      *
205      * @return an event setting for further configuration, not {@code null}
206      *
207      */
208     public EventSettings disable(String name) {
209         return recording.disable(name);
210     }
211 
212     /**
213      * Disables event.
214      *
215      * @param eventClass the event to enable, not {@code null}
216      *
217      * @throws IllegalArgumentException if {@code eventClass} is an abstract
218      *         class or not a subclass of {@link Event}
219      *
220      * @return an event setting for further configuration, not {@code null}
221      *
222      */
223     public EventSettings disable(Class&lt;? extends Event&gt; eventClass) {
224         return recording.disable(eventClass);
225     }
226 
227     /**
228      * Determines how far back data is kept for the stream.
229      * &lt;p&gt;
230      * To control the amount of recording data stored on disk, the maximum
231      * length of time to retain the data can be specified. Data stored on disk
232      * that is older than the specified length of time is removed by the Java
233      * Virtual Machine (JVM).
234      * &lt;p&gt;
235      * If neither maximum limit or the maximum age is set, the size of the
236      * recording may grow indefinitely if events are on
237      *
238      * @param maxAge the length of time that data is kept, or {@code null} if
239      *        infinite
240      *
241      * @throws IllegalArgumentException if {@code maxAge} is negative
242      *
243      * @throws IllegalStateException if the recording is in the {@code CLOSED}
244      *         state
245      */
246     public void setMaxAge(Duration maxAge) {
247         synchronized (directoryStream) {
248             recording.setMaxAge(maxAge);
249             this.maxAge = maxAge;
250             updateOnCompleteHandler();
251         }
252     }
253 
254     /**
255      * Determines how much data is kept for the stream.
256      * &lt;p&gt;
257      * To control the amount of recording data that is stored on disk, the
258      * maximum amount of data to retain can be specified. When the maximum limit
259      * is exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to
260      * make room for a more recent chunk.
261      * &lt;p&gt;
262      * If neither maximum limit or the maximum age is set, the size of the
263      * recording may grow indefinitely.
264      * &lt;p&gt;
265      * The size is measured in bytes.
266      *
267      * @param maxSize the amount of data to retain, {@code 0} if infinite
268      *
269      * @throws IllegalArgumentException if {@code maxSize} is negative
270      *
271      * @throws IllegalStateException if the recording is in {@code CLOSED} state
272      */
273     public void setMaxSize(long maxSize) {
274         synchronized (directoryStream) {
275             recording.setMaxSize(maxSize);
276             this.maxSize = maxSize;
277             updateOnCompleteHandler();
278         }
279     }
280 
281     @Override
282     public void setReuse(boolean reuse) {
283         directoryStream.setReuse(reuse);
284     }
285 
286     @Override
287     public void setOrdered(boolean ordered) {
288         directoryStream.setOrdered(ordered);
289     }
290 
291     @Override
292     public void setStartTime(Instant startTime) {
293         directoryStream.setStartTime(startTime);
294     }
295 
296     @Override
297     public void setEndTime(Instant endTime) {
298         directoryStream.setEndTime(endTime);
299     }
300 
301     @Override
302     public void onEvent(String eventName, Consumer&lt;RecordedEvent&gt; action) {
303         directoryStream.onEvent(eventName, action);
304     }
305 
306     @Override
307     public void onEvent(Consumer&lt;RecordedEvent&gt; action) {
308         directoryStream.onEvent(action);
309     }
310 
311     @Override
312     public void onFlush(Runnable action) {
313         directoryStream.onFlush(action);
314     }
315 
316     @Override
317     public void onClose(Runnable action) {
318         directoryStream.onClose(action);
319     }
320 
321     @Override
322     public void onError(Consumer&lt;Throwable&gt; action) {
323         directoryStream.onError(action);
324     }
325 
326     @Override
327     public void close() {
328         directoryStream.setChunkCompleteHandler(null);
329         recording.close();
330         directoryStream.close();
331     }
332 
333     @Override
334     public boolean remove(Object action) {
335         return directoryStream.remove(action);
336     }
337 
338     @Override
339     public void start() {
340         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
341         long startNanos = pr.start();
342         updateOnCompleteHandler();
343         directoryStream.start(startNanos);
344     }
345 
346     /**
347      * Starts asynchronous processing of actions.
348      * &lt;p&gt;
349      * Actions are performed in a single separate thread.
350      * &lt;p&gt;
351      * To stop the stream, use the {@link #close()} method.
352      * &lt;p&gt;
353      * The following example prints the CPU usage for ten seconds. When
354      * the current thread leaves the try-with-resources block the
355      * stream is stopped/closed.
356      *
357      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamStartAsync&quot;}
358      *
359      * @throws IllegalStateException if the stream is already started or closed
360      */
361     @Override
362     public void startAsync() {
363         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
364         long startNanos = pr.start();
365         updateOnCompleteHandler();
366         directoryStream.startAsync(startNanos);
367     }
368 
369     /**
370      * Stops the recording stream.
371      * &lt;p&gt;
372      * Stops a started stream and waits until all events in the recording have
373      * been consumed.
374      * &lt;p&gt;
375      * Invoking this method in an action, for example in the
376      * {@link #onEvent(Consumer)} method, could block the stream indefinitely.
377      * To stop the stream abruptly, use the {@link #close} method.
378      * &lt;p&gt;
379      * The following code snippet illustrates how this method can be used in
380      * conjunction with the {@link #startAsync()} method to monitor what happens
381      * during a test method:
382      *
383      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamStop&quot;}
384      *
385      * @return {@code true} if recording is stopped, {@code false} otherwise
386      *
387      * @throws IllegalStateException if the recording is not started or is already stopped
388      *
389      * @since 20
390      */
391     public boolean stop() {
392         boolean stopped = false;
393         try {
394             try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {
395                 stopped = recording.stop();
396                 directoryStream.setCloseOnComplete(false);
397                 sb.setStreamEnd(recording.getStopTime().toEpochMilli());
398             }
399             directoryStream.awaitTermination();
400         } catch (InterruptedException | IOException e) {
401             // OK, return
402         }
403         return stopped;
404     }
405 
406     /**
407      * Writes recording data to a file.
408      * &lt;p&gt;
409      * The recording stream must be started, but not closed.
410      * &lt;p&gt;
411      * It&#39;s highly recommended that a max age or max size is set before
412      * starting the stream. Otherwise, the dump may not contain any events.
413      *
414      * @param destination the location where recording data is written, not
415      *        {@code null}
416      *
417      * @throws IOException if the recording data can&#39;t be copied to the specified
418      *         location, or if the stream is closed, or not started.
419      *
420      * @see RecordingStream#setMaxAge(Duration)
421      * @see RecordingStream#setMaxSize(long)
422      *
423      * @since 17
424      */
425     public void dump(Path destination) throws IOException {
426         Objects.requireNonNull(destination, &quot;destination&quot;);
427         Object recorder = PrivateAccess.getInstance().getPlatformRecorder();
428         synchronized (recorder) {
429             RecordingState state = recording.getState();
430             if (state == RecordingState.CLOSED) {
431                 throw new IOException(&quot;Recording stream has been closed, no content to write&quot;);
432             }
433             if (state == RecordingState.NEW) {
434                 throw new IOException(&quot;Recording stream has not been started, no content to write&quot;);
435             }
436             recording.dump(destination);
437         }
438     }
439 
440     @Override
441     public void awaitTermination(Duration timeout) throws InterruptedException {
442         directoryStream.awaitTermination(timeout);
443     }
444 
445     @Override
446     public void awaitTermination() throws InterruptedException {
447         directoryStream.awaitTermination();
448     }
449 
450     /**
451      * Registers an action to perform when new metadata arrives in the stream.
452      *
453      * The event type of an event always arrives sometime before the actual event.
454      * The action must be registered before the stream is started.
455      * &lt;p&gt;
456      * The following example shows how to listen to new event types, register
457      * an action if the event type name matches a regular expression and increase a
458      * counter if a matching event is found. A benefit of using an action per
459      * event type, instead of the generic {@link #onEvent(Consumer)} method,
460      * is that a stream implementation can avoid reading events that are of no
461      * interest.
462      *
463      * {@snippet class = &quot;Snippets&quot; region = &quot;RecordingStreamMetadata&quot;}
464      *
465      * @param action to perform, not {@code null}
466      *
467      * @throws IllegalStateException if an action is added after the stream has
468      *                               started
469      * @since 16
470      */
471     @Override
472     public void onMetadata(Consumer&lt;MetadataEvent&gt; action) {
473         directoryStream.onMetadata(action);
474     }
475 
476     private void updateOnCompleteHandler() {
477         if (maxAge != null || maxSize != 0) {
478             // User has set a chunk removal policy
479             directoryStream.setChunkCompleteHandler(null);
480         } else {
481             directoryStream.setChunkCompleteHandler(new ChunkConsumer(recording));
482         }
483     }
484 }
    </pre>
  </body>
</html>