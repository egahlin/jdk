<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.security.AccessControlContext;
 31 import java.security.AccessController;
 32 import java.time.Duration;
 33 import java.time.Instant;
 34 import java.util.Collections;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Objects;
 38 import java.util.function.Consumer;
 39 
 40 import jdk.jfr.Configuration;
 41 import jdk.jfr.Event;
 42 import jdk.jfr.EventSettings;
 43 import jdk.jfr.EventType;
 44 import jdk.jfr.Recording;
 45 import jdk.jfr.RecordingState;
 46 import jdk.jfr.internal.PlatformRecording;
 47 import jdk.jfr.internal.PrivateAccess;
 48 import jdk.jfr.internal.SecuritySupport;
 49 import jdk.jfr.internal.util.Utils;
 50 import jdk.jfr.internal.consumer.EventDirectoryStream;
 51 import jdk.jfr.internal.management.StreamBarrier;
 52 
 53 /**
 54  * A recording stream produces events from the current JVM (Java Virtual
 55  * Machine).
 56  * &lt;p&gt;
 57  * The following example shows how to record events using the default
 58  * configuration and print the Garbage Collection, CPU Load and JVM Information
 59  * event to standard out.
 60  *
 61  * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamOverview&quot;}
 62  *
 63  * @since 14
 64  */
 65 public final class RecordingStream implements AutoCloseable, EventStream {
 66 
 67     static final class ChunkConsumer implements Consumer&lt;Long&gt; {
 68 
 69         private final Recording recording;
 70 
 71         ChunkConsumer(Recording recording) {
 72             this.recording = recording;
 73         }
 74 
 75         @Override
 76         public void accept(Long endNanos) {
 77             Instant t = Utils.epochNanosToInstant(endNanos);
 78             PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);
 79             p.removeBefore(t);
 80         }
 81     }
 82 
 83     private final Recording recording;
 84     private final Instant creationTime;
 85     private final EventDirectoryStream directoryStream;
 86     private long maxSize;
 87     private Duration maxAge;
 88 
 89     /**
 90      * Creates an event stream for the current JVM (Java Virtual Machine).
 91      *
 92      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
 93      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
 94      *         support, or if the file repository can&#39;t be created or accessed)
 95      */
 96     public RecordingStream() {
 97         this(Map.of());
 98     }
 99 
100     private RecordingStream(Map&lt;String, String&gt; settings) {
101         SecuritySupport.checkAccessFlightRecorder();
102         @SuppressWarnings(&quot;removal&quot;)
103         AccessControlContext acc = AccessController.getContext();
104         this.recording = new Recording();
105         this.creationTime = Instant.now();
106         this.recording.setName(&quot;Recording Stream: &quot; + creationTime);
107         try {
108             PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
109             this.directoryStream = new EventDirectoryStream(
110                 acc,
111                 null,
112                 SecuritySupport.PRIVILEGED,
113                 pr,
114                 configurations(),
115                 false
116             );
117         } catch (IOException ioe) {
118             this.recording.close();
119             throw new IllegalStateException(ioe.getMessage());
120         }
121         if (!settings.isEmpty()) {
122             recording.setSettings(settings);
123         }
124     }
125 
126     private List&lt;Configuration&gt; configurations() {
127         try {
128             return Configuration.getConfigurations();
129         } catch (Exception e) {
130             return Collections.emptyList();
131         }
132     }
133 
134     /**
135      * Creates a recording stream using settings from a configuration.
136      * &lt;p&gt;
137      * The following example shows how to create a recording stream that uses a
138      * predefined configuration.
139      *
140      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamConstructor&quot;}
141      *
142      * @param configuration configuration that contains the settings to use,
143      *        not {@code null}
144      *
145      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
146      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
147      *         support, or if the file repository can&#39;t be created or accessed)
148      *
149      * @see Configuration
150      */
151     public RecordingStream(Configuration configuration) {
152         this(Objects.requireNonNull(configuration, &quot;configuration&quot;).getSettings());
153     }
154 
155     /**
156      * Enables the event with the specified name.
157      * &lt;p&gt;
158      * If multiple events have the same name (for example, the same class is
159      * loaded in different class loaders), then all events that match the name
160      * are enabled. To enable a specific class, use the {@link #enable(Class)}
161      * method or a {@code String} representation of the event type ID.
162      *
163      * @param name the settings for the event, not {@code null}
164      *
165      * @return an event setting for further configuration, not {@code null}
166      *
167      * @see EventType
168      */
169     public EventSettings enable(String name) {
170         return recording.enable(name);
171     }
172 
173     /**
174      * Replaces all settings for this recording stream.
175      * &lt;p&gt;
176      * The following example records 20 seconds using the &quot;default&quot; configuration
177      * and then changes settings to the &quot;profile&quot; configuration.
178      *
179      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamSetSettings&quot;}
180      *
181      * @param settings the settings to set, not {@code null}
182      *
183      * @see Recording#setSettings(Map)
184      */
185     public void setSettings(Map&lt;String, String&gt; settings) {
186         recording.setSettings(settings);
187     };
188 
189     /**
190      * Enables event.
191      *
192      * @param eventClass the event to enable, not {@code null}
193      *
194      * @throws IllegalArgumentException if {@code eventClass} is an abstract
195      *         class or not a subclass of {@link Event}
196      *
197      * @return an event setting for further configuration, not {@code null}
198      */
199     public EventSettings enable(Class&lt;? extends Event&gt; eventClass) {
200         return recording.enable(eventClass);
201     }
202 
203     /**
204      * Disables event with the specified name.
205      * &lt;p&gt;
206      * If multiple events with same name (for example, the same class is loaded
207      * in different class loaders), then all events that match the name are
208      * disabled. To disable a specific class, use the {@link #disable(Class)}
209      * method or a {@code String} representation of the event type ID.
210      *
211      * @param name the settings for the event, not {@code null}
212      *
213      * @return an event setting for further configuration, not {@code null}
214      *
215      */
216     public EventSettings disable(String name) {
217         return recording.disable(name);
218     }
219 
220     /**
221      * Disables event.
222      *
223      * @param eventClass the event to enable, not {@code null}
224      *
225      * @throws IllegalArgumentException if {@code eventClass} is an abstract
226      *         class or not a subclass of {@link Event}
227      *
228      * @return an event setting for further configuration, not {@code null}
229      *
230      */
231     public EventSettings disable(Class&lt;? extends Event&gt; eventClass) {
232         return recording.disable(eventClass);
233     }
234 
235     /**
236      * Determines how far back data is kept for the stream.
237      * &lt;p&gt;
238      * To control the amount of recording data stored on disk, the maximum
239      * length of time to retain the data can be specified. Data stored on disk
240      * that is older than the specified length of time is removed by the Java
241      * Virtual Machine (JVM).
242      * &lt;p&gt;
243      * If neither maximum limit or the maximum age is set, the size of the
244      * recording may grow indefinitely if events are on
245      *
246      * @param maxAge the length of time that data is kept, or {@code null} if
247      *        infinite
248      *
249      * @throws IllegalArgumentException if {@code maxAge} is negative
250      *
251      * @throws IllegalStateException if the recording is in the {@code CLOSED}
252      *         state
253      */
254     public void setMaxAge(Duration maxAge) {
255         synchronized (directoryStream) {
256             recording.setMaxAge(maxAge);
257             this.maxAge = maxAge;
258             updateOnCompleteHandler();
259         }
260     }
261 
262     /**
263      * Determines how much data is kept for the stream.
264      * &lt;p&gt;
265      * To control the amount of recording data that is stored on disk, the
266      * maximum amount of data to retain can be specified. When the maximum limit
267      * is exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to
268      * make room for a more recent chunk.
269      * &lt;p&gt;
270      * If neither maximum limit or the maximum age is set, the size of the
271      * recording may grow indefinitely.
272      * &lt;p&gt;
273      * The size is measured in bytes.
274      *
275      * @param maxSize the amount of data to retain, {@code 0} if infinite
276      *
277      * @throws IllegalArgumentException if {@code maxSize} is negative
278      *
279      * @throws IllegalStateException if the recording is in {@code CLOSED} state
280      */
281     public void setMaxSize(long maxSize) {
282         synchronized (directoryStream) {
283             recording.setMaxSize(maxSize);
284             this.maxSize = maxSize;
285             updateOnCompleteHandler();
286         }
287     }
288 
289     @Override
290     public void setReuse(boolean reuse) {
291         directoryStream.setReuse(reuse);
292     }
293 
294     @Override
295     public void setOrdered(boolean ordered) {
296         directoryStream.setOrdered(ordered);
297     }
298 
299     @Override
300     public void setStartTime(Instant startTime) {
301         directoryStream.setStartTime(startTime);
302     }
303 
304     @Override
305     public void setEndTime(Instant endTime) {
306         directoryStream.setEndTime(endTime);
307     }
308 
309     @Override
310     public void onEvent(String eventName, Consumer&lt;RecordedEvent&gt; action) {
311         directoryStream.onEvent(eventName, action);
312     }
313 
314     @Override
315     public void onEvent(Consumer&lt;RecordedEvent&gt; action) {
316         directoryStream.onEvent(action);
317     }
318 
319     @Override
320     public void onFlush(Runnable action) {
321         directoryStream.onFlush(action);
322     }
323 
324     @Override
325     public void onClose(Runnable action) {
326         directoryStream.onClose(action);
327     }
328 
329     @Override
330     public void onError(Consumer&lt;Throwable&gt; action) {
331         directoryStream.onError(action);
332     }
333 
334     @Override
335     public void close() {
336         directoryStream.setChunkCompleteHandler(null);
337         recording.close();
338         directoryStream.close();
339     }
340 
341     @Override
342     public boolean remove(Object action) {
343         return directoryStream.remove(action);
344     }
345 
346     @Override
347     public void start() {
348         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
349         long startNanos = pr.start();
350         updateOnCompleteHandler();
351         directoryStream.start(startNanos);
352     }
353 
354     /**
355      * Starts asynchronous processing of actions.
356      * &lt;p&gt;
357      * Actions are performed in a single separate thread.
358      * &lt;p&gt;
359      * To stop the stream, use the {@link #close()} method.
360      * &lt;p&gt;
361      * The following example prints the CPU usage for ten seconds. When
362      * the current thread leaves the try-with-resources block the
363      * stream is stopped/closed.
364      *
365      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamStartAsync&quot;}
366      *
367      * @throws IllegalStateException if the stream is already started or closed
368      */
369     @Override
370     public void startAsync() {
371         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
372         long startNanos = pr.start();
373         updateOnCompleteHandler();
374         directoryStream.startAsync(startNanos);
375     }
376 
377     /**
378      * Stops the recording stream.
379      * &lt;p&gt;
380      * Stops a started stream and waits until all events in the recording have
381      * been consumed.
382      * &lt;p&gt;
383      * Invoking this method in an action, for example in the
384      * {@link #onEvent(Consumer)} method, could block the stream indefinitely.
385      * To stop the stream abruptly, use the {@link #close} method.
386      * &lt;p&gt;
387      * The following code snippet illustrates how this method can be used in
388      * conjunction with the {@link #startAsync()} method to monitor what happens
389      * during a test method:
390      *
391      * {@snippet class=&quot;Snippets&quot; region=&quot;RecordingStreamStop&quot;}
392      *
393      * @return {@code true} if recording is stopped, {@code false} otherwise
394      *
395      * @throws IllegalStateException if the recording is not started or is already stopped
396      *
397      * @since 20
398      */
399     public boolean stop() {
400         boolean stopped = false;
401         try {
402             try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {
403                 stopped = recording.stop();
404                 directoryStream.setCloseOnComplete(false);
405                 sb.setStreamEnd(recording.getStopTime().toEpochMilli());
406             }
407             directoryStream.awaitTermination();
408         } catch (InterruptedException | IOException e) {
409             // OK, return
410         }
411         return stopped;
412     }
413 
414     /**
415      * Writes recording data to a file.
416      * &lt;p&gt;
417      * The recording stream must be started, but not closed.
418      * &lt;p&gt;
419      * It&#39;s highly recommended that a max age or max size is set before
420      * starting the stream. Otherwise, the dump may not contain any events.
421      *
422      * @param destination the location where recording data is written, not
423      *        {@code null}
424      *
425      * @throws IOException if the recording data can&#39;t be copied to the specified
426      *         location, or if the stream is closed, or not started.
427      *
428      * @see RecordingStream#setMaxAge(Duration)
429      * @see RecordingStream#setMaxSize(long)
430      *
431      * @since 17
432      */
433     public void dump(Path destination) throws IOException {
434         Objects.requireNonNull(destination, &quot;destination&quot;);
435         Object recorder = PrivateAccess.getInstance().getPlatformRecorder();
436         synchronized (recorder) {
437             RecordingState state = recording.getState();
438             if (state == RecordingState.CLOSED) {
439                 throw new IOException(&quot;Recording stream has been closed, no content to write&quot;);
440             }
441             if (state == RecordingState.NEW) {
442                 throw new IOException(&quot;Recording stream has not been started, no content to write&quot;);
443             }
444             recording.dump(destination);
445         }
446     }
447 
448     @Override
449     public void awaitTermination(Duration timeout) throws InterruptedException {
450         directoryStream.awaitTermination(timeout);
451     }
452 
453     @Override
454     public void awaitTermination() throws InterruptedException {
455         directoryStream.awaitTermination();
456     }
457 
458     /**
459      * Registers an action to perform when new metadata arrives in the stream.
460      *
461      * The event type of an event always arrives sometime before the actual event.
462      * The action must be registered before the stream is started.
463      * &lt;p&gt;
464      * The following example shows how to listen to new event types, register
465      * an action if the event type name matches a regular expression and increase a
466      * counter if a matching event is found. A benefit of using an action per
467      * event type, instead of the generic {@link #onEvent(Consumer)} method,
468      * is that a stream implementation can avoid reading events that are of no
469      * interest.
470      *
471      * {@snippet class = &quot;Snippets&quot; region = &quot;RecordingStreamMetadata&quot;}
472      *
473      * @param action to perform, not {@code null}
474      *
475      * @throws IllegalStateException if an action is added after the stream has
476      *                               started
477      * @since 16
478      */
479     @Override
480     public void onMetadata(Consumer&lt;MetadataEvent&gt; action) {
481         directoryStream.onMetadata(action);
482     }
483 
484     private void updateOnCompleteHandler() {
485         if (maxAge != null || maxSize != 0) {
486             // User has set a chunk removal policy
487             directoryStream.setChunkCompleteHandler(null);
488         } else {
489             directoryStream.setChunkCompleteHandler(new ChunkConsumer(recording));
490         }
491     }
492 }
    </pre>
  </body>
</html>