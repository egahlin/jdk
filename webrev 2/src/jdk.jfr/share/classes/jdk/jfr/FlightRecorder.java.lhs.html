<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogLevel.INFO;
 30 import static jdk.jfr.internal.LogTag.JFR;
 31 
<a name="2" id="anc2"></a><span class="line-removed"> 32 import java.security.AccessControlContext;</span>
<span class="line-removed"> 33 import java.security.AccessController;</span>
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.List;
 37 import java.util.Objects;
 38 
 39 import jdk.jfr.internal.JVM;
 40 import jdk.jfr.internal.JVMSupport;
 41 import jdk.jfr.internal.Logger;
 42 import jdk.jfr.internal.MetadataRepository;
 43 import jdk.jfr.internal.Options;
 44 import jdk.jfr.internal.PlatformRecorder;
 45 import jdk.jfr.internal.PlatformRecording;
 46 import jdk.jfr.internal.Repository;
<a name="3" id="anc3"></a><span class="line-removed"> 47 import jdk.jfr.internal.SecuritySupport;</span>
 48 import jdk.jfr.internal.util.Utils;
 49 import jdk.jfr.internal.periodic.PeriodicEvents;
 50 
 51 /**
 52  * Class for accessing, controlling, and managing Flight Recorder.
 53  * &lt;p&gt;
 54  * This class provides the methods necessary for creating, starting, stopping,
 55  * and destroying recordings.
 56  *
 57  * @since 9
 58  */
 59 public final class FlightRecorder {
 60     private static volatile FlightRecorder platformRecorder;
 61     private static volatile boolean initialized;
 62     private final PlatformRecorder internal;
 63 
 64     private FlightRecorder(PlatformRecorder internal) {
 65         this.internal = internal;
 66     }
 67 
 68     /**
 69      * Returns an immutable list of the available recordings.
 70      * &lt;p&gt;
 71      * A recording becomes available when it is created. It becomes unavailable when it
 72      * is in the {@code CLOSED} state, typically after a call to
 73      * {@link Recording#close()}.
 74      *
 75      * @return a list of recordings, not {@code null}
 76      */
 77     public List&lt;Recording&gt; getRecordings() {
 78         List&lt;Recording&gt; recs = new ArrayList&lt;&gt;();
 79         for (PlatformRecording r : internal.getRecordings()) {
 80             recs.add(r.getRecording());
 81         }
 82         return Collections.unmodifiableList(recs);
 83     }
 84 
 85     /**
 86      * Creates a snapshot of all available recorded data.
 87      * &lt;p&gt;
 88      * A snapshot is a synthesized recording in a {@code STOPPED} state. If no data is
 89      * available, a recording with size {@code 0} is returned.
 90      * &lt;p&gt;
 91      * A snapshot provides stable access to data for later operations (for example,
 92      * operations to change the interval or to reduce the data size).
 93      * &lt;p&gt;
 94      * The following example shows how to create a snapshot and write a subset of the data to a file.
 95      *
 96      * {@snippet class=&quot;Snippets&quot; region=&quot;FlightRecorderTakeSnapshot&quot;}
 97      *
 98      * The caller must close the recording when access to the data is no longer
 99      * needed.
100      *
101      * @return a snapshot of all available recording data, not {@code null}
102      */
103     public Recording takeSnapshot() {
104         Recording snapshot = new Recording();
105         snapshot.setName(&quot;Snapshot&quot;);
106         internal.fillWithRecordedData(snapshot.getInternal(), null);
107         return snapshot;
108     }
109 
110     /**
111      * Registers an event class.
112      * &lt;p&gt;
113      * If the event class is already registered, then the invocation of this method is
114      * ignored.
115      *
116      * @param eventClass the event class to register, not {@code null}
117      *
118      * @throws IllegalArgumentException if class is abstract or not a subclass
119      *         of {@link Event}
120      */
121     public static void register(Class&lt;? extends Event&gt; eventClass) {
122         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
123         if (JVMSupport.isNotAvailable()) {
124             return;
125         }
126         Utils.ensureValidEventSubclass(eventClass);
127         MetadataRepository.getInstance().register(eventClass);
128     }
129 
130     /**
131      * Unregisters an event class.
132      * &lt;p&gt;
133      * If the event class is not registered, then the invocation of this method is
134      * ignored.
135      *
136      * @param eventClass the event class to unregistered, not {@code null}
137      * @throws IllegalArgumentException if a class is abstract or not a subclass
138      *         of {@link Event}
139      */
140     public static void unregister(Class&lt;? extends Event&gt; eventClass) {
141         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
142         if (JVMSupport.isNotAvailable()) {
143             return;
144         }
145         Utils.ensureValidEventSubclass(eventClass);
146         MetadataRepository.getInstance().unregister(eventClass);
147     }
148 
149     /**
150      * Returns the Flight Recorder for the platform.
151      *
152      * @return a Flight Recorder instance, not {@code null}
153      *
154      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
155      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
156      *         support, or if the file repository can&#39;t be created or accessed)
157      */
158     public static FlightRecorder getFlightRecorder() throws IllegalStateException {
159         synchronized (PlatformRecorder.class) {
<a name="4" id="anc4"></a><span class="line-removed">160             SecuritySupport.checkAccessFlightRecorder();</span>
161             JVMSupport.ensureWithIllegalStateException();
162             if (platformRecorder == null) {
163                 try {
164                     platformRecorder = new FlightRecorder(new PlatformRecorder());
165                 } catch (IllegalStateException ise) {
166                     throw ise;
167                 } catch (Exception e) {
168                     throw new IllegalStateException(&quot;Can&#39;t create Flight Recorder. &quot; + e.getMessage(), e);
169                 }
170                 // Must be in synchronized block to prevent instance leaking out
171                 // before initialization is done
172                 initialized = true;
173                 Logger.log(JFR, INFO, &quot;Flight Recorder initialized&quot;);
174                 if (Logger.shouldLog(JFR, DEBUG)) {
175                     Logger.log(JFR, DEBUG, &quot;maxchunksize: &quot; + Options.getMaxChunkSize()+ &quot; bytes&quot;);
176                     Logger.log(JFR, DEBUG, &quot;memorysize: &quot; + Options.getMemorySize()+ &quot; bytes&quot;);
177                     Logger.log(JFR, DEBUG, &quot;globalbuffersize: &quot; + Options.getGlobalBufferSize()+ &quot; bytes&quot;);
178                     Logger.log(JFR, DEBUG, &quot;globalbuffercount: &quot; + Options.getGlobalBufferCount());
179                     Logger.log(JFR, DEBUG, &quot;dumppath: &quot; + Options.getDumpPath());
180                     Logger.log(JFR, DEBUG, &quot;stackdepth: &quot; + Options.getStackDepth());
181                     Logger.log(JFR, DEBUG, &quot;threadbuffersize: &quot; + Options.getThreadBufferSize());
182                 }
183                 if (Logger.shouldLog(JFR, INFO)) {
184                     Logger.log(JFR, INFO, &quot;Repository base directory: &quot; + Repository.getRepository().getBaseLocation());
185                 }
186                 PlatformRecorder.notifyRecorderInitialized(platformRecorder);
187             }
188         }
189         return platformRecorder;
190     }
191 
192     /**
193      * Adds a hook for a periodic event.
194      * &lt;p&gt;
195      * The implementation of the hook should return as soon as possible, to
196      * avoid blocking other Flight Recorder operations. The hook should emit
197      * one or more events of the specified type. When a hook is added, the
198      * interval at which the call is invoked is configurable using the
199      * {@code &quot;period&quot;} setting.
200      *
201      * @param eventClass the class that the hook should run for, not {@code null}
202      * @param hook the hook, not {@code null}
203      * @throws IllegalArgumentException if a class is not a subclass of
204      *         {@link Event}, is abstract, or the hook is already added
205      * @throws IllegalStateException if the event class has the
206      *         {@code Registered(false)} annotation and is not registered manually
207      */
208     public static void addPeriodicEvent(Class&lt;? extends Event&gt; eventClass, Runnable hook) {
209         Objects.requireNonNull(eventClass, &quot;eventClass&quot;);
210         Objects.requireNonNull(hook, &quot;hook&quot;);
211         if (JVMSupport.isNotAvailable()) {
212             return;
213         }
214 
215         Utils.ensureValidEventSubclass(eventClass);
<a name="5" id="anc5"></a><span class="line-modified">216         SecuritySupport.checkRegisterPermission();</span>
<span class="line-removed">217         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">218         AccessControlContext acc = AccessController.getContext();</span>
<span class="line-removed">219         PeriodicEvents.addUserEvent(acc, eventClass, hook);</span>
220     }
221 
222     /**
223      * Removes a hook for a periodic event.
224      *
225      * @param hook the hook to remove, not {@code null}
226      * @return {@code true} if hook is removed, {@code false} otherwise
227      */
228     public static boolean removePeriodicEvent(Runnable hook) {
229         Objects.requireNonNull(hook, &quot;hook&quot;);
<a name="6" id="anc6"></a><span class="line-removed">230         SecuritySupport.checkRegisterPermission();</span>
231         if (JVMSupport.isNotAvailable()) {
232             return false;
233         }
234         return PeriodicEvents.removeEvent(hook);
235     }
236 
237     /**
238      * Returns an immutable list that contains all currently registered events.
239      * &lt;p&gt;
240      * By default, events are registered when they are first used, typically
241      * when an event object is allocated. To ensure an event is visible early,
242      * registration can be triggered by invoking the
243      * {@link FlightRecorder#register(Class)} method.
244      *
245      * @return list of events, not {@code null}
246      */
247     public List&lt;EventType&gt; getEventTypes() {
248         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
249     }
250 
251     /**
<a name="7" id="anc7"></a><span class="line-modified">252      * Adds a recorder listener and captures the {@code AccessControlContext} to</span>
<span class="line-removed">253      * use when invoking the listener.</span>
254      * &lt;p&gt;
255      * If Flight Recorder is already initialized when the listener is added, then the method
256      * {@link FlightRecorderListener#recorderInitialized(FlightRecorder)} method is
257      * invoked before returning from this method.
258      *
259      * @param changeListener the listener to add, not {@code null}
260      */
261     public static void addListener(FlightRecorderListener changeListener) {
262         Objects.requireNonNull(changeListener, &quot;changeListener&quot;);
<a name="8" id="anc8"></a><span class="line-removed">263         SecuritySupport.checkAccessFlightRecorder();</span>
264         if (JVMSupport.isNotAvailable()) {
265             return;
266         }
267         PlatformRecorder.addListener(changeListener);
268     }
269 
270     /**
271      * Removes a recorder listener.
272      * &lt;p&gt;
273      * If the same listener is added multiple times, only one instance is
274      * removed.
275      *
276      * @param changeListener listener to remove, not {@code null}
277      *
278      * @return {@code true}, if the listener could be removed, {@code false}
279      *         otherwise
280      */
281     public static boolean removeListener(FlightRecorderListener changeListener) {
282         Objects.requireNonNull(changeListener, &quot;changeListener&quot;);
<a name="9" id="anc9"></a><span class="line-removed">283         SecuritySupport.checkAccessFlightRecorder();</span>
284         if (JVMSupport.isNotAvailable()) {
285             return false;
286         }
287 
288         return PlatformRecorder.removeListener(changeListener);
289     }
290 
291     /**
292      * Returns {@code true} if the Java Virtual Machine (JVM) has Flight Recorder capabilities.
293      * &lt;p&gt;
294      * This method can quickly check whether Flight Recorder can be
295      * initialized, without actually doing the initialization work. The value may
296      * change during runtime and it is not safe to cache it.
297      *
298      * @return {@code true}, if Flight Recorder is available, {@code false}
299      *         otherwise
300      *
301      * @see FlightRecorderListener for callback when Flight Recorder is
302      *      initialized
303      */
304     public static boolean isAvailable() {
305         if (JVMSupport.isNotAvailable()) {
306             return false;
307         }
308         return JVM.isAvailable();
309     }
310 
311     /**
312      * Returns {@code true} if Flight Recorder is initialized.
313      *
314      * @return {@code true}, if Flight Recorder is initialized,
315      *         {@code false} otherwise
316      *
317      * @see FlightRecorderListener for callback when Flight Recorder is
318      *      initialized
319      */
320     public static boolean isInitialized() {
321         return initialized;
322     }
323 
324     PlatformRecorder getInternal() {
325         return internal;
326     }
327 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>