<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal;
 26 
 27 import java.lang.reflect.Modifier;
 28 
 29 import jdk.jfr.internal.event.EventConfiguration;
 30 import jdk.jfr.internal.util.Bytecode;
 31 import jdk.jfr.internal.util.Utils;
 32 /**
 33  * All upcalls from the JVM should go through this class.
 34  *
 35  */
 36 // Called by native
 37 final class JVMUpcalls {
 38     /**
 39      * Called by the JVM when a retransform happens on a tagged class
 40      *
 41      * @param traceId
 42      *            Id of the class
 43      * @param dummy1
 44      *            not used, but act as padding so bytesForEagerInstrumentation and
 45      *            onRetransform can have identical method signatures, which simplifies the
 46      *            invoke machinery in native
 47      *
 48      * @param dummy2
 49      *            not used, but act as padding so bytesForEagerInstrumentation and
 50      *            onRetransform can have identical method signatures, which simplifies the
 51      *            invoke machinery in native
 52      *
 53      * @param clazz
 54      *            class being retransformed
 55      * @param oldBytes
 56      *            byte code
 57      * @return byte code to use
 58      * @throws Throwable
 59      */
 60     static byte[] onRetransform(long traceId, boolean dummy1, boolean dummy2, Class&lt;?&gt; clazz, byte[] oldBytes) throws Throwable {
 61         try {
 62             if (jdk.internal.event.Event.class.isAssignableFrom(clazz) &amp;&amp; !Modifier.isAbstract(clazz.getModifiers())) {
 63                 if (!JVMSupport.shouldInstrument(Utils.isJDKClass(clazz), clazz.getName())) {
 64                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + clazz.getName() + &quot; since container support is missing&quot;);
 65                     return oldBytes;
 66                 }
<a name="2" id="anc2"></a><span class="line-removed"> 67                 EventWriterKey.ensureEventWriterFactory();</span>
 68                 EventConfiguration configuration = JVMSupport.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));
 69                 if (configuration == null) {
 70                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;No event configuration found for &quot; + clazz.getName() + &quot;. Ignoring instrumentation request.&quot;);
 71                     // Probably triggered by some other agent
 72                     return oldBytes;
 73                 }
 74                 boolean jdkClass = Utils.isJDKClass(clazz);
 75                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding instrumentation to event class &quot; + clazz.getName() + &quot; using retransform&quot;);
 76                 EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId, jdkClass, false);
 77                 byte[] bytes = ei.buildInstrumented();
 78                 Bytecode.log(clazz.getName(), bytes);
 79                 return bytes;
 80             }
 81             return oldBytes;
 82         } catch (Throwable t) {
 83             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation to event class &quot; + clazz.getName());
 84         }
 85         return oldBytes;
 86     }
 87 
 88     /**
 89      * Called by the JVM when requested to do an &quot;eager&quot; instrumentation. Would
 90      * normally happen when JVMTI retransform capabilities are not available.
 91      *
 92      * @param traceId
 93      *            Id of the class
 94      * @param forceInstrumentation
 95      *            add instrumentation regardless if event is enabled or not.
 96      * @param superClass
 97      *            the super class of the class being processed
 98      * @param oldBytes
 99      *            byte code
100      * @return byte code to use
101      * @throws Throwable
102      */
103     static byte[] bytesForEagerInstrumentation(long traceId, boolean forceInstrumentation, boolean bootClassLoader, Class&lt;?&gt; superClass, byte[] oldBytes) throws Throwable {
104         if (JVMSupport.isNotAvailable()) {
105             return oldBytes;
106         }
107         String eventName = &quot;&lt;Unknown&gt;&quot;;
108         try {
109             EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId, bootClassLoader, true);
110             eventName = ei.getEventName();
111             if (!JVMSupport.shouldInstrument(bootClassLoader,  ei.getEventName())) {
112                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + eventName + &quot; since container support is missing&quot;);
113                 return oldBytes;
114             }
115 
116             if (!forceInstrumentation) {
117                 // Assume we are recording
118                 MetadataRepository mr = MetadataRepository.getInstance();
119                 // No need to generate bytecode if:
120                 // 1) Event class is disabled, and there is not an external configuration that overrides.
121                 // 2) Event class has @Registered(false)
122                 if (!mr.isEnabled(ei.getEventName()) &amp;&amp; !ei.isEnabled() || !ei.isRegistered()) {
123                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for event type &quot; + eventName + &quot; since event was disabled on class load&quot;);
124                     return oldBytes;
125                 }
126             }
<a name="3" id="anc3"></a><span class="line-removed">127             EventWriterKey.ensureEventWriterFactory();</span>
128             Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding &quot; + (forceInstrumentation ? &quot;forced &quot; : &quot;&quot;) + &quot;instrumentation for event type &quot; + eventName + &quot; during initial class load&quot;);
129             byte[] bytes = ei.buildInstrumented();
130             Bytecode.log(ei.getClassName() + &quot;(&quot; + traceId + &quot;)&quot;, bytes);
131             return bytes;
132         } catch (Throwable t) {
133             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation for event type &quot; + eventName);
134             return oldBytes;
135         }
136     }
137 
138     /**
139      * Called by the JVM to ensure metadata for internal events/types become public.
140      *
141      * Must be called after metadata repository has been initialized (JFR created).
142      *
143      */
144     static void unhideInternalTypes() {
145         MetadataRepository.unhideInternalTypes();
146     }
147 
148     /**
149      * Called by the JVM to create the recorder thread.
150      *
151      * @param systemThreadGroup  the system thread group
152      *
153      * @param contextClassLoader the context class loader.
154      *
155      * @return a new thread
156      */
157     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
<a name="4" id="anc4"></a><span class="line-modified">158         return SecuritySupport.createRecorderThread(systemThreadGroup, contextClassLoader);</span>


159     }
160 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>