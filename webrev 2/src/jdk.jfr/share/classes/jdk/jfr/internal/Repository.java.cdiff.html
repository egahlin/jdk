<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PrivateAccess.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RepositoryChunk.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,41 ***</span>
   */
  
  package jdk.jfr.internal;
  
  import java.io.IOException;
  import java.nio.file.Path;
  import java.time.DateTimeException;
  import java.time.LocalDateTime;
  import java.time.ZoneOffset;
  import java.util.HashSet;
  import java.util.Set;
  
<span class="line-removed">- import jdk.jfr.internal.SecuritySupport.SafePath;</span>
  import jdk.jfr.internal.management.ChunkFilename;
  import jdk.jfr.internal.util.ValueFormatter;
  
  public final class Repository {
  
      private static final int MAX_REPO_CREATION_RETRIES = 1000;
      private static final Repository instance = new Repository();
<span class="line-removed">- </span>
      private static final String JFR_REPOSITORY_LOCATION_PROPERTY = &quot;jdk.jfr.repository&quot;;
<span class="line-modified">! </span>
<span class="line-modified">!     private final Set&lt;SafePath&gt; cleanupDirectories = new HashSet&lt;&gt;();</span>
<span class="line-modified">!     private SafePath baseLocation;</span>
<span class="line-removed">-     private SafePath repository;</span>
      private ChunkFilename chunkFilename;
  
      private Repository() {
      }
  
      public static Repository getRepository() {
          return instance;
      }
  
<span class="line-modified">!     public synchronized void setBasePath(SafePath baseLocation) throws IOException {</span>
          if(baseLocation.equals(this.baseLocation)) {
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Same base repository path &quot; + baseLocation.toString() + &quot; is set&quot;);
              return;
          }
          // Probe to see if repository can be created, needed for fail fast
<span class="line-new-header">--- 24,42 ---</span>
   */
  
  package jdk.jfr.internal;
  
  import java.io.IOException;
<span class="line-added">+ import java.nio.file.Files;</span>
  import java.nio.file.Path;
  import java.time.DateTimeException;
  import java.time.LocalDateTime;
  import java.time.ZoneOffset;
  import java.util.HashSet;
  import java.util.Set;
  
  import jdk.jfr.internal.management.ChunkFilename;
  import jdk.jfr.internal.util.ValueFormatter;
<span class="line-added">+ import jdk.jfr.internal.util.DirectoryCleaner;</span>
<span class="line-added">+ import jdk.jfr.internal.util.Utils;</span>
  
  public final class Repository {
  
<span class="line-added">+     private static final Path JAVA_IO_TMPDIR = Utils.getPathInProperty(&quot;java.io.tmpdir&quot;, null);</span>
      private static final int MAX_REPO_CREATION_RETRIES = 1000;
      private static final Repository instance = new Repository();
      private static final String JFR_REPOSITORY_LOCATION_PROPERTY = &quot;jdk.jfr.repository&quot;;
<span class="line-modified">!     private final Set&lt;Path&gt; cleanupDirectories = new HashSet&lt;&gt;();</span>
<span class="line-modified">!     private Path baseLocation;</span>
<span class="line-modified">!     private Path repository;</span>
      private ChunkFilename chunkFilename;
  
      private Repository() {
      }
  
      public static Repository getRepository() {
          return instance;
      }
  
<span class="line-modified">!     public synchronized void setBasePath(Path baseLocation) throws IOException {</span>
          if(baseLocation.equals(this.baseLocation)) {
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Same base repository path &quot; + baseLocation.toString() + &quot; is set&quot;);
              return;
          }
          // Probe to see if repository can be created, needed for fail fast
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,38 ***</span>
          this.repository = createRepository(baseLocation);
          this.chunkFilename = null;
          try {
              // Remove so we don&#39;t &quot;leak&quot; repositories, if JFR is never started
              // and shutdown hook not added.
<span class="line-modified">!             SecuritySupport.delete(repository);</span>
          } catch (IOException ioe) {
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Could not delete disk repository &quot; + repository);
          }
          this.baseLocation = baseLocation;
      }
  
      public synchronized void ensureRepository() throws IOException {
          if (baseLocation == null) {
<span class="line-modified">!             setBasePath(SecuritySupport.JAVA_IO_TMPDIR);</span>
          }
      }
  
      synchronized RepositoryChunk newChunk() {
          LocalDateTime timestamp = timestamp();
          try {
<span class="line-modified">!             if (!SecuritySupport.existDirectory(repository)) {</span>
                  this.repository = createRepository(baseLocation);
                  JVM.setRepositoryLocation(repository.toString());
<span class="line-modified">!                 SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());</span>
                  cleanupDirectories.add(repository);
                  chunkFilename = null;
              }
              if (chunkFilename == null) {
<span class="line-modified">!                 chunkFilename = ChunkFilename.newPriviliged(repository.toPath());</span>
              }
              String filename = chunkFilename.next(timestamp);
<span class="line-modified">!             return new RepositoryChunk(new SafePath(filename));</span>
          } catch (Exception e) {
              String errorMsg = String.format(&quot;Could not create chunk in repository %s, %s: %s&quot;, repository, e.getClass(), e.getMessage());
              Logger.log(LogTag.JFR, LogLevel.ERROR, errorMsg);
              JVM.abort(errorMsg);
              throw new InternalError(&quot;Could not abort after JFR disk creation error&quot;);
<span class="line-new-header">--- 67,38 ---</span>
          this.repository = createRepository(baseLocation);
          this.chunkFilename = null;
          try {
              // Remove so we don&#39;t &quot;leak&quot; repositories, if JFR is never started
              // and shutdown hook not added.
<span class="line-modified">!             Files.delete(repository);</span>
          } catch (IOException ioe) {
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Could not delete disk repository &quot; + repository);
          }
          this.baseLocation = baseLocation;
      }
  
      public synchronized void ensureRepository() throws IOException {
          if (baseLocation == null) {
<span class="line-modified">!             setBasePath(JAVA_IO_TMPDIR);</span>
          }
      }
  
      synchronized RepositoryChunk newChunk() {
          LocalDateTime timestamp = timestamp();
          try {
<span class="line-modified">!             if (!Files.exists(repository)) {</span>
                  this.repository = createRepository(baseLocation);
                  JVM.setRepositoryLocation(repository.toString());
<span class="line-modified">!                 System.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());</span>
                  cleanupDirectories.add(repository);
                  chunkFilename = null;
              }
              if (chunkFilename == null) {
<span class="line-modified">!                 chunkFilename = new ChunkFilename(repository);</span>
              }
              String filename = chunkFilename.next(timestamp);
<span class="line-modified">!             return new RepositoryChunk(Path.of(filename));</span>
          } catch (Exception e) {
              String errorMsg = String.format(&quot;Could not create chunk in repository %s, %s: %s&quot;, repository, e.getClass(), e.getMessage());
              Logger.log(LogTag.JFR, LogLevel.ERROR, errorMsg);
              JVM.abort(errorMsg);
              throw new InternalError(&quot;Could not abort after JFR disk creation error&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,85 ***</span>
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Could not create LocalDateTime with the default time zone. Using UTC time zone for chunk filename.&quot;);
              return LocalDateTime.now(ZoneOffset.UTC);
          }
      }
  
<span class="line-modified">!     private static SafePath createRepository(SafePath basePath) throws IOException {</span>
<span class="line-modified">!         SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);</span>
<span class="line-modified">!         SafePath f = null;</span>
  
          String basename = ValueFormatter.formatDateTime(timestamp()) + &quot;_&quot; + JVM.getPid();
          String name = basename;
  
          int i = 0;
          for (; i &lt; MAX_REPO_CREATION_RETRIES; i++) {
<span class="line-modified">!             f = new SafePath(canonicalBaseRepositoryPath.toPath().resolve(name));</span>
              if (tryToUseAsRepository(f)) {
                  break;
              }
              name = basename + &quot;_&quot; + i;
          }
  
          if (i == MAX_REPO_CREATION_RETRIES) {
              throw new IOException(&quot;Unable to create JFR repository directory using base location (&quot; + basePath + &quot;)&quot;);
          }
<span class="line-modified">!         return SecuritySupport.toRealPath(f);</span>
      }
  
<span class="line-modified">!     private static SafePath createRealBasePath(SafePath safePath) throws IOException {</span>
<span class="line-modified">!         if (SecuritySupport.exists(safePath)) {</span>
<span class="line-modified">!             if (!SecuritySupport.isWritable(safePath)) {</span>
<span class="line-modified">!                 throw new IOException(&quot;JFR repository directory (&quot; + safePath.toString() + &quot;) exists, but isn&#39;t writable&quot;);</span>
              }
<span class="line-modified">!             return SecuritySupport.toRealPath(safePath);</span>
          }
<span class="line-modified">!         SafePath p = SecuritySupport.createDirectories(safePath);</span>
<span class="line-removed">-         return SecuritySupport.toRealPath(p);</span>
      }
  
<span class="line-modified">!     private static boolean tryToUseAsRepository(final SafePath path) {</span>
<span class="line-modified">!         Path parent = path.toPath().getParent();</span>
          if (parent == null) {
              return false;
          }
          try {
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 SecuritySupport.createDirectories(path);</span>
<span class="line-modified">!             } catch (Exception e) {</span>
<span class="line-modified">!                 // file already existed or some other problem occurred</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (!SecuritySupport.exists(path)) {</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             if (!SecuritySupport.isDirectory(path)) {</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         } catch (IOException io) {</span>
              return false;
          }
      }
  
      synchronized void clear() {
          if (Options.getPreserveRepository()) {
              return;
          }
  
<span class="line-modified">!         for (SafePath p : cleanupDirectories) {</span>
              try {
<span class="line-modified">!                 SecuritySupport.clearDirectory(p);</span>
                  Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Removed repository &quot; + p);
              } catch (IOException e) {
                  Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Repository &quot; + p + &quot; could not be removed at shutdown: &quot; + e.getMessage());
              }
          }
      }
  
<span class="line-modified">!     public synchronized SafePath getRepositoryPath() {</span>
          return repository;
      }
  
<span class="line-modified">!     public synchronized SafePath getBaseLocation() {</span>
          return baseLocation;
      }
  
  }
<span class="line-new-header">--- 112,80 ---</span>
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Could not create LocalDateTime with the default time zone. Using UTC time zone for chunk filename.&quot;);
              return LocalDateTime.now(ZoneOffset.UTC);
          }
      }
  
<span class="line-modified">!     private static Path createRepository(Path basePath) throws IOException {</span>
<span class="line-modified">!         Path canonicalBaseRepositoryPath = createRealBasePath(basePath);</span>
<span class="line-modified">!         Path f = null;</span>
  
          String basename = ValueFormatter.formatDateTime(timestamp()) + &quot;_&quot; + JVM.getPid();
          String name = basename;
  
          int i = 0;
          for (; i &lt; MAX_REPO_CREATION_RETRIES; i++) {
<span class="line-modified">!             f = canonicalBaseRepositoryPath.resolve(name);</span>
              if (tryToUseAsRepository(f)) {
                  break;
              }
              name = basename + &quot;_&quot; + i;
          }
  
          if (i == MAX_REPO_CREATION_RETRIES) {
              throw new IOException(&quot;Unable to create JFR repository directory using base location (&quot; + basePath + &quot;)&quot;);
          }
<span class="line-modified">!         return f.toRealPath();</span>
      }
  
<span class="line-modified">!     private static Path createRealBasePath(Path path) throws IOException {</span>
<span class="line-modified">!         if (Files.exists(path)) {</span>
<span class="line-modified">!             if (!Files.isWritable(path)) {</span>
<span class="line-modified">!                 throw new IOException(&quot;JFR repository directory (&quot; + path.toString() + &quot;) exists, but isn&#39;t writable&quot;);</span>
              }
<span class="line-modified">!             return path.toRealPath();</span>
          }
<span class="line-modified">!         return Files.createDirectories(path).toRealPath();</span>
      }
  
<span class="line-modified">!     private static boolean tryToUseAsRepository(Path path) {</span>
<span class="line-modified">!         Path parent = path.getParent();</span>
          if (parent == null) {
              return false;
          }
          try {
<span class="line-modified">!             Files.createDirectories(path);</span>
<span class="line-modified">!         } catch (Exception e) {</span>
<span class="line-modified">!             // file already existed or some other problem occurred</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (!Files.exists(path)) {</span>
<span class="line-modified">!             return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (!Files.isDirectory(path)) {</span>
              return false;
          }
<span class="line-added">+         return true;</span>
      }
  
      synchronized void clear() {
          if (Options.getPreserveRepository()) {
              return;
          }
  
<span class="line-modified">!         for (Path p : cleanupDirectories) {</span>
              try {
<span class="line-modified">!                 DirectoryCleaner.clear(p);</span>
                  Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Removed repository &quot; + p);
              } catch (IOException e) {
                  Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Repository &quot; + p + &quot; could not be removed at shutdown: &quot; + e.getMessage());
              }
          }
      }
  
<span class="line-modified">!     public synchronized Path getRepositoryPath() {</span>
          return repository;
      }
  
<span class="line-modified">!     public synchronized Path getBaseLocation() {</span>
          return baseLocation;
      }
  
  }
</pre>
<center><a href="PrivateAccess.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RepositoryChunk.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>