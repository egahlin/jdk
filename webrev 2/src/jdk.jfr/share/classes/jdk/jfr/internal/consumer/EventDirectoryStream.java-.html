<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.security.AccessControlContext;
 31 import java.time.Instant;
 32 import java.util.Arrays;
 33 import java.util.Comparator;
 34 import java.util.List;
 35 import java.util.Objects;
 36 import java.util.concurrent.atomic.AtomicLong;
 37 import java.util.function.Consumer;
 38 
 39 import jdk.jfr.Configuration;
 40 import jdk.jfr.RecordingState;
 41 import jdk.jfr.consumer.RecordedEvent;
 42 import jdk.jfr.internal.JVM;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;
 46 import jdk.jfr.internal.PlatformRecording;
 47 import jdk.jfr.internal.SecuritySupport;
 48 import jdk.jfr.internal.util.Utils;
 49 import jdk.jfr.internal.management.StreamBarrier;
 50 
 51 /**
 52  * Implementation of an {@code EventStream}} that operates against a directory
 53  * with chunk files.
 54  *
 55  */
 56 public final class EventDirectoryStream extends AbstractEventStream {
 57 
 58     private static final Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 59 
 60     private final RepositoryFiles repositoryFiles;
 61     private final FileAccess fileAccess;
 62     private final PlatformRecording recording;
 63     private final StreamBarrier barrier = new StreamBarrier();
 64     private final AtomicLong streamId = new AtomicLong();
 65     private ChunkParser currentParser;
 66     private long currentChunkStartNanos;
 67     private RecordedEvent[] sortedCache;
 68     private int threadExclusionLevel = 0;
 69     private volatile Consumer&lt;Long&gt; onCompleteHandler;
 70 
 71     public EventDirectoryStream(
 72             @SuppressWarnings(&quot;removal&quot;)
 73             AccessControlContext acc,
 74             Path p,
 75             FileAccess fileAccess,
 76             PlatformRecording recording,
 77             List&lt;Configuration&gt; configurations,
 78             boolean allowSubDirectories) throws IOException {
 79         super(acc, configurations);
 80         this.recording = recording;
 81         if (p != null &amp;&amp; SecuritySupport.PRIVILEGED == fileAccess) {
 82             throw new SecurityException(&quot;Priviliged file access not allowed with potentially malicious Path implementation&quot;);
 83         }
 84         this.fileAccess = Objects.requireNonNull(fileAccess);
 85         this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);
 86         this.streamId.incrementAndGet();
 87         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Stream &quot; + streamId + &quot; started.&quot;);
 88     }
 89 
 90     @Override
 91     public void close() {
 92         closeParser();
 93         dispatcher().runCloseActions();
 94         repositoryFiles.close();
 95         if (currentParser != null) {
 96             currentParser.close();
 97             onComplete(currentParser.getEndNanos());
 98         }
 99     }
100 
101     public void setChunkCompleteHandler(Consumer&lt;Long&gt; handler) {
102         onCompleteHandler = handler;
103     }
104 
105     private void onComplete(long epochNanos) {
106         Consumer&lt;Long&gt; handler = onCompleteHandler;
107         if (handler != null) {
108             handler.accept(epochNanos);
109         }
110     }
111 
112     @Override
113     public void start() {
114         start(Utils.timeToNanos(Instant.now()));
115     }
116 
117     @Override
118     public void startAsync() {
119         startAsync(Utils.timeToNanos(Instant.now()));
120     }
121 
122     @Override
123     protected void process() throws IOException {
124         Thread t = Thread.currentThread();
125         try {
126             if (JVM.isExcluded(t)) {
127                 threadExclusionLevel++;
128             } else {
129                 JVM.exclude(t);
130             }
131             processRecursionSafe();
132         } finally {
133             if (threadExclusionLevel &gt; 0) {
134                 threadExclusionLevel--;
135             } else {
136                 JVM.include(t);
137             }
138         }
139     }
140 
141     protected void processRecursionSafe() throws IOException {
142         Dispatcher lastDisp = null;
143         Dispatcher disp = dispatcher();
144         Path path;
145         boolean validStartTime = isRecordingStream() || disp.startTime != null;
146         if (validStartTime) {
147             path = repositoryFiles.firstPath(disp.startNanos, true);
148         } else {
149             path = repositoryFiles.lastPath(true);
150         }
151         if (path == null) { // closed
152             logStreamEnd(&quot;no first chunk file found.&quot;);
153             return;
154         }
155         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
156         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {
157             input.setStreamed();
158             currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
159             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
160             long filterStart = validStartTime ? disp.startNanos : segmentStart;
161             long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
162             while (!isClosed()) {
163                 onMetadata(currentParser);
164                 while (!isClosed() &amp;&amp; !currentParser.isChunkFinished()) {
165                     disp = dispatcher();
166                     if (disp != lastDisp) {
167                         var ranged = disp.parserConfiguration.withRange(filterStart, filterEnd);
168                         currentParser.updateConfiguration(ranged, true);
169                         lastDisp = disp;
170                     }
171                     if (disp.parserConfiguration.ordered()) {
172                         processOrdered(disp);
173                     } else {
174                         processUnordered(disp);
175                     }
176                     currentParser.resetCache();
177                     long lastFlush = currentParser.getLastFlush();
178                     if (lastFlush  &gt; filterEnd) {
179                         logStreamEnd(&quot;end time at &quot; + filterEnd +
180                                      &quot;ns (epoch), parser at &quot; + lastFlush + &quot;ns (epoch).&quot;);
181                         return;
182                     }
183                 }
184                 long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();
185                 long endMillis = Instant.ofEpochSecond(0, endNanos).toEpochMilli();
186 
187                 barrier.check(); // block if recording is being stopped
188                 if (barrier.getStreamEnd() &lt;= endMillis) {
189                     String msg = &quot;stopped at &quot; + barrier.getStreamEnd() + &quot;ms (epoch), &quot;;
190                     msg += &quot;parser at &quot; + endMillis + &quot;ms (epoch), &quot; + endNanos + &quot;ns (epoch)&quot;;
191                     logStreamEnd(msg);
192                     return;
193                 }
194 
195                 if (isRecordingStream()) {
196                     if (recording.getState() == RecordingState.STOPPED &amp;&amp; !barrier.used()) {
197                         logStreamEnd(&quot;recording stopped externally.&quot;);
198                         return;
199                     }
200                 }
201 
202                 if (repositoryFiles.hasFixedPath() &amp;&amp; currentParser.isFinalChunk()) {
203                     logStreamEnd(&quot;JVM process exited/crashed, or repository migrated to an unknown location.&quot;);
204                     return;
205                 }
206                 if (isClosed()) {
207                     logStreamEnd(&quot;stream closed.&quot;);
208                     return;
209                 }
210                 long durationNanos = currentParser.getChunkDuration();
211                 long endChunkNanos = currentParser.getEndNanos();
212                 if (durationNanos == 0) {
213                     // Avoid reading the same chunk again and again if
214                     // duration is 0 ns
215                     durationNanos++;
216                     if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO)) {
217                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Unexpected chunk with 0 ns duration&quot;);
218                     }
219                 }
220                 path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos, true);
221                 if (path == null) {
222                     logStreamEnd(&quot;no more chunk files found.&quot;);
223                     return;
224                 }
225                 currentChunkStartNanos = repositoryFiles.getTimestamp(path);
226                 input.setFile(path);
227                 onComplete(endChunkNanos);
228                 currentParser = currentParser.newChunkParser();
229                 // TODO: Optimization. No need filter when we reach new chunk
230                 // Could set start = 0;
231             }
232         }
233     }
234 
235     private void logStreamEnd(String text) {
236         String msg = &quot;Stream &quot; + streamId + &quot; ended, &quot; + text;
237         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, msg);
238     }
239 
240     protected boolean isRecordingStream() {
241         return recording != null;
242     }
243 
244     private void processOrdered(Dispatcher c) throws IOException {
245         if (sortedCache == null) {
246             sortedCache = new RecordedEvent[100_000];
247         }
248         int index = 0;
249         while (true) {
250             RecordedEvent e = currentParser.readStreamingEvent();
251             if (e == null) {
252                 break;
253             }
254             if (index == sortedCache.length) {
255                 sortedCache = Arrays.copyOf(sortedCache, sortedCache.length * 2);
256             }
257             sortedCache[index++] = e;
258         }
259         onMetadata(currentParser);
260         // no events found
261         if (index == 0 &amp;&amp; currentParser.isChunkFinished()) {
262             onFlush();
263             return;
264         }
265         // at least 2 events, sort them
266         if (index &gt; 1) {
267             Arrays.sort(sortedCache, 0, index, EVENT_COMPARATOR);
268         }
269         for (int i = 0; i &lt; index; i++) {
270             c.dispatch(sortedCache[i]);
271         }
272         onFlush();
273         return;
274     }
275 
276     private boolean processUnordered(Dispatcher c) throws IOException {
277         while (true) {
278             RecordedEvent e = currentParser.readStreamingEvent();
279             if (e == null) {
280                 onFlush();
281                 return true;
282             }
283             onMetadata(currentParser);
284             c.dispatch(e);
285         }
286     }
287 
288     public StreamBarrier activateStreamBarrier() {
289         barrier.activate();
290         return barrier;
291     }
292 }
    </pre>
  </body>
</html>