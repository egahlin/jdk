<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ChunkFilename.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../periodic/JavaEventTask.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.management;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.util.Collections;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.function.Consumer;
<span class="line-removed"> 37 import java.security.AccessControlContext;</span>
<span class="line-removed"> 38 </span>
 39 import jdk.jfr.Configuration;
 40 import jdk.jfr.EventSettings;
 41 import jdk.jfr.EventType;
 42 import jdk.jfr.Recording;
 43 import jdk.jfr.consumer.EventStream;
 44 import jdk.jfr.internal.JDKEvents;
 45 import jdk.jfr.internal.JVMSupport;
 46 import jdk.jfr.internal.LogLevel;
 47 import jdk.jfr.internal.LogTag;
 48 import jdk.jfr.internal.Logger;
 49 import jdk.jfr.internal.MetadataRepository;
 50 import jdk.jfr.internal.PlatformRecording;
 51 import jdk.jfr.internal.PrivateAccess;
<span class="line-removed"> 52 import jdk.jfr.internal.SecuritySupport;</span>
<span class="line-removed"> 53 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 54 import jdk.jfr.internal.util.Utils;
 55 import jdk.jfr.internal.util.ValueFormatter;
 56 import jdk.jfr.internal.util.ValueParser;
<span class="line-modified"> 57 import jdk.jfr.internal.WriteableUserPath;</span>
 58 import jdk.jfr.internal.consumer.AbstractEventStream;
 59 import jdk.jfr.internal.consumer.EventDirectoryStream;
<span class="line-removed"> 60 import jdk.jfr.internal.consumer.FileAccess;</span>
 61 
 62 /**
 63  * The management API in module jdk.management.jfr should be built on top of the
 64  * public API in jdk.jfr. Before putting more functionality here, consider if it
 65  * should not be part of the public API, and if not, please provide motivation
 66  *
 67  */
 68 public final class ManagementSupport {
 69 
 70     // Purpose of this method is to expose the event types to the
 71     // FlightRecorderMXBean without instantiating Flight Recorder.
 72     //
 73     // This allows:
 74     //
 75     // 1) discoverability, so event settings can be exposed without the need to
 76     // create a new Recording in FlightRecorderMXBean.
 77     //
 78     // 2) a graphical JMX client to list all attributes to the user, without
 79     // loading JFR memory buffers. This is especially important when there is
 80     // no intent to use Flight Recorder.
 81     //
 82     // An alternative design would be to make FlightRecorder#getEventTypes
 83     // static, but it would the make the API look strange
 84     //
 85     public static List&lt;EventType&gt; getEventTypes() {
 86         // would normally be checked when a Flight Recorder instance is created
<span class="line-removed"> 87         SecuritySupport.checkAccessFlightRecorder();</span>
 88         if (JVMSupport.isNotAvailable()) {
 89             return List.of();
 90         }
 91         JDKEvents.initialize(); // make sure JDK events are available
 92         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
 93     }
 94 
 95     // Reuse internal code for parsing a timespan
 96     public static long parseTimespan(String s) {
 97         return ValueParser.parseTimespan(s);
 98     }
 99 
100     // Reuse internal code for converting nanoseconds since epoch to Instant
101     public static Instant epochNanosToInstant(long epochNanos) {
102       return Utils.epochNanosToInstant(epochNanos);
103     }
104 
105     // Reuse internal code for formatting settings
106     public static final String formatTimespan(Duration dValue, String separation) {
107         return ValueFormatter.formatTimespan(dValue, separation);
108     }
109 
110     // Reuse internal logging mechanism
111     public static void logError(String message) {
112         Logger.log(LogTag.JFR, LogLevel.ERROR, message);
113     }
114 
115     // Reuse internal logging mechanism
116     public static void logDebug(String message) {
117         Logger.log(LogTag.JFR, LogLevel.DEBUG, message);
118     }
119 
120     // Get the textual representation when the destination was set, which
121     // requires access to jdk.jfr.internal.PlatformRecording
122     public static String getDestinationOriginalText(Recording recording) {
123         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">124         WriteableUserPath wup = pr.getDestination();</span>
<span class="line-modified">125         return wup == null ? null : wup.getOriginalText();</span>
126     }
127 
128     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
129     // can abort if not all data is valid
<span class="line-modified">130     public static void checkSetDestination(Recording recording, String destination) throws IOException{</span>
131         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
132         if(destination != null){
<span class="line-modified">133             WriteableUserPath wup = new WriteableUserPath(Paths.get(destination));</span>
<span class="line-removed">134             pr.checkSetDestination(wup);</span>
135         }
136     }
137 
138     // Needed to modify setting using fluent API.
139     public static EventSettings newEventSettings(EventSettingsModifier esm) {
140         return PrivateAccess.getInstance().newEventSettings(esm);
141     }
142 
143     // Needed callback to detect when a chunk has been parsed.
144     public static void removePath(Recording recording, Path path) {
145         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">146         pr.removePath(new SafePath(path));</span>
147     }
148 
149     // Needed callback to detect when a chunk has been parsed.
150     public static void setOnChunkCompleteHandler(EventStream stream, Consumer&lt;Long&gt; consumer) {
151         EventDirectoryStream eds = (EventDirectoryStream) stream;
152         eds.setChunkCompleteHandler(consumer);
153     }
154 
155     // Needed to start an ongoing stream at the right chunk, which
156     // can be identified by the start time with nanosecond precision.
157     public static long getStartTimeNanos(Recording recording) {
158         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
159         return pr.getStartNanos();
160     }
161 
162     // Needed to produce Configuration objects for MetadataEvent
163     public static Configuration newConfiguration(String name, String label, String description, String provider,
164           Map&lt;String, String&gt; settings, String contents) {
165         return PrivateAccess.getInstance().newConfiguration(name, label, description, provider, settings, contents);
166     }
167 
168     // Can&#39;t use EventStream.openRepository(...) because
169     // EventStream::onMetadataData need to supply MetadataEvent
170     // with configuration objects
171     public static EventStream newEventDirectoryStream(
<span class="line-removed">172             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">173             AccessControlContext acc,</span>
174             Path directory,
175             List&lt;Configuration&gt; confs) throws IOException {
176         return new EventDirectoryStream(
<span class="line-removed">177             acc,</span>
178             directory,
<span class="line-removed">179             FileAccess.UNPRIVILEGED,</span>
180             null,
181             confs,
182             false
183         );
184     }
185 
186     // An EventStream is passive, so a stop() method doesn&#39;t fit well in the API.
187     // RemoteRecordingStream::stop() implementation need to prevent stream
188     // from being closed, so this method is needed
189     public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {
190         AbstractEventStream aes = (AbstractEventStream) stream;
191         aes.setCloseOnComplete(closeOnComplete);
192     }
193 
194     // Internal method needed to block parser
195     public static StreamBarrier activateStreamBarrier(EventStream stream) {
196         EventDirectoryStream aes = (EventDirectoryStream) stream;
197         return aes.activateStreamBarrier();
198     }
199 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.management;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.util.Collections;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.function.Consumer;


 37 import jdk.jfr.Configuration;
 38 import jdk.jfr.EventSettings;
 39 import jdk.jfr.EventType;
 40 import jdk.jfr.Recording;
 41 import jdk.jfr.consumer.EventStream;
 42 import jdk.jfr.internal.JDKEvents;
 43 import jdk.jfr.internal.JVMSupport;
 44 import jdk.jfr.internal.LogLevel;
 45 import jdk.jfr.internal.LogTag;
 46 import jdk.jfr.internal.Logger;
 47 import jdk.jfr.internal.MetadataRepository;
 48 import jdk.jfr.internal.PlatformRecording;
 49 import jdk.jfr.internal.PrivateAccess;


 50 import jdk.jfr.internal.util.Utils;
 51 import jdk.jfr.internal.util.ValueFormatter;
 52 import jdk.jfr.internal.util.ValueParser;
<span class="line-modified"> 53 import jdk.jfr.internal.WriteablePath;</span>
 54 import jdk.jfr.internal.consumer.AbstractEventStream;
 55 import jdk.jfr.internal.consumer.EventDirectoryStream;

 56 
 57 /**
 58  * The management API in module jdk.management.jfr should be built on top of the
 59  * public API in jdk.jfr. Before putting more functionality here, consider if it
 60  * should not be part of the public API, and if not, please provide motivation
 61  *
 62  */
 63 public final class ManagementSupport {
 64 
 65     // Purpose of this method is to expose the event types to the
 66     // FlightRecorderMXBean without instantiating Flight Recorder.
 67     //
 68     // This allows:
 69     //
 70     // 1) discoverability, so event settings can be exposed without the need to
 71     // create a new Recording in FlightRecorderMXBean.
 72     //
 73     // 2) a graphical JMX client to list all attributes to the user, without
 74     // loading JFR memory buffers. This is especially important when there is
 75     // no intent to use Flight Recorder.
 76     //
 77     // An alternative design would be to make FlightRecorder#getEventTypes
 78     // static, but it would the make the API look strange
 79     //
 80     public static List&lt;EventType&gt; getEventTypes() {
 81         // would normally be checked when a Flight Recorder instance is created

 82         if (JVMSupport.isNotAvailable()) {
 83             return List.of();
 84         }
 85         JDKEvents.initialize(); // make sure JDK events are available
 86         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
 87     }
 88 
 89     // Reuse internal code for parsing a timespan
 90     public static long parseTimespan(String s) {
 91         return ValueParser.parseTimespan(s);
 92     }
 93 
 94     // Reuse internal code for converting nanoseconds since epoch to Instant
 95     public static Instant epochNanosToInstant(long epochNanos) {
 96       return Utils.epochNanosToInstant(epochNanos);
 97     }
 98 
 99     // Reuse internal code for formatting settings
100     public static final String formatTimespan(Duration dValue, String separation) {
101         return ValueFormatter.formatTimespan(dValue, separation);
102     }
103 
104     // Reuse internal logging mechanism
105     public static void logError(String message) {
106         Logger.log(LogTag.JFR, LogLevel.ERROR, message);
107     }
108 
109     // Reuse internal logging mechanism
110     public static void logDebug(String message) {
111         Logger.log(LogTag.JFR, LogLevel.DEBUG, message);
112     }
113 
114     // Get the textual representation when the destination was set, which
115     // requires access to jdk.jfr.internal.PlatformRecording
116     public static String getDestinationOriginalText(Recording recording) {
117         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">118         WriteablePath wp = pr.getDestination();</span>
<span class="line-modified">119         return wp == null ? null : wp.getPath().toString();</span>
120     }
121 
122     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
123     // can abort if not all data is valid
<span class="line-modified">124     public static void checkSetDestination(Recording recording, String destination) throws IOException {</span>
125         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
126         if(destination != null){
<span class="line-modified">127             pr.checkSetDestination(new WriteablePath(Paths.get(destination)));</span>

128         }
129     }
130 
131     // Needed to modify setting using fluent API.
132     public static EventSettings newEventSettings(EventSettingsModifier esm) {
133         return PrivateAccess.getInstance().newEventSettings(esm);
134     }
135 
136     // Needed callback to detect when a chunk has been parsed.
137     public static void removePath(Recording recording, Path path) {
138         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">139         pr.removePath(path);</span>
140     }
141 
142     // Needed callback to detect when a chunk has been parsed.
143     public static void setOnChunkCompleteHandler(EventStream stream, Consumer&lt;Long&gt; consumer) {
144         EventDirectoryStream eds = (EventDirectoryStream) stream;
145         eds.setChunkCompleteHandler(consumer);
146     }
147 
148     // Needed to start an ongoing stream at the right chunk, which
149     // can be identified by the start time with nanosecond precision.
150     public static long getStartTimeNanos(Recording recording) {
151         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
152         return pr.getStartNanos();
153     }
154 
155     // Needed to produce Configuration objects for MetadataEvent
156     public static Configuration newConfiguration(String name, String label, String description, String provider,
157           Map&lt;String, String&gt; settings, String contents) {
158         return PrivateAccess.getInstance().newConfiguration(name, label, description, provider, settings, contents);
159     }
160 
161     // Can&#39;t use EventStream.openRepository(...) because
162     // EventStream::onMetadataData need to supply MetadataEvent
163     // with configuration objects
164     public static EventStream newEventDirectoryStream(


165             Path directory,
166             List&lt;Configuration&gt; confs) throws IOException {
167         return new EventDirectoryStream(

168             directory,

169             null,
170             confs,
171             false
172         );
173     }
174 
175     // An EventStream is passive, so a stop() method doesn&#39;t fit well in the API.
176     // RemoteRecordingStream::stop() implementation need to prevent stream
177     // from being closed, so this method is needed
178     public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {
179         AbstractEventStream aes = (AbstractEventStream) stream;
180         aes.setCloseOnComplete(closeOnComplete);
181     }
182 
183     // Internal method needed to block parser
184     public static StreamBarrier activateStreamBarrier(EventStream stream) {
185         EventDirectoryStream aes = (EventDirectoryStream) stream;
186         return aes.activateStreamBarrier();
187     }
188 }
</pre>
</td>
</tr>
</table>
<center><a href="ChunkFilename.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../periodic/JavaEventTask.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>