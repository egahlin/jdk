<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.lang.constant.ClassDesc;
 29 import java.lang.constant.MethodTypeDesc;
 30 import java.lang.reflect.Field;
 31 import java.lang.reflect.Modifier;
 32 import java.util.ArrayList;
 33 import java.util.HashSet;
 34 import java.util.LinkedHashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Set;
 38 import java.util.function.Consumer;
 39 
 40 import java.lang.classfile.Annotation;
 41 import java.lang.classfile.AnnotationElement;
 42 import java.lang.classfile.AnnotationValue;
 43 import java.lang.classfile.ClassElement;
 44 import java.lang.classfile.ClassModel;
 45 import java.lang.classfile.ClassFile;
 46 import java.lang.classfile.CodeBuilder;
 47 import java.lang.classfile.CodeBuilder.BlockCodeBuilder;
 48 import java.lang.classfile.FieldModel;
 49 import java.lang.classfile.Label;
 50 import java.lang.classfile.MethodModel;
 51 import java.lang.classfile.Opcode;
 52 import java.lang.classfile.TypeKind;
 53 import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
 54 import jdk.jfr.internal.event.EventConfiguration;
 55 import jdk.jfr.internal.event.EventWriter;
 56 import jdk.jfr.Enabled;
 57 import jdk.jfr.Event;
 58 import jdk.jfr.Name;
 59 import jdk.jfr.Registered;
 60 import jdk.jfr.SettingControl;
 61 import jdk.jfr.SettingDefinition;
 62 import jdk.jfr.internal.util.Utils;
 63 import jdk.jfr.internal.util.Bytecode;
 64 import jdk.jfr.internal.util.ImplicitFields;
 65 import jdk.jfr.internal.util.Bytecode.FieldDesc;
 66 import jdk.jfr.internal.util.Bytecode.MethodDesc;
 67 import static jdk.jfr.internal.util.Bytecode.invokevirtual;
 68 import static jdk.jfr.internal.util.Bytecode.invokestatic;
 69 import static jdk.jfr.internal.util.Bytecode.getfield;
 70 import static jdk.jfr.internal.util.Bytecode.putfield;
 71 import static jdk.jfr.internal.util.Bytecode.classDesc;
 72 
 73 /**
 74  * Class responsible for adding instrumentation to a subclass of {@link Event}.
 75  *
 76  */
 77 final class EventInstrumentation {
 78 
 79     private record SettingDesc(ClassDesc paramType, String methodName) {
 80     }
 81 
 82     private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, ImplicitFields.DURATION);
 83     private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, &quot;eventConfiguration&quot;);;
 84     private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, ImplicitFields.START_TIME);
 85     private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);
 86     private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);
 87     private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);
 88     private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);
 89     private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);
 90     private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);
 91     private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);
<a name="2" id="anc2"></a>
 92     private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);
 93     private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);
 94     private static final MethodDesc METHOD_BEGIN = MethodDesc.of(&quot;begin&quot;, &quot;()V&quot;);
 95     private static final MethodDesc METHOD_COMMIT = MethodDesc.of(&quot;commit&quot;, &quot;()V&quot;);
 96     private static final MethodDesc METHOD_DURATION = MethodDesc.of(&quot;duration&quot;, &quot;(J)J&quot;);
 97     private static final MethodDesc METHOD_ENABLED = MethodDesc.of(&quot;enabled&quot;, &quot;()Z&quot;);
 98     private static final MethodDesc METHOD_END = MethodDesc.of(&quot;end&quot;, &quot;()V&quot;);
 99     private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
100     private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(&quot;getSetting&quot;, SettingControl.class, int.class);
101     private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;()Z&quot;);
<a name="3" id="anc3"></a><span class="line-modified">102     private static final MethodDesc METHOD_GET_EVENT_WRITER = MethodDesc.of(&quot;getEventWriter&quot;, &quot;()&quot; + TYPE_EVENT_WRITER.descriptorString());</span>
103     private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(&quot;isEnabled&quot;, &quot;()Z&quot;);
104     private static final MethodDesc METHOD_RESET = MethodDesc.of(&quot;reset&quot;, &quot;()V&quot;);
105     private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
106     private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(&quot;timestamp&quot;, &quot;()J&quot;);
107 
108     private final ClassModel classModel;
109     private final List&lt;SettingDesc&gt; settingDescs;
110     private final List&lt;FieldDesc&gt; fieldDescs;;
111     private final String eventName;
112     private final String className;
113     private final Class&lt;?&gt; superClass;
114     private final boolean untypedEventConfiguration;
115     private final MethodDesc staticCommitMethod;
116     private final long eventTypeId;
117     private final boolean guardEventConfiguration;
118     private final boolean isJDK;
119     private final Map&lt;MethodDesc, Consumer&lt;CodeBuilder&gt;&gt; methodUpdates = new LinkedHashMap&lt;&gt;();
120     private final ImplicitFields implicitFields;
121 
122     EventInstrumentation(Class&lt;?&gt; superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {
123         this.eventTypeId = id;
124         this.superClass = superClass;
125         this.isJDK = isJDK;
126         this.classModel = createClassModel(bytes);
127         this.className = classModel.thisClass().asInternalName().replace(&quot;/&quot;, &quot;.&quot;);
128         String name = annotationValue(classModel, ANNOTATION_NAME, String.class);
129         this.eventName = name == null ? className : name;
130         this.implicitFields = determineImplicitFields();
131         this.settingDescs = buildSettingDescs(superClass, classModel);
132         this.fieldDescs = buildFieldDescs(superClass, classModel);
133         this.staticCommitMethod = isJDK ? findStaticCommitMethod(classModel, fieldDescs) : null;
134         this.untypedEventConfiguration = hasUntypedConfiguration();
135         // Corner case when we are forced to generate bytecode
136         // (bytesForEagerInstrumentation)
137         // We can&#39;t reference EventConfiguration::isEnabled() before event class has
138         // been registered,
139         // so we add a guard against a null reference.
140         this.guardEventConfiguration = guardEventConfiguration;
141     }
142 
143     private ImplicitFields determineImplicitFields() {
144         if (isJDK) {
145             Class&lt;?&gt; eventClass = MirrorEvents.find(isJDK, className);
146             if (eventClass != null) {
147                 return new ImplicitFields(eventClass);
148             }
149         }
150         ImplicitFields ifs = new ImplicitFields(superClass);
151         String[] value = annotationValue(classModel, ANNOTATION_REMOVE_FIELDS, String[].class);
152         if (value != null) {
153             ifs.removeFields(value);
154         }
155         return ifs;
156     }
157 
158     static MethodDesc findStaticCommitMethod(ClassModel classModel, List&lt;FieldDesc&gt; fields) {
159         StringBuilder sb = new StringBuilder();
160         sb.append(&quot;(&quot;);
161         for (FieldDesc field : fields) {
162             sb.append(field.type().descriptorString());
163         }
164         sb.append(&quot;)V&quot;);
165         MethodDesc m = MethodDesc.of(&quot;commit&quot;, sb.toString());
166         for (MethodModel method : classModel.methods()) {
167             String d = method.methodTypeSymbol().descriptorString();
168             if (method.methodName().equalsString(&quot;commit&quot;) &amp;&amp; m.descriptor().descriptorString().equals(d)) {
169                 return m;
170             }
171         }
172         return null;
173     }
174 
175     private boolean hasUntypedConfiguration() {
176         for (FieldModel f : classModel.fields()) {
177             if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {
178                 return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());
179             }
180         }
181         throw new InternalError(&quot;Class missing configuration field&quot;);
182     }
183 
184     public String getClassName() {
185         return classModel.thisClass().asInternalName().replace(&quot;/&quot;, &quot;.&quot;);
186     }
187 
188     private ClassModel createClassModel(byte[] bytes) {
189         return ClassFile.of().parse(bytes);
190     }
191 
192     boolean isRegistered() {
193         Boolean result = annotationValue(classModel, ANNOTATION_REGISTERED, Boolean.class);
194         if (result != null) {
195             return result.booleanValue();
196         }
197         if (superClass != null) {
198             Registered r = superClass.getAnnotation(Registered.class);
199             if (r != null) {
200                 return r.value();
201             }
202         }
203         return true;
204     }
205 
206     boolean isEnabled() {
207         Boolean result = annotationValue(classModel, ANNOTATION_ENABLED, Boolean.class);
208         if (result != null) {
209             return result.booleanValue();
210         }
211         if (superClass != null) {
212             Enabled e = superClass.getAnnotation(Enabled.class);
213             if (e != null) {
214                 return e.value();
215             }
216         }
217         return true;
218     }
219 
220     @SuppressWarnings(&quot;unchecked&quot;)
221     // Only supports String, String[] and Boolean values
222     private static &lt;T&gt; T annotationValue(ClassModel classModel, ClassDesc classDesc, Class&lt;T&gt; type) {
223         String typeDescriptor = classDesc.descriptorString();
224         for (ClassElement ce : classModel) {
225             if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {
226                 for (Annotation a : rvaa.annotations()) {
227                     if (a.className().equalsString(typeDescriptor)) {
228                         if (a.elements().size() == 1) {
229                             AnnotationElement ae = a.elements().getFirst();
230                             if (ae.name().equalsString(&quot;value&quot;)) {
231                                 if (ae.value() instanceof AnnotationValue.OfBoolean ofb &amp;&amp; type.equals(Boolean.class)) {
232                                     Boolean b = ofb.booleanValue();
233                                     return (T)b;
234                                 }
235                                 if (ae.value() instanceof AnnotationValue.OfString ofs &amp;&amp; type.equals(String.class)) {
236                                     String s = ofs.stringValue();
237                                     return (T)s;
238                                 }
239                                 if (ae.value() instanceof AnnotationValue.OfArray ofa &amp;&amp; type.equals(String[].class)) {
240                                     List&lt;AnnotationValue&gt; list = ofa.values();
241                                     String[] array = new String[list.size()];
242                                     int index = 0;
243                                     for (AnnotationValue av : list) {
244                                         var avs = (AnnotationValue.OfString)av;
245                                         array[index++] = avs.stringValue();
246                                     }
247                                     return (T)array;
248                                 }
249                             }
250                         }
251                     }
252                 }
253             }
254         }
255         return null;
256     }
257 
258     private static List&lt;SettingDesc&gt; buildSettingDescs(Class&lt;?&gt; superClass, ClassModel classModel) {
259         Set&lt;String&gt; methodSet = new HashSet&lt;&gt;();
260         List&lt;SettingDesc&gt; settingDescs = new ArrayList&lt;&gt;();
261         for (MethodModel m : classModel.methods()) {
262             for (var me : m) {
263                 if (me instanceof RuntimeVisibleAnnotationsAttribute rvaa) {
264                     for (Annotation a : rvaa.annotations()) {
265                         // We can&#39;t really validate the method at this
266                         // stage. We would need to check that the parameter
267                         // is an instance of SettingControl.
268                         if (a.className().equalsString(TYPE_SETTING_DEFINITION.descriptorString())) {
269                             String name = m.methodName().stringValue();
270                             // Use @Name if it exists
271                             for (Annotation nameCandidate : rvaa.annotations()) {
272                                 if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {
273                                     if (nameCandidate.elements().size() == 1) {
274                                         AnnotationElement ae = nameCandidate.elements().getFirst();
275                                         if (ae.name().equalsString(&quot;value&quot;)) {
276                                             if (ae.value() instanceof AnnotationValue.OfString s) {
277                                                 name = Utils.validJavaIdentifier(s.stringValue(), name);
278                                             }
279                                         }
280                                     }
281                                 }
282                             }
283                             // Add setting if method returns boolean and has one parameter
284                             MethodTypeDesc mtd = m.methodTypeSymbol();
285                             if (&quot;Z&quot;.equals(mtd.returnType().descriptorString())) {
286                                 if (mtd.parameterList().size() == 1) {
287                                     ClassDesc type = mtd.parameterList().getFirst();
288                                     if (type.isClassOrInterface()) {
289                                         String methodName = m.methodName().stringValue();
290                                         methodSet.add(methodName);
291                                         settingDescs.add(new SettingDesc(type, methodName));
292                                     }
293                                 }
294                             }
295                         }
296                     }
297                 }
298             }
299         }
300         for (Class&lt;?&gt; c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {
301             for (java.lang.reflect.Method method : c.getDeclaredMethods()) {
302                 if (!methodSet.contains(method.getName())) {
303                     // skip private method in base classes
304                     if (!Modifier.isPrivate(method.getModifiers())) {
305                         if (method.getReturnType().equals(Boolean.TYPE)) {
306                             if (method.getParameterCount() == 1) {
307                                 Class&lt;?&gt; type = method.getParameters()[0].getType();
308                                 if (SettingControl.class.isAssignableFrom(type)) {
309                                     ClassDesc paramType = Bytecode.classDesc(type);
310                                     methodSet.add(method.getName());
311                                     settingDescs.add(new SettingDesc(paramType, method.getName()));
312                                 }
313                             }
314                         }
315                     }
316                 }
317             }
318         }
319         return settingDescs;
320     }
321 
322     private List&lt;FieldDesc&gt; buildFieldDescs(Class&lt;?&gt; superClass, ClassModel classModel) {
323         Set&lt;String&gt; fieldSet = new HashSet&lt;&gt;();
324         List&lt;FieldDesc&gt; fieldDescs = new ArrayList&lt;&gt;(classModel.fields().size());
325         // These two fields are added by native as &#39;transient&#39; so they will be
326         // ignored by the loop below.
327         // The benefit of adding them manually is that we can
328         // control in which order they occur and we can add @Name, @Description
329         // in Java, instead of in native. It also means code for adding implicit
330         // fields for native can be reused by Java.
331         fieldDescs.add(FIELD_START_TIME);
332         if (implicitFields.hasDuration()) {
333             fieldDescs.add(FIELD_DURATION);
334         }
335         for (FieldModel field : classModel.fields()) {
336             if (!fieldSet.contains(field.fieldName().stringValue()) &amp;&amp; isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {
337                 FieldDesc fi = FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue());
338                 fieldDescs.add(fi);
339                 fieldSet.add(field.fieldName().stringValue());
340             }
341         }
342         for (Class&lt;?&gt; c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {
343             for (Field field : c.getDeclaredFields()) {
344                 // skip private field in base classes
345                 if (!Modifier.isPrivate(field.getModifiers())) {
346                     if (isValidField(field.getModifiers(), field.getType().getName())) {
347                         String fieldName = field.getName();
348                         if (!fieldSet.contains(fieldName)) {
349                             fieldDescs.add(FieldDesc.of(field.getType(), fieldName));
350                             fieldSet.add(fieldName);
351                         }
352                     }
353                 }
354             }
355         }
356         return fieldDescs;
357     }
358 
359     public static boolean isValidField(int access, ClassDesc classDesc) {
360         String className = classDesc.packageName();
361         if (!className.isEmpty()) {
362             className = className + &quot;.&quot;;
363         }
364         className += classDesc.displayName();
365         return isValidField(access, className);
366     }
367 
368     public static boolean isValidField(int access, String className) {
369         if (Modifier.isTransient(access) || Modifier.isStatic(access)) {
370             return false;
371         }
372         return Type.isValidJavaFieldType(className);
373     }
374 
375     public byte[] buildInstrumented() {
376         makeInstrumented();
377         return toByteArray();
378     }
379 
380     byte[] toByteArray() {
381         return ClassFile.of().build(classModel.thisClass().asSymbol(), classBuilder -&gt; {
382             for (ClassElement ce : classModel) {
383                 boolean updated = false;
384                 if (ce instanceof MethodModel method) {
385                     Consumer&lt;CodeBuilder&gt; methodUpdate = findMethodUpdate(method);
386                     if (methodUpdate != null) {
387                         classBuilder.withMethod(method.methodName().stringValue(), method.methodTypeSymbol(), method.flags().flagsMask(), methodBuilder -&gt; {
388                             methodBuilder.withCode(methodUpdate);
389                         });
390                         updated = true;
391                     }
392                 }
393                 if (!updated) {
394                     classBuilder.with(ce);
395                 }
396             }
397         });
398     }
399 
400     public byte[] buildUninstrumented() {
401         makeUninstrumented();
402         return toByteArray();
403     }
404 
405     private void throwMissingDuration(CodeBuilder codeBuilder, String method) {
406         String message = &quot;Cannot use method &quot; + method + &quot; when event lacks duration field&quot;;
407         Bytecode.throwException(codeBuilder, TYPE_ISE, message);
408     }
409 
410     private void makeInstrumented() {
411         // MyEvent#isEnabled()
412         updateEnabledMethod(METHOD_IS_ENABLED);
413 
414         // MyEvent#begin()
415         updateMethod(METHOD_BEGIN, codeBuilder -&gt; {
416             if (!implicitFields.hasDuration()) {
417                 throwMissingDuration(codeBuilder, &quot;begin&quot;);
418             } else {
419                 codeBuilder.aload(0);
420                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
421                 putfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);
422                 codeBuilder.return_();
423             }
424         });
425 
426         // MyEvent#end()
427         updateMethod(METHOD_END, codeBuilder -&gt; {
428             if (!implicitFields.hasDuration()) {
429                 throwMissingDuration(codeBuilder, &quot;end&quot;);
430             } else {
431                 codeBuilder.aload(0);
432                 codeBuilder.aload(0);
433                 getfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);
434                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);
435                 putfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);
436                 codeBuilder.return_();
437             }
438         });
439 
440         // MyEvent#commit() or static MyEvent#commit(...)
441         MethodDesc m = staticCommitMethod == null ? METHOD_COMMIT : staticCommitMethod;
442         updateMethod(m, codeBuilder -&gt; {
443             Label excluded = codeBuilder.newLabel();
444             Label end = codeBuilder.newLabel();
445             codeBuilder.trying(blockCodeBuilder -&gt; {
446                 if (staticCommitMethod != null) {
447                     updateStaticCommit(blockCodeBuilder, excluded);
448                 } else {
449                     updateInstanceCommit(blockCodeBuilder, end, excluded);
450                 }
451                 // stack: [integer]
452                 // notified -&gt; restart event write attempt
453                 blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());
454                 // stack: []
455                 blockCodeBuilder.goto_(end);
456             }, catchBuilder -&gt; {
457                 catchBuilder.catchingAll(catchAllHandler -&gt; {
458                     getEventWriter(catchAllHandler);
459                     // stack: [ex] [EW]
460                     catchAllHandler.dup();
461                     // stack: [ex] [EW] [EW]
462                     Label rethrow = catchAllHandler.newLabel();
463                     catchAllHandler.ifnull(rethrow);
464                     // stack: [ex] [EW]
465                     catchAllHandler.dup();
466                     // stack: [ex] [EW] [EW]
467                     invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);
468                     catchAllHandler.labelBinding(rethrow);
469                     // stack:[ex] [EW]
470                     catchAllHandler.pop();
471                     // stack:[ex]
472                     catchAllHandler.athrow();
473                 });
474             });
475             codeBuilder.labelBinding(excluded);
476             // stack: [EW]
477             codeBuilder.pop();
478             codeBuilder.labelBinding(end);
479             // stack: []
480             codeBuilder.return_();
481         });
482 
483         // MyEvent#shouldCommit()
484         updateMethod(METHOD_EVENT_SHOULD_COMMIT, codeBuilder -&gt; {
485             Label fail = codeBuilder.newLabel();
486             if (guardEventConfiguration) {
487                 getEventConfiguration(codeBuilder);
488                 codeBuilder.ifnull(fail);
489             }
490             // if (!eventConfiguration.shouldCommit(duration) goto fail;
491             getEventConfiguration(codeBuilder);
492             codeBuilder.aload(0);
493             getfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);
494             invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);
495             codeBuilder.ifeq(fail);
496             for (int index = 0; index &lt; settingDescs.size(); index++) {
497                 SettingDesc sd = settingDescs.get(index);
498                 // if (!settingsMethod(eventConfiguration.settingX)) goto fail;
499                 codeBuilder.aload(0);
500                 getEventConfiguration(codeBuilder);
501                 codeBuilder.loadConstant(index);
502                 invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);
503                 MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(&quot;(&quot; + sd.paramType().descriptorString() + &quot;)Z&quot;);
504                 codeBuilder.checkcast(sd.paramType());
505                 codeBuilder.invokevirtual(getEventClassDesc(), sd.methodName(), mdesc);
506                 codeBuilder.ifeq(fail);
507             }
508             // return true
509             codeBuilder.iconst_1();
510             codeBuilder.ireturn();
511             // return false
512             codeBuilder.labelBinding(fail);
513             codeBuilder.iconst_0();
514             codeBuilder.ireturn();
515         });
516 
517         if (isJDK) {
518             if (hasStaticMethod(METHOD_ENABLED)) {
519                 updateEnabledMethod(METHOD_ENABLED);
520             }
521 
522             updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, codeBuilder -&gt; {
523                 Label fail = codeBuilder.newLabel();
524                 if (guardEventConfiguration) {
525                     // if (eventConfiguration == null) goto fail;
526                     getEventConfiguration(codeBuilder);
527                     codeBuilder.ifnull(fail);
528                 }
529                 // return eventConfiguration.shouldCommit(duration);
530                 getEventConfiguration(codeBuilder);
531                 codeBuilder.lload(0);
532                 codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());
533                 codeBuilder.ireturn();
534                 // fail:
535                 codeBuilder.labelBinding(fail);
536                 // return false
537                 codeBuilder.iconst_0();
538                 codeBuilder.ireturn();
539             });
540             updateIfStaticMethodExists(METHOD_TIME_STAMP, codeBuilder -&gt; {
541                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
542                 codeBuilder.lreturn();
543             });
544         }
545     }
546 
547     void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {
548         // indexes the argument type array, the argument type array does not include
549         // &#39;this&#39;
550         int argIndex = 0;
551         // indexes the proper slot in the local variable table, takes type size into
552         // account, therefore sometimes argIndex != slotIndex
553         int slotIndex = 0;
554         int fieldIndex = 0;
555         ClassDesc[] argumentTypes = staticCommitMethod.descriptor().parameterArray();
556         TypeKind tk = null;
557         getEventWriter(blockCodeBuilder);
558         // stack: [EW],
559         blockCodeBuilder.dup();
560         // stack: [EW], [EW]
561         // write begin event
562         getEventConfiguration(blockCodeBuilder);
563         // stack: [EW], [EW], [EventConfiguration]
564         blockCodeBuilder.loadConstant(eventTypeId);
565         // stack: [EW], [EW], [EventConfiguration] [long]
566         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());
567         // stack: [EW], [integer]
568         blockCodeBuilder.ifeq(excluded);
569         // stack: [EW]
570         // write startTime
571         blockCodeBuilder.dup();
572         // stack: [EW], [EW]
573         tk = TypeKind.from(argumentTypes[argIndex++]);
574         blockCodeBuilder.loadLocal(tk, slotIndex);
575         // stack: [EW], [EW], [long]
576         slotIndex += tk.slotSize();
577         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
578         fieldIndex++;
579         // stack: [EW]
580         if (implicitFields.hasDuration()) {
581             // write duration
582             blockCodeBuilder.dup();
583             // stack: [EW], [EW]
584             tk = TypeKind.from(argumentTypes[argIndex++]);
585             blockCodeBuilder.loadLocal(tk, slotIndex);
586             // stack: [EW], [EW], [long]
587             slotIndex += tk.slotSize();
588             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
589             fieldIndex++;
590         }
591         // stack: [EW]
592         if (implicitFields.hasEventThread()) {
593             // write eventThread
594             blockCodeBuilder.dup();
595             // stack: [EW], [EW]
596             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());
597         }
598         // stack: [EW]
599         if (implicitFields.hasStackTrace()) {
600             // write stackTrace
601             blockCodeBuilder.dup();
602             // stack: [EW], [EW]
603             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());
604         }
605         // stack: [EW]
606         // write custom fields
607         while (fieldIndex &lt; fieldDescs.size()) {
608             blockCodeBuilder.dup();
609             // stack: [EW], [EW]
610             tk = TypeKind.from(argumentTypes[argIndex++]);
611             blockCodeBuilder.loadLocal(tk, slotIndex);
612             // stack:[EW], [EW], [field]
613             slotIndex += tk.slotSize();
614             FieldDesc field = fieldDescs.get(fieldIndex);
615             EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);
616             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());
617             // stack: [EW]
618             fieldIndex++;
619         }
620         // stack: [EW]
621         // write end event (writer already on stack)
622         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());
623         // stack: [int]
624     }
625 
626     void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {
627         // if (!isEnable()) {
628         // return;
629         // }
630         blockCodeBuilder.aload(0);
631         invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_IS_ENABLED);
632         Label l0 = blockCodeBuilder.newLabel();
633         blockCodeBuilder.ifne(l0);
634         blockCodeBuilder.return_();
635         blockCodeBuilder.labelBinding(l0);
636         // long startTime = this.startTime
637         blockCodeBuilder.aload(0);
638         getfield(blockCodeBuilder, getEventClassDesc(), FIELD_START_TIME);
639         blockCodeBuilder.lstore(1);
640         // if (startTime == 0) {
641         //   startTime = EventWriter.timestamp();
642         // } else {
643         blockCodeBuilder.lload(1);
644         blockCodeBuilder.lconst_0();
645         blockCodeBuilder.lcmp();
646         Label durationEvent = blockCodeBuilder.newLabel();
647         blockCodeBuilder.ifne(durationEvent);
648         invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
649         blockCodeBuilder.lstore(1);
650         Label commit = blockCodeBuilder.newLabel();
651         blockCodeBuilder.goto_(commit);
652         //   if (duration == 0) {
653         //     duration = EventWriter.timestamp() - startTime;
654         //   }
655         // }
656         blockCodeBuilder.labelBinding(durationEvent);
657         blockCodeBuilder.aload(0);
658         getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
659         blockCodeBuilder.lconst_0();
660         blockCodeBuilder.lcmp();
661         blockCodeBuilder.ifne(commit);
662         blockCodeBuilder.aload(0);
663         invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
664         blockCodeBuilder.lload(1);
665         blockCodeBuilder.lsub();
666         putfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
667         blockCodeBuilder.labelBinding(commit);
668         // if (shouldCommit()) {
669         blockCodeBuilder.aload(0);
670         invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_EVENT_SHOULD_COMMIT);
671         blockCodeBuilder.ifeq(end);
672         getEventWriter(blockCodeBuilder);
673         // stack: [EW]
674         blockCodeBuilder.dup();
675         // stack: [EW] [EW]
676         getEventConfiguration(blockCodeBuilder);
677         // stack: [EW] [EW] [EC]
678         blockCodeBuilder.loadConstant(eventTypeId);
679         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());
680         // stack: [EW] [int]
681         blockCodeBuilder.ifeq(excluded);
682         // stack: [EW]
683         int fieldIndex = 0;
684         blockCodeBuilder.dup();
685         // stack: [EW] [EW]
686         blockCodeBuilder.lload(1);
687         // stack: [EW] [EW] [long]
688         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
689         fieldIndex++;
690         // stack: [EW]
691         if (implicitFields.hasDuration()) {
692             // write duration
693             blockCodeBuilder.dup();
694             // stack: [EW] [EW]
695             blockCodeBuilder.aload(0);
696             // stack: [EW] [EW] [this]
697             getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
698             // stack: [EW] [EW] [long]
699             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
700             fieldIndex++;
701         }
702         // stack: [EW]
703         if (implicitFields.hasEventThread()) {
704             // write eventThread
705             blockCodeBuilder.dup();
706             // stack: [EW] [EW]
707             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());
708         }
709         // stack: [EW]
710         if (implicitFields.hasStackTrace()) {
711             // write stack trace
712             blockCodeBuilder.dup();
713             // stack: [EW] [EW]
714             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());
715         }
716         // stack: [EW]
717         while (fieldIndex &lt; fieldDescs.size()) {
718             FieldDesc field = fieldDescs.get(fieldIndex);
719             blockCodeBuilder.dup();
720             // stack: [EW] [EW]
721             blockCodeBuilder.aload(0);
722             // stack: [EW] [EW] [this]
723             getfield(blockCodeBuilder, getEventClassDesc(), field);
724             // stack: [EW] [EW] &lt;T&gt;
725             EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);
726             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());
727             // stack: [EW]
728             fieldIndex++;
729         }
730         // stack:[EW]
731         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());
732         // stack:[int]
733     }
734 
735     private void updateEnabledMethod(MethodDesc method) {
736         updateMethod(method, codeBuilder -&gt; {
737             Label nullLabel = codeBuilder.newLabel();
738             if (guardEventConfiguration) {
739                 getEventConfiguration(codeBuilder);
740                 codeBuilder.ifnull(nullLabel);
741             }
742             getEventConfiguration(codeBuilder);
743             invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);
744             codeBuilder.ireturn();
745             if (guardEventConfiguration) {
746                 codeBuilder.labelBinding(nullLabel);
747                 codeBuilder.iconst_0();
748                 codeBuilder.ireturn();
749             }
750         });
751     }
752 
753     private void updateIfStaticMethodExists(MethodDesc method, Consumer&lt;CodeBuilder&gt; code) {
754         if (hasStaticMethod(method)) {
755             updateMethod(method, code);
756         }
757     }
758 
759     private boolean hasStaticMethod(MethodDesc method) {
760         for (MethodModel m : classModel.methods()) {
761             if (m.methodName().equalsString(method.name()) &amp;&amp; m.methodTypeSymbol().equals(method.descriptor())) {
762                 return Modifier.isStatic(m.flags().flagsMask());
763             }
764         }
765         return false;
766     }
767 
768     private void getEventWriter(CodeBuilder codeBuilder) {
<a name="4" id="anc4"></a><span class="line-modified">769         invokestatic(codeBuilder, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);</span>

770     }
771 
772     private void getEventConfiguration(CodeBuilder codeBuilder) {
773         if (untypedEventConfiguration) {
774             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);
775             codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);
776         } else {
777             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);
778         }
779     }
780 
781     private void makeUninstrumented() {
782         updateExistingWithReturnFalse(METHOD_EVENT_SHOULD_COMMIT);
783         updateExistingWithReturnFalse(METHOD_IS_ENABLED);
784         updateExistingWithEmptyVoidMethod(METHOD_COMMIT);
785         if (staticCommitMethod != null) {
786             updateExistingWithEmptyVoidMethod(staticCommitMethod);
787         }
788         updateExistingWithEmptyVoidMethod(METHOD_BEGIN);
789         updateExistingWithEmptyVoidMethod(METHOD_END);
790     }
791 
792     private final void updateExistingWithEmptyVoidMethod(MethodDesc voidMethod) {
793         updateMethod(voidMethod, codeBuilder -&gt; {
794             codeBuilder.return_();
795         });
796     }
797 
798     private final void updateExistingWithReturnFalse(MethodDesc voidMethod) {
799         updateMethod(voidMethod, codeBuilder -&gt; {
800             codeBuilder.iconst_0();
801             codeBuilder.ireturn();
802         });
803     }
804 
805     private Consumer&lt;CodeBuilder&gt; findMethodUpdate(MethodModel mm) {
806         MethodDesc m = MethodDesc.of(mm.methodName().stringValue(), mm.methodType().stringValue());
807         return methodUpdates.get(m);
808     }
809 
810     private void updateMethod(MethodDesc method, Consumer&lt;CodeBuilder&gt; codeBuilder) {
811         methodUpdates.put(method, codeBuilder);
812     }
813 
814     private ClassDesc getEventClassDesc() {
815         return classModel.thisClass().asSymbol();
816     }
817 
818     public String getEventName() {
819         return eventName;
820     }
821 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>