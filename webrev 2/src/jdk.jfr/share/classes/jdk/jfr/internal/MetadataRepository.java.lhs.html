<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.DataOutputStream;
 30 import java.io.IOException;
 31 import java.lang.reflect.Constructor;
 32 import java.lang.reflect.InvocationTargetException;
 33 import java.time.Instant;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Comparator;
 37 import java.util.HashSet;
 38 import java.util.LinkedHashMap;
 39 import java.util.List;
 40 import java.util.Map;
 41 
 42 import jdk.jfr.AnnotationElement;
 43 import jdk.jfr.Event;
 44 import jdk.jfr.EventType;
 45 import jdk.jfr.Name;
 46 import jdk.jfr.Period;
 47 import jdk.jfr.ValueDescriptor;
 48 import jdk.jfr.internal.consumer.RepositoryFiles;
 49 import jdk.jfr.internal.event.EventConfiguration;
 50 import jdk.jfr.internal.management.HiddenWait;
 51 import jdk.jfr.internal.periodic.PeriodicEvents;
 52 import jdk.jfr.internal.util.Utils;
 53 
 54 public final class MetadataRepository {
 55 
 56     private static final MetadataRepository instance = new MetadataRepository();
 57 
 58     private final Map&lt;String, EventType&gt; nativeEventTypes = LinkedHashMap.newHashMap(150);
 59     private final Map&lt;String, EventControl&gt; nativeControls = LinkedHashMap.newHashMap(150);
 60     private final SettingsManager settingsManager = new SettingsManager();
 61     private final HiddenWait threadSleeper = new HiddenWait();
 62     private Constructor&lt;EventConfiguration&gt; cachedEventConfigurationConstructor;
 63     private boolean staleMetadata = true;
 64     private boolean unregistered;
 65     private long lastUnloaded = -1;
 66 
 67     private long lastMillis;
 68 
 69     public MetadataRepository() {
 70         initializeJVMEventTypes();
 71     }
 72 
 73     private void initializeJVMEventTypes() {
 74         TypeLibrary.initialize();
 75         for (Type type : TypeLibrary.getTypes()) {
 76             if (type instanceof PlatformEventType pEventType) {
 77                 EventType eventType = PrivateAccess.getInstance().newEventType(pEventType);
 78                 pEventType.setHasCutoff(type.hasAnnotation(Cutoff.class));
 79                 pEventType.setHasThrottle(type.hasAnnotation(Throttle.class));
 80                 pEventType.setHasLevel(type.hasAnnotation(Level.class));
 81                 pEventType.setHasPeriod(type.hasAnnotation(Period.class));
 82                 // Must add hook before EventControl is created as it removes
 83                 // annotations, such as Period and Threshold.
 84                 if (pEventType.hasPeriod()) {
 85                     pEventType.setEventHook(true);
 86                     if (!pEventType.isMethodSampling()) {
 87                         PeriodicEvents.addJVMEvent(pEventType);
 88                     }
 89                 }
 90                 String name = eventType.getName();
 91                 nativeControls.put(name, new EventControl(pEventType));
 92                 nativeEventTypes.put(name,eventType);
 93             }
 94         }
 95     }
 96 
 97     public static MetadataRepository getInstance() {
 98         return instance;
 99     }
100 
101     public synchronized List&lt;EventType&gt; getRegisteredEventTypes() {
102         List&lt;EventConfiguration&gt; configurations = getEventConfigurations();
103         List&lt;EventType&gt; eventTypes = new ArrayList&lt;&gt;(configurations.size() + nativeEventTypes.size());
104         for (EventConfiguration ec : configurations) {
105             if (ec.isRegistered()) {
106                 eventTypes.add(ec.getEventType());
107             }
108         }
109         for (EventType t : nativeEventTypes.values()) {
110             if (PrivateAccess.getInstance().isVisible(t)) {
111                 eventTypes.add(t);
112             }
113         }
114         return eventTypes;
115     }
116 
117     public synchronized EventType getEventType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
118         EventConfiguration ec = getConfiguration(eventClass, false);
119         if (ec != null &amp;&amp; ec.isRegistered()) {
120             return ec.getEventType();
121         }
122         throw new IllegalStateException(&quot;Event class &quot; + eventClass.getName() + &quot; is not registered&quot;);
123     }
124 
125     public synchronized void unregister(Class&lt;? extends Event&gt; eventClass) {
<a name="2" id="anc2"></a><span class="line-removed">126         SecuritySupport.checkRegisterPermission();</span>
127         EventConfiguration configuration = getConfiguration(eventClass, false);
128         if (configuration != null) {
129             configuration.getPlatformEventType().setRegistered(false);
130         }
131         // never registered, ignore call
132     }
133     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
134         return register(eventClass, Collections.emptyList(), Collections.emptyList());
135     }
136 
137     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) {
<a name="3" id="anc3"></a><span class="line-removed">138         SecuritySupport.checkRegisterPermission();</span>
139         if (JVM.isExcluded(eventClass)) {
140             // Event classes are marked as excluded during class load
141             // if they override methods in the jdk.jfr.Event class, i.e. commit().
142             // An excluded class lacks a configuration field and can&#39;t be used by JFR.
143             // The Event::commit() is marked as final, so javac won&#39;t
144             // compile an override, but it can be constructed by other means.
145             throw new IllegalArgumentException(&quot;Must not override methods declared in jdk.jfr.Event&quot;);
146         }
147         EventConfiguration configuration = getConfiguration(eventClass, true);
148         if (configuration == null) {
149             PlatformEventType pe = findMirrorType(eventClass);
150             configuration = makeConfiguration(eventClass, pe, dynamicAnnotations, dynamicFields);
151         }
152         configuration.getPlatformEventType().setRegistered(true);
153         TypeLibrary.addType(configuration.getPlatformEventType());
154         if (JVM.isRecording()) {
155             settingsManager.setEventControl(configuration.getEventControl(), true, JVM.counterTime());
156             settingsManager.updateRetransform(Collections.singletonList((eventClass)));
157        }
158        setStaleMetadata();
159        return configuration.getEventType();
160     }
161 
162     private PlatformEventType findMirrorType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) throws InternalError {
163         Class&lt;? extends MirrorEvent&gt; mirrorClass = MirrorEvents.find(eventClass);
164         if (mirrorClass == null) {
165             return null; // not a mirror
166         }
167         Utils.verifyMirror(mirrorClass, eventClass);
168         PlatformEventType et = (PlatformEventType) TypeLibrary.createType(mirrorClass);
169         TypeLibrary.removeType(et.getId());
170         long id = Type.getTypeId(eventClass);
171         et.setId(id);
172         return et;
173     }
174 
175     private EventConfiguration getConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, boolean ensureInitialized) {
176         Utils.ensureValidEventSubclass(eventClass);
177         SecuritySupport.makeVisibleToJFR(eventClass);
178         if (ensureInitialized) {
179             Utils.ensureInitialized(eventClass);
180         }
181         return JVMSupport.getConfiguration(eventClass);
182     }
183 
184     private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {
185         try {
186             if (cachedEventConfigurationConstructor == null) {
187                 var argClasses = new Class&lt;?&gt;[] { EventType.class, EventControl.class};
188                 Constructor&lt;EventConfiguration&gt; c = EventConfiguration.class.getDeclaredConstructor(argClasses);
<a name="4" id="anc4"></a><span class="line-modified">189                 SecuritySupport.setAccessible(c);</span>
190                 cachedEventConfigurationConstructor = c;
191             }
192             return cachedEventConfigurationConstructor.newInstance(eventType, ec);
193         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
194             throw new InternalError(e);
195         }
196     }
197 
198     private EventConfiguration makeConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, PlatformEventType pEventType, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) throws InternalError {
199         SecuritySupport.addInternalEventExport(eventClass);
200         if (pEventType == null) {
201             pEventType = (PlatformEventType) TypeLibrary.createType(eventClass, dynamicAnnotations, dynamicFields);
202         }
203         // Check for native mirror.
204         // Note, defining an event in metadata.xml is not a generic mechanism to emit
205         // native data in Java. For example, calling JVM.getStackTraceId(int, long)
206         // and assign the result to a long field is not enough to always get a proper
207         // stack trace. Purpose of the mechanism is to transfer metadata, such as
208         // native type IDs, without specialized Java logic for each type.
209         if (Utils.isJDKClass(eventClass)) {
210             Name name = eventClass.getAnnotation(Name.class);
211             if (name != null) {
212                 String n = name.value();
213                 EventType nativeType = nativeEventTypes.get(n);
214                 if (nativeType != null) {
215                     var nativeFields = nativeType.getFields();
216                     var eventFields = pEventType.getFields();
217                     var comparator = Comparator.comparing(ValueDescriptor::getName);
218                     if (!Utils.compareLists(nativeFields, eventFields, comparator)) {
219                         throw new InternalError(&quot;Field for native mirror event &quot; + n + &quot; doesn&#39;t match Java event&quot;);
220                     }
221                     nativeEventTypes.remove(n);
222                     nativeControls.remove(n);
223                     TypeLibrary.removeType(nativeType.getId());
224                     pEventType.setAnnotations(nativeType.getAnnotationElements());
225                     pEventType.setFields(nativeType.getFields());
226                 }
227             }
228         }
229         EventType eventType = PrivateAccess.getInstance().newEventType(pEventType);
230         EventControl ec = new EventControl(pEventType, eventClass);
231         EventConfiguration configuration = newEventConfiguration(eventType, ec);
232         PlatformEventType pe = configuration.getPlatformEventType();
233         pe.setRegistered(true);
234         // If class is instrumented or should not be instrumented, mark as instrumented.
235         if (JVM.isInstrumented(eventClass) || !JVMSupport.shouldInstrument(pe.isJDK(), pe.getName())) {
236             pe.setInstrumented();
237         }
238         JVMSupport.setConfiguration(eventClass, configuration);
239         return configuration;
240     }
241 
242     public synchronized void setSettings(List&lt;Map&lt;String, String&gt;&gt; list, boolean writeSettingEvents) {
243         settingsManager.setSettings(list, writeSettingEvents);
244     }
245 
246     synchronized void disableEvents() {
247         for (EventControl c : getEventControls()) {
248             c.disable();
249         }
250     }
251 
252     public synchronized List&lt;EventControl&gt; getEventControls() {
253         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = JVM.getAllEventClasses();
254         ArrayList&lt;EventControl&gt; controls = new ArrayList&lt;&gt;(eventClasses.size() + nativeControls.size());
255         controls.addAll(nativeControls.values());
256         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : eventClasses) {
257             EventConfiguration eh = JVMSupport.getConfiguration(clazz);
258             if (eh != null) {
259                 controls.add(eh.getEventControl());
260             }
261         }
262         return controls;
263     }
264 
265     private void storeDescriptorInJVM() throws InternalError {
266         JVM.storeMetadataDescriptor(getBinaryRepresentation());
267         staleMetadata = false;
268     }
269 
270     private static List&lt;EventConfiguration&gt; getEventConfigurations() {
271         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; allEventClasses = JVM.getAllEventClasses();
272         List&lt;EventConfiguration&gt; eventConfigurations = new ArrayList&lt;&gt;(allEventClasses.size());
273         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : allEventClasses) {
274             EventConfiguration ec = JVMSupport.getConfiguration(clazz);
275             if (ec != null) {
276                 eventConfigurations.add(ec);
277             }
278         }
279         return eventConfigurations;
280     }
281 
282     private byte[] getBinaryRepresentation() {
283         ByteArrayOutputStream baos = new ByteArrayOutputStream(40000);
284         DataOutputStream daos = new DataOutputStream(baos);
285         try {
286             List&lt;Type&gt; types = TypeLibrary.getVisibleTypes();
287             if (Logger.shouldLog(LogTag.JFR_METADATA, LogLevel.DEBUG)) {
288                 Collections.sort(types,Comparator.comparing(Type::getName));
289                 for (Type t: types) {
290                     Logger.log(LogTag.JFR_METADATA, LogLevel.INFO, &quot;Serialized type: &quot; + t.getName() + &quot; id=&quot; + t.getId());
291                 }
292             }
293             Collections.sort(types);
294             MetadataDescriptor.write(types, daos);
295             daos.flush();
296             return baos.toByteArray();
297         } catch (IOException e) {
298             // should not happen
299             throw new InternalError(e);
300         }
301     }
302 
303     synchronized boolean isEnabled(String eventName) {
304         return settingsManager.isEnabled(eventName);
305     }
306 
307     synchronized void setStaleMetadata() {
308         staleMetadata = true;
309     }
310 
311     // Lock around setOutput ensures that other threads don&#39;t
312     // emit events after setOutput and unregister the event class, before a call
313     // to storeDescriptorInJVM
314     synchronized Instant setOutput(String filename) {
315         if (staleMetadata) {
316             storeDescriptorInJVM();
317         }
318         // Each chunk needs a unique timestamp. If two chunks get the same
319         // timestamp, the parser may stop prematurely at an earlier chunk.
320         // The resolution needs to be measured in milliseconds as this
321         // is what RecordingInfo:getStopTime() returns.
322         awaitEpochMilliShift();
323         JVM.setOutput(filename);
324         long chunkStart = JVMSupport.getChunkStartNanos();
325         if (filename != null) {
326             RepositoryFiles.notifyNewFile();
327         }
328         unregisterUnloaded();
329         if (unregistered) {
330             if (TypeLibrary.clearUnregistered()) {
331                 storeDescriptorInJVM();
332             }
333             unregistered = false;
334         }
335         return Utils.epochNanosToInstant(chunkStart);
336     }
337 
338     private void awaitEpochMilliShift() {
339         while (true) {
340             long nanos = JVM.nanosNow();
341             long millis = Utils.epochNanosToInstant(nanos).toEpochMilli();
342             if (millis != lastMillis) {
343                 lastMillis = millis;
344                 return;
345             }
346             threadSleeper.takeNap(1);
347         }
348     }
349 
350     private void unregisterUnloaded() {
351         long unloaded = JVM.getUnloadedEventClassCount();
352         if (this.lastUnloaded != unloaded) {
353             this.lastUnloaded = unloaded;
354             List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = JVM.getAllEventClasses();
355             HashSet&lt;Long&gt; knownIds = new HashSet&lt;&gt;(eventClasses.size());
356             for (Class&lt;? extends jdk.internal.event.Event&gt;  ec: eventClasses) {
357                 knownIds.add(Type.getTypeId(ec));
358             }
359             for (Type type : TypeLibrary.getTypes()) {
360                 if (type instanceof PlatformEventType pe) {
361                     if (!knownIds.contains(pe.getId())) {
362                         if (!pe.isJVM()) {
363                             pe.setRegistered(false);
364                             if (pe.hasStackFilters()) {
365                                 JVM.unregisterStackFilter(pe.getStackFilterId());
366                             }
367                         }
368                     }
369                 }
370             }
371         }
372     }
373 
374     synchronized void setUnregistered() {
375        unregistered = true;
376     }
377 
378     public synchronized void flush() {
379         if (staleMetadata) {
380             storeDescriptorInJVM();
381         }
382         JVM.flush();
383     }
384 
385     static void unhideInternalTypes() {
386         for (Type t : TypeLibrary.getTypes()) {
387             if (t.isInternal()) {
388                 t.setVisible(true);
389                 Logger.log(LogTag.JFR_METADATA, LogLevel.DEBUG, &quot;Unhiding internal type &quot; + t.getName());
390             }
391         }
392         // Singleton should have been initialized here.
393         // It&#39;s not possible to call MetadataRepository().getInstance(),
394         // because it will deadlock with Java thread calling flush() or setOutput();
395         instance.storeDescriptorInJVM();
396     }
397 
398     public synchronized List&lt;Type&gt; getVisibleTypes() {
399         return TypeLibrary.getVisibleTypes();
400     }
401 
402     public synchronized long registerStackFilter(String[] typeArray, String[] methodArray) {
403         return JVM.registerStackFilter(typeArray, methodArray);
404     }
405 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>