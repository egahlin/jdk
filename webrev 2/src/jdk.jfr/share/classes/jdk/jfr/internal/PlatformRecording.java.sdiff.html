<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogLevel.ERROR;
 30 import static jdk.jfr.internal.LogLevel.INFO;
 31 import static jdk.jfr.internal.LogLevel.WARN;
 32 import static jdk.jfr.internal.LogTag.JFR;
 33 
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.nio.channels.FileChannel;
 37 import java.nio.file.NoSuchFileException;

 38 import java.nio.file.StandardOpenOption;
<span class="line-removed"> 39 import java.security.AccessControlContext;</span>
<span class="line-removed"> 40 import java.security.AccessController;</span>
<span class="line-removed"> 41 import java.security.PrivilegedActionException;</span>
<span class="line-removed"> 42 import java.security.PrivilegedExceptionAction;</span>
 43 import java.time.Duration;
 44 import java.time.Instant;
 45 import java.time.LocalDateTime;
 46 import java.util.ArrayList;
 47 import java.util.Collections;
 48 import java.util.Date;
 49 import java.util.Iterator;
 50 import java.util.LinkedHashMap;
 51 import java.util.LinkedList;
 52 import java.util.List;
 53 import java.util.Map;
 54 import java.util.StringJoiner;
 55 import java.util.TimerTask;
 56 import java.util.TreeMap;
 57 
 58 import jdk.jfr.Configuration;
 59 import jdk.jfr.FlightRecorderListener;
 60 import jdk.jfr.Recording;
 61 import jdk.jfr.RecordingState;
<span class="line-removed"> 62 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 63 import jdk.jfr.internal.util.Utils;
 64 import jdk.jfr.internal.util.ValueFormatter;
 65 
 66 public final class PlatformRecording implements AutoCloseable {
 67 
 68     private final PlatformRecorder recorder;
 69     private final long id;
 70     // Recording settings
 71     private Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();
 72     private Duration duration;
 73     private Duration maxAge;
 74     private long maxSize;
 75 
<span class="line-modified"> 76     private WriteableUserPath destination;</span>
 77 
 78     private boolean toDisk = true;
 79     private String name;
 80     private boolean dumpOnExit;
<span class="line-modified"> 81     private SafePath dumpDirectory;</span>
 82     // Timestamp information
 83     private Instant stopTime;
 84     private Instant startTime;
 85 
 86     // Misc, information
 87     private RecordingState state = RecordingState.NEW;
 88     private long size;
 89     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 90     private volatile Recording recording;
 91     private TimerTask stopTask;
 92     private TimerTask startTask;
<span class="line-removed"> 93     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed"> 94     private final AccessControlContext dumpDirectoryControlContext;</span>
 95     private boolean shouldWriteActiveRecordingEvent = true;
 96     private Duration flushInterval = Duration.ofSeconds(1);
 97     private long finalStartChunkNanos = Long.MIN_VALUE;
 98     private long startNanos = -1;
 99 
100     @SuppressWarnings(&quot;removal&quot;)
101     PlatformRecording(PlatformRecorder recorder, long id) {
<span class="line-removed">102         // Typically the access control context is taken</span>
<span class="line-removed">103         // when you call dump(Path) or setDestination(Path),</span>
<span class="line-removed">104         // but if no destination is set and the filename is auto-generated,</span>
<span class="line-removed">105         // the control context of the recording is taken when the</span>
<span class="line-removed">106         // Recording object is constructed. This works well for</span>
<span class="line-removed">107         // -XX:StartFlightRecording and JFR.dump</span>
<span class="line-removed">108         this.dumpDirectoryControlContext = AccessController.getContext();</span>
109         this.id = id;
110         this.recorder = recorder;
111         this.name = String.valueOf(id);
112     }
113 
114     public long start() {
115         RecordingState oldState;
116         RecordingState newState;
117         synchronized (recorder) {
118             oldState = getState();
119             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
120                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
121             }
122             if (startTask != null) {
123                 startTask.cancel();
124                 startTask = null;
125                 startTime = null;
126             }
127             startNanos = recorder.start(this);
128             if (Logger.shouldLog(LogTag.JFR, LogLevel.INFO)) {
</pre>
<hr />
<pre>
158         }
159         notifyIfStateChanged(oldState, newState);
160 
161         return startNanos;
162     }
163 
164     public boolean stop(String reason) {
165         RecordingState oldState;
166         RecordingState newState;
167         synchronized (recorder) {
168             oldState = getState();
169             if (stopTask != null) {
170                 stopTask.cancel();
171                 stopTask = null;
172             }
173             recorder.stop(this);
174             String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
175             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
176             newState = getState();
177         }
<span class="line-modified">178         WriteableUserPath dest = getDestination();</span>
179         if (dest == null &amp;&amp; dumpDirectory != null) {
180             dest = makeDumpPath();
181         }
182         if (dest != null) {
183             try {
184                 dumpStopped(dest);
185                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getRealPathText());
186                 notifyIfStateChanged(newState, oldState);
187                 close(); // remove if copied out
188             } catch(IOException e) {
189                 Logger.log(LogTag.JFR, LogLevel.ERROR,
190                            &quot;Unable to complete I/O operation when dumping recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
191             }
192         } else {
193             notifyIfStateChanged(newState, oldState);
194         }
195         return true;
196     }
197 
<span class="line-modified">198     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">199     public WriteableUserPath makeDumpPath() {</span>
200         try {
201             String name = JVMSupport.makeFilename(getRecording());
<span class="line-modified">202             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;WriteableUserPath&gt;() {</span>
<span class="line-modified">203                 @Override</span>
<span class="line-modified">204                 public WriteableUserPath run() throws Exception {</span>
<span class="line-removed">205                     SafePath p = dumpDirectory;</span>
<span class="line-removed">206                     if (p == null) {</span>
<span class="line-removed">207                         p = new SafePath(&quot;.&quot;);</span>
<span class="line-removed">208                     }</span>
<span class="line-removed">209                     return new WriteableUserPath(p.toPath().resolve(name));</span>
<span class="line-removed">210                 }</span>
<span class="line-removed">211             }, dumpDirectoryControlContext);</span>
<span class="line-removed">212         } catch (PrivilegedActionException e) {</span>
<span class="line-removed">213             Throwable t = e.getCause();</span>
<span class="line-removed">214             if (t instanceof SecurityException) {</span>
<span class="line-removed">215                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Not allowed to create dump path for recording &quot; + recording.getId() + &quot; on exit.&quot;);</span>
<span class="line-removed">216             }</span>
<span class="line-removed">217             if (t instanceof IOException) {</span>
<span class="line-removed">218                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not dump &quot; + recording.getId() + &quot; on exit.&quot;);</span>
219             }
<span class="line-modified">220             return null;</span>


221         }

222     }
223 
224 
225     public void scheduleStart(Duration delay) {
226         synchronized (recorder) {
227             ensureOkForSchedule();
228 
229             startTime = Instant.now().plus(delay);
230             LocalDateTime now = LocalDateTime.now().plus(delay);
231             setState(RecordingState.DELAYED);
232             startTask = createStartTask();
233             try {
234                 recorder.getTimer().schedule(startTask, delay.toMillis());
235                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Scheduled recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to start at &quot; + now);
236             } catch (IllegalStateException ise) {
237                 // This can happen in the unlikely case that a recording
238                 // is scheduled after the Timer has been cancelled in
239                 // the shutdown hook. Just ignore.
240             }
241         }
</pre>
<hr />
<pre>
405         }
406         return clone;
407     }
408 
409     public boolean isToDisk() {
410         synchronized (recorder) {
411             return toDisk;
412         }
413     }
414 
415     public void setMaxSize(long maxSize) {
416         synchronized (recorder) {
417             if (getState() == RecordingState.CLOSED) {
418                 throw new IllegalStateException(&quot;Can&#39;t set max size when recording is closed&quot;);
419             }
420             this.maxSize = maxSize;
421             trimToSize();
422         }
423     }
424 
<span class="line-modified">425     public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>
426         synchronized (recorder) {
<span class="line-modified">427             checkSetDestination(userSuppliedPath);</span>
<span class="line-modified">428             this.destination = userSuppliedPath;</span>
429         }
430     }
431 
<span class="line-modified">432     public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>


433         synchronized (recorder) {
434             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
435                 throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
436             }
437         }
438     }
439 
<span class="line-modified">440     public WriteableUserPath getDestination() {</span>
441         synchronized (recorder) {
442             return destination;
443         }
444     }
445 
446     void setState(RecordingState state) {
447         synchronized (recorder) {
448             this.state = state;
449         }
450     }
451 
452     void setStartTime(Instant startTime) {
453         synchronized (recorder) {
454             this.startTime = startTime;
455         }
456     }
457 
458     void setStopTime(Instant timeStamp) {
459         synchronized (recorder) {
460             stopTime = timeStamp;
</pre>
<hr />
<pre>
690         if (stopTask != null) {
691             stopTask.cancel();
692             stopTask = null;
693         }
694         if (getState() == RecordingState.CLOSED) {
695             return;
696         }
697         if (duration != null) {
698             stopTask = createStopTask();
699             recorder.getTimer().schedule(stopTask, new Date(startTime.plus(duration).toEpochMilli()));
700         }
701     }
702 
703     TimerTask createStopTask() {
704         return new TimerTask() {
705             @Override
706             public void run() {
707                 try {
708                     stop(&quot;End of duration reached&quot;);
709                 } catch (Throwable t) {
<span class="line-modified">710                     // Prevent malicious user to propagate exception callback in the wrong context</span>
<span class="line-removed">711                     Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not stop recording.&quot;);</span>
712                 }
713             }
714         };
715     }
716 
717     public Recording newCopy(boolean stop) {
718         return recorder.newCopy(this, stop);
719     }
720 
721     void setStopTask(TimerTask stopTask) {
722         synchronized (recorder) {
723             this.stopTask = stopTask;
724         }
725     }
726 
727     void clearDestination() {
728         destination = null;
729     }
730 
731     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
732         this.shouldWriteActiveRecordingEvent = shouldWrite;
733     }
734 
735     boolean shouldWriteMetadataEvent() {
736         return shouldWriteActiveRecordingEvent;
737     }
738 
739     // Dump running and stopped recordings
<span class="line-modified">740     public void dump(WriteableUserPath writeableUserPath) throws IOException {</span>
741         synchronized (recorder) {
742             try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
<span class="line-modified">743                 p.dumpStopped(writeableUserPath);</span>
744             }
745         }
746     }
747 
<span class="line-modified">748     public void dumpStopped(WriteableUserPath userPath) throws IOException {</span>
749         synchronized (recorder) {
<span class="line-modified">750             transferChunksWithRetry(userPath);</span>
751         }
752     }
753 
<span class="line-modified">754     private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {</span>
<span class="line-modified">755         userPath.doPrivilegedIO(() -&gt; {</span>
<span class="line-modified">756             try {</span>
<span class="line-modified">757                 transferChunks(userPath);</span>
<span class="line-modified">758             } catch (NoSuchFileException nsfe) {</span>
<span class="line-modified">759                 Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Missing chunkfile when writing recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) to &quot; + userPath.getRealPathText() + &quot;.&quot;);</span>
<span class="line-modified">760                 // if one chunkfile was missing, its likely more are missing</span>
<span class="line-modified">761                 removeNonExistantPaths();</span>
<span class="line-modified">762                 // and try the transfer again</span>
<span class="line-modified">763                 transferChunks(userPath);</span>
<span class="line-removed">764             }</span>
<span class="line-removed">765             return null;</span>
<span class="line-removed">766         });</span>
767     }
768 
<span class="line-modified">769     private void transferChunks(WriteableUserPath userPath) throws IOException {</span>
<span class="line-modified">770         try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {</span>
771             long bytes = cc.transferTo(fc);
772             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Transferred &quot; + bytes + &quot; bytes from the disk repository&quot;);
773             // No need to force if no data was transferred, which avoids IOException when device is /dev/null
774             if (bytes != 0) {
775                 fc.force(true);
776             }
777         }
778     }
779 
780     public void filter(Instant begin, Instant end, Long maxSize) {
781         synchronized (recorder) {
782             List&lt;RepositoryChunk&gt; result = removeAfter(end, removeBefore(begin, new ArrayList&lt;&gt;(chunks)));
783             if (maxSize != null) {
784                 if (begin != null &amp;&amp; end == null) {
785                     result = reduceFromBeginning(maxSize, result);
786                 } else {
787                     result = reduceFromEnd(maxSize, result);
788                 }
789             }
790             long size = 0;
</pre>
<hr />
<pre>
842         }
843         // always keep at least one chunk
844         if (result.isEmpty()) {
845             result.add(input.getFirst());
846         }
847         return result;
848     }
849 
850     private static List&lt;RepositoryChunk&gt; reduceFromEnd(Long maxSize, List&lt;RepositoryChunk&gt; input) {
851         Collections.reverse(input);
852         List&lt;RepositoryChunk&gt; result = reduceFromBeginning(maxSize, input);
853         Collections.reverse(result);
854         return result;
855     }
856 
857     /**
858      * Sets the dump directory.
859      * &lt;p&gt;
860      * Only to be used by DCmdStart.
861      */
<span class="line-modified">862     public void setDumpDirectory(SafePath directory) {</span>
863        this.dumpDirectory = directory;
864     }
865 
866     public void setFlushInterval(Duration interval) {
867         synchronized (recorder) {
868             if (getState() == RecordingState.CLOSED) {
869                 throw new IllegalStateException(&quot;Can&#39;t set stream interval when recording is closed&quot;);
870             }
871             this.flushInterval = interval;
872         }
873     }
874 
875     public Duration getFlushInterval() {
876         synchronized (recorder) {
877             return flushInterval;
878         }
879     }
880 
881     public long getStreamIntervalMillis() {
882         synchronized (recorder) {
</pre>
<hr />
<pre>
896     }
897 
898     public void setFinalStartnanos(long chunkStartNanos) {
899        this.finalStartChunkNanos = chunkStartNanos;
900     }
901 
902     public void removeBefore(Instant timestamp) {
903         synchronized (recorder) {
904             while (!chunks.isEmpty()) {
905                 RepositoryChunk oldestChunk = chunks.peek();
906                 if (!oldestChunk.getEndTime().isBefore(timestamp)) {
907                     return;
908                 }
909                 chunks.removeFirst();
910                 removed(oldestChunk);
911             }
912         }
913 
914     }
915 
<span class="line-modified">916     public void removePath(SafePath path) {</span>
917         synchronized (recorder) {
918             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
919             while (it.hasNext()) {
920                 RepositoryChunk c = it.next();
921                 if (c.getFile().equals(path)) {
922                     it.remove();
923                     removed(c);
924                     return;
925                 }
926             }
927         }
928     }
929 
930     void removeNonExistantPaths() {
931         synchronized (recorder) {
932             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
933             Logger.log(JFR, INFO, &quot;Checking for missing chunkfiles for recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;)&quot;);
934             while (it.hasNext()) {
935                 RepositoryChunk chunk = it.next();
936                 if (chunk.isMissingFile()) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogLevel.ERROR;
 30 import static jdk.jfr.internal.LogLevel.INFO;
 31 import static jdk.jfr.internal.LogLevel.WARN;
 32 import static jdk.jfr.internal.LogTag.JFR;
 33 
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.nio.channels.FileChannel;
 37 import java.nio.file.NoSuchFileException;
<span class="line-added"> 38 import java.nio.file.Path;</span>
 39 import java.nio.file.StandardOpenOption;




 40 import java.time.Duration;
 41 import java.time.Instant;
 42 import java.time.LocalDateTime;
 43 import java.util.ArrayList;
 44 import java.util.Collections;
 45 import java.util.Date;
 46 import java.util.Iterator;
 47 import java.util.LinkedHashMap;
 48 import java.util.LinkedList;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.StringJoiner;
 52 import java.util.TimerTask;
 53 import java.util.TreeMap;
 54 
 55 import jdk.jfr.Configuration;
 56 import jdk.jfr.FlightRecorderListener;
 57 import jdk.jfr.Recording;
 58 import jdk.jfr.RecordingState;

 59 import jdk.jfr.internal.util.Utils;
 60 import jdk.jfr.internal.util.ValueFormatter;
 61 
 62 public final class PlatformRecording implements AutoCloseable {
 63 
 64     private final PlatformRecorder recorder;
 65     private final long id;
 66     // Recording settings
 67     private Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();
 68     private Duration duration;
 69     private Duration maxAge;
 70     private long maxSize;
 71 
<span class="line-modified"> 72     private WriteablePath destination;</span>
 73 
 74     private boolean toDisk = true;
 75     private String name;
 76     private boolean dumpOnExit;
<span class="line-modified"> 77     private Path dumpDirectory;</span>
 78     // Timestamp information
 79     private Instant stopTime;
 80     private Instant startTime;
 81 
 82     // Misc, information
 83     private RecordingState state = RecordingState.NEW;
 84     private long size;
 85     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 86     private volatile Recording recording;
 87     private TimerTask stopTask;
 88     private TimerTask startTask;


 89     private boolean shouldWriteActiveRecordingEvent = true;
 90     private Duration flushInterval = Duration.ofSeconds(1);
 91     private long finalStartChunkNanos = Long.MIN_VALUE;
 92     private long startNanos = -1;
 93 
 94     @SuppressWarnings(&quot;removal&quot;)
 95     PlatformRecording(PlatformRecorder recorder, long id) {







 96         this.id = id;
 97         this.recorder = recorder;
 98         this.name = String.valueOf(id);
 99     }
100 
101     public long start() {
102         RecordingState oldState;
103         RecordingState newState;
104         synchronized (recorder) {
105             oldState = getState();
106             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
107                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
108             }
109             if (startTask != null) {
110                 startTask.cancel();
111                 startTask = null;
112                 startTime = null;
113             }
114             startNanos = recorder.start(this);
115             if (Logger.shouldLog(LogTag.JFR, LogLevel.INFO)) {
</pre>
<hr />
<pre>
145         }
146         notifyIfStateChanged(oldState, newState);
147 
148         return startNanos;
149     }
150 
151     public boolean stop(String reason) {
152         RecordingState oldState;
153         RecordingState newState;
154         synchronized (recorder) {
155             oldState = getState();
156             if (stopTask != null) {
157                 stopTask.cancel();
158                 stopTask = null;
159             }
160             recorder.stop(this);
161             String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
162             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
163             newState = getState();
164         }
<span class="line-modified">165         WriteablePath dest = getDestination();</span>
166         if (dest == null &amp;&amp; dumpDirectory != null) {
167             dest = makeDumpPath();
168         }
169         if (dest != null) {
170             try {
171                 dumpStopped(dest);
172                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getRealPathText());
173                 notifyIfStateChanged(newState, oldState);
174                 close(); // remove if copied out
175             } catch(IOException e) {
176                 Logger.log(LogTag.JFR, LogLevel.ERROR,
177                            &quot;Unable to complete I/O operation when dumping recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
178             }
179         } else {
180             notifyIfStateChanged(newState, oldState);
181         }
182         return true;
183     }
184 
<span class="line-modified">185     public WriteablePath makeDumpPath() {</span>

186         try {
187             String name = JVMSupport.makeFilename(getRecording());
<span class="line-modified">188             Path p = dumpDirectory;</span>
<span class="line-modified">189             if (p == null) {</span>
<span class="line-modified">190                 p = Path.of(&quot;.&quot;);</span>














191             }
<span class="line-modified">192             return new WriteablePath(p.resolve(name));</span>
<span class="line-added">193         } catch (IOException e) {</span>
<span class="line-added">194             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not dump &quot; + recording.getId() + &quot; on exit. &quot; + e.getMessage());</span>
195         }
<span class="line-added">196         return null;</span>
197     }
198 
199 
200     public void scheduleStart(Duration delay) {
201         synchronized (recorder) {
202             ensureOkForSchedule();
203 
204             startTime = Instant.now().plus(delay);
205             LocalDateTime now = LocalDateTime.now().plus(delay);
206             setState(RecordingState.DELAYED);
207             startTask = createStartTask();
208             try {
209                 recorder.getTimer().schedule(startTask, delay.toMillis());
210                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Scheduled recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to start at &quot; + now);
211             } catch (IllegalStateException ise) {
212                 // This can happen in the unlikely case that a recording
213                 // is scheduled after the Timer has been cancelled in
214                 // the shutdown hook. Just ignore.
215             }
216         }
</pre>
<hr />
<pre>
380         }
381         return clone;
382     }
383 
384     public boolean isToDisk() {
385         synchronized (recorder) {
386             return toDisk;
387         }
388     }
389 
390     public void setMaxSize(long maxSize) {
391         synchronized (recorder) {
392             if (getState() == RecordingState.CLOSED) {
393                 throw new IllegalStateException(&quot;Can&#39;t set max size when recording is closed&quot;);
394             }
395             this.maxSize = maxSize;
396             trimToSize();
397         }
398     }
399 
<span class="line-modified">400     public void setDestination(WriteablePath destination) throws IOException {</span>
401         synchronized (recorder) {
<span class="line-modified">402             checkSetDestination(destination);</span>
<span class="line-modified">403             this.destination = destination;</span>
404         }
405     }
406 
<span class="line-modified">407     public void checkSetDestination(WriteablePath writeablePath) throws IOException {</span>
<span class="line-added">408         // The writeablePath argument is not checked. It&#39;s sufficient that an instance has</span>
<span class="line-added">409         // been created.</span>
410         synchronized (recorder) {
411             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
412                 throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
413             }
414         }
415     }
416 
<span class="line-modified">417     public WriteablePath getDestination() {</span>
418         synchronized (recorder) {
419             return destination;
420         }
421     }
422 
423     void setState(RecordingState state) {
424         synchronized (recorder) {
425             this.state = state;
426         }
427     }
428 
429     void setStartTime(Instant startTime) {
430         synchronized (recorder) {
431             this.startTime = startTime;
432         }
433     }
434 
435     void setStopTime(Instant timeStamp) {
436         synchronized (recorder) {
437             stopTime = timeStamp;
</pre>
<hr />
<pre>
667         if (stopTask != null) {
668             stopTask.cancel();
669             stopTask = null;
670         }
671         if (getState() == RecordingState.CLOSED) {
672             return;
673         }
674         if (duration != null) {
675             stopTask = createStopTask();
676             recorder.getTimer().schedule(stopTask, new Date(startTime.plus(duration).toEpochMilli()));
677         }
678     }
679 
680     TimerTask createStopTask() {
681         return new TimerTask() {
682             @Override
683             public void run() {
684                 try {
685                     stop(&quot;End of duration reached&quot;);
686                 } catch (Throwable t) {
<span class="line-modified">687                     Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not stop recording. &quot; + t.getMessage());</span>

688                 }
689             }
690         };
691     }
692 
693     public Recording newCopy(boolean stop) {
694         return recorder.newCopy(this, stop);
695     }
696 
697     void setStopTask(TimerTask stopTask) {
698         synchronized (recorder) {
699             this.stopTask = stopTask;
700         }
701     }
702 
703     void clearDestination() {
704         destination = null;
705     }
706 
707     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
708         this.shouldWriteActiveRecordingEvent = shouldWrite;
709     }
710 
711     boolean shouldWriteMetadataEvent() {
712         return shouldWriteActiveRecordingEvent;
713     }
714 
715     // Dump running and stopped recordings
<span class="line-modified">716     public void dump(WriteablePath writeablePath) throws IOException {</span>
717         synchronized (recorder) {
718             try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
<span class="line-modified">719                 p.dumpStopped(writeablePath);</span>
720             }
721         }
722     }
723 
<span class="line-modified">724     public void dumpStopped(WriteablePath path) throws IOException {</span>
725         synchronized (recorder) {
<span class="line-modified">726             transferChunksWithRetry(path);</span>
727         }
728     }
729 
<span class="line-modified">730     private void transferChunksWithRetry(WriteablePath path) throws IOException {</span>
<span class="line-modified">731         try {</span>
<span class="line-modified">732             transferChunks(path);</span>
<span class="line-modified">733         } catch (NoSuchFileException nsfe) {</span>
<span class="line-modified">734             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Missing chunkfile when writing recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) to &quot; + path.getRealPathText() + &quot;.&quot;);</span>
<span class="line-modified">735             // if one chunkfile was missing, its likely more are missing</span>
<span class="line-modified">736             removeNonExistantPaths();</span>
<span class="line-modified">737             // and try the transfer again</span>
<span class="line-modified">738             transferChunks(path);</span>
<span class="line-modified">739         }</span>



740     }
741 
<span class="line-modified">742     private void transferChunks(WriteablePath path) throws IOException {</span>
<span class="line-modified">743         try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {</span>
744             long bytes = cc.transferTo(fc);
745             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Transferred &quot; + bytes + &quot; bytes from the disk repository&quot;);
746             // No need to force if no data was transferred, which avoids IOException when device is /dev/null
747             if (bytes != 0) {
748                 fc.force(true);
749             }
750         }
751     }
752 
753     public void filter(Instant begin, Instant end, Long maxSize) {
754         synchronized (recorder) {
755             List&lt;RepositoryChunk&gt; result = removeAfter(end, removeBefore(begin, new ArrayList&lt;&gt;(chunks)));
756             if (maxSize != null) {
757                 if (begin != null &amp;&amp; end == null) {
758                     result = reduceFromBeginning(maxSize, result);
759                 } else {
760                     result = reduceFromEnd(maxSize, result);
761                 }
762             }
763             long size = 0;
</pre>
<hr />
<pre>
815         }
816         // always keep at least one chunk
817         if (result.isEmpty()) {
818             result.add(input.getFirst());
819         }
820         return result;
821     }
822 
823     private static List&lt;RepositoryChunk&gt; reduceFromEnd(Long maxSize, List&lt;RepositoryChunk&gt; input) {
824         Collections.reverse(input);
825         List&lt;RepositoryChunk&gt; result = reduceFromBeginning(maxSize, input);
826         Collections.reverse(result);
827         return result;
828     }
829 
830     /**
831      * Sets the dump directory.
832      * &lt;p&gt;
833      * Only to be used by DCmdStart.
834      */
<span class="line-modified">835     public void setDumpDirectory(Path directory) {</span>
836        this.dumpDirectory = directory;
837     }
838 
839     public void setFlushInterval(Duration interval) {
840         synchronized (recorder) {
841             if (getState() == RecordingState.CLOSED) {
842                 throw new IllegalStateException(&quot;Can&#39;t set stream interval when recording is closed&quot;);
843             }
844             this.flushInterval = interval;
845         }
846     }
847 
848     public Duration getFlushInterval() {
849         synchronized (recorder) {
850             return flushInterval;
851         }
852     }
853 
854     public long getStreamIntervalMillis() {
855         synchronized (recorder) {
</pre>
<hr />
<pre>
869     }
870 
871     public void setFinalStartnanos(long chunkStartNanos) {
872        this.finalStartChunkNanos = chunkStartNanos;
873     }
874 
875     public void removeBefore(Instant timestamp) {
876         synchronized (recorder) {
877             while (!chunks.isEmpty()) {
878                 RepositoryChunk oldestChunk = chunks.peek();
879                 if (!oldestChunk.getEndTime().isBefore(timestamp)) {
880                     return;
881                 }
882                 chunks.removeFirst();
883                 removed(oldestChunk);
884             }
885         }
886 
887     }
888 
<span class="line-modified">889     public void removePath(Path path) {</span>
890         synchronized (recorder) {
891             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
892             while (it.hasNext()) {
893                 RepositoryChunk c = it.next();
894                 if (c.getFile().equals(path)) {
895                     it.remove();
896                     removed(c);
897                     return;
898                 }
899             }
900         }
901     }
902 
903     void removeNonExistantPaths() {
904         synchronized (recorder) {
905             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
906             Logger.log(JFR, INFO, &quot;Checking for missing chunkfiles for recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;)&quot;);
907             while (it.hasNext()) {
908                 RepositoryChunk chunk = it.next();
909                 if (chunk.isMissingFile()) {
</pre>
</td>
</tr>
</table>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>