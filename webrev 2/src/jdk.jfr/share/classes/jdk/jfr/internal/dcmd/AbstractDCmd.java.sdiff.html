<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../consumer/filter/ChunkWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.time.Duration;
 33 import java.util.ArrayList;
 34 import java.util.Comparator;
 35 import java.util.List;
 36 
 37 import jdk.jfr.FlightRecorder;
 38 import jdk.jfr.Recording;
 39 import jdk.jfr.internal.JVM;
 40 import jdk.jfr.internal.util.Output.LinePrinter;
 41 import jdk.jfr.internal.util.Output;
 42 import jdk.jfr.internal.JVMSupport;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;
<span class="line-removed"> 46 import jdk.jfr.internal.SecuritySupport;</span>
<span class="line-removed"> 47 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 48 import jdk.jfr.internal.util.ValueFormatter;
 49 
 50 /**
 51  * Base class for JFR diagnostic commands
 52  *
 53  */
 54 abstract class AbstractDCmd {
 55     private final LinePrinter output = new LinePrinter();
 56     private String source;
 57 
 58     // Called by native
 59     public abstract String[] getHelp();
 60 
 61     // Called by native. The number of arguments for each command is
 62     // reported to the DCmdFramework as a hardcoded number in native.
 63     // This is to avoid an upcall as part of DcmdFramework enumerating existing commands.
 64     // Remember to keep the two sides in synch.
 65     public abstract Argument[] getArgumentInfos();
 66 
 67     protected abstract void execute(ArgumentParser parser) throws DCmdException;
</pre>
<hr />
<pre>
117     protected final String[] getResult() {
118         return output.getLines().toArray(new String[0]);
119     }
120 
121     protected void logWarning(String message) {
122         if (source.equals(&quot;internal&quot;)) { // -XX:StartFlightRecording
123             Logger.log(LogTag.JFR_START, LogLevel.WARN, message);
124         } else { // DiagnosticMXBean or JCMD
125             println(&quot;Warning! &quot; + message);
126         }
127     }
128 
129     public String getPid() {
130         // Invoking ProcessHandle.current().pid() would require loading more
131         // classes during startup so instead JVM.getPid() is used.
132         // The pid will not be exposed to running Java application, only when starting
133         // JFR from command line (-XX:StartFlightRecording) or jcmd (JFR.start and JFR.check)
134         return JVM.getPid();
135     }
136 
<span class="line-modified">137     protected final SafePath resolvePath(Recording recording, String filename) throws InvalidPathException {</span>
138         if (filename == null) {
139             return makeGenerated(recording, Paths.get(&quot;.&quot;));
140         }
141         Path path = Paths.get(filename);
142         if (Files.isDirectory(path)) {
143             return makeGenerated(recording, path);
144         }
<span class="line-modified">145         return new SafePath(path.toAbsolutePath().normalize());</span>
146     }
147 
<span class="line-modified">148     private SafePath makeGenerated(Recording recording, Path directory) {</span>
<span class="line-modified">149         return new SafePath(directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize());</span>
150     }
151 
152     protected final Recording findRecording(String name) throws DCmdException {
153         try {
154             return findRecordingById(Integer.parseInt(name));
155         } catch (NumberFormatException nfe) {
156             // User specified a name, not an id.
157             return findRecordingByName(name);
158         }
159     }
160 
<span class="line-modified">161     protected final void reportOperationComplete(String actionPrefix, String name, SafePath file) {</span>
162         print(actionPrefix);
163         print(&quot; recording&quot;);
164         if (name != null) {
165             print(&quot; \&quot;&quot; + name + &quot;\&quot;&quot;);
166         }
167         if (file != null) {
168             print(&quot;,&quot;);
169             try {
170                 print(&quot; &quot;);
<span class="line-modified">171                 long bytes = SecuritySupport.getFileSize(file);</span>
172                 printBytes(bytes);
173             } catch (IOException e) {
174                 // Ignore, not essential
175             }
176             println(&quot; written to:&quot;);
177             println();
178             printPath(file);
179         } else {
180             println(&quot;.&quot;);
181         }
182     }
183 
184     protected final List&lt;Recording&gt; getRecordings() {
185         List&lt;Recording&gt; list = new ArrayList&lt;&gt;(getFlightRecorder().getRecordings());
186         list.sort(Comparator.comparingLong(Recording::getId));
187         return list;
188     }
189 
190     static String quoteIfNeeded(String text) {
191         if (text.contains(&quot; &quot;)) {
</pre>
<hr />
<pre>
202     protected final void print(String s) {
203         output.print(s);
204     }
205 
206     protected final void print(String s, Object... args) {
207         output.print(s, args);
208     }
209 
210     protected final void println(String s, Object... args) {
211         output.println(s, args);
212     }
213 
214     protected final void printBytes(long bytes) {
215         print(ValueFormatter.formatBytes(bytes));
216     }
217 
218     protected final void printTimespan(Duration timespan, String separator) {
219         print(ValueFormatter.formatTimespan(timespan, separator));
220     }
221 
<span class="line-modified">222     protected final void printPath(SafePath path) {</span>
223         if (path == null) {
224             print(&quot;N/A&quot;);
225             return;
226         }
<span class="line-modified">227         try {</span>
<span class="line-removed">228             printPath(SecuritySupport.getAbsolutePath(path).toPath());</span>
<span class="line-removed">229         } catch (IOException ioe) {</span>
<span class="line-removed">230             printPath(path.toPath());</span>
<span class="line-removed">231         }</span>
232     }
233 
234     protected final void printHelpText() {
235         for (String line : getHelp()) {
236             println(line);
237         }
238     }
239 
<span class="line-removed">240     protected final void printPath(Path path) {</span>
<span class="line-removed">241         try {</span>
<span class="line-removed">242             println(path.toAbsolutePath().toString());</span>
<span class="line-removed">243         } catch (SecurityException e) {</span>
<span class="line-removed">244             // fall back on filename</span>
<span class="line-removed">245             println(path.toString());</span>
<span class="line-removed">246         }</span>
<span class="line-removed">247     }</span>
<span class="line-removed">248 </span>
249     private Recording findRecordingById(int id) throws DCmdException {
250         for (Recording r : getFlightRecorder().getRecordings()) {
251             if (r.getId() == id) {
252                 return r;
253             }
254         }
255         throw new DCmdException(&quot;Could not find %d.\n\nUse JFR.check without options to see list of all available recordings.&quot;, id);
256     }
257 
258     private Recording findRecordingByName(String name) throws DCmdException {
259         for (Recording recording : getFlightRecorder().getRecordings()) {
260             if (name.equals(recording.getName())) {
261                 return recording;
262             }
263         }
264         throw new DCmdException(&quot;Could not find %s.\n\nUse JFR.check without options to see list of all available recordings.&quot;, name);
265     }
266 
267     protected final String exampleRepository() {
268         if (&quot;\r\n&quot;.equals(System.lineSeparator())) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.time.Duration;
 33 import java.util.ArrayList;
 34 import java.util.Comparator;
 35 import java.util.List;
 36 
 37 import jdk.jfr.FlightRecorder;
 38 import jdk.jfr.Recording;
 39 import jdk.jfr.internal.JVM;
 40 import jdk.jfr.internal.util.Output.LinePrinter;
 41 import jdk.jfr.internal.util.Output;
 42 import jdk.jfr.internal.JVMSupport;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;


 46 import jdk.jfr.internal.util.ValueFormatter;
 47 
 48 /**
 49  * Base class for JFR diagnostic commands
 50  *
 51  */
 52 abstract class AbstractDCmd {
 53     private final LinePrinter output = new LinePrinter();
 54     private String source;
 55 
 56     // Called by native
 57     public abstract String[] getHelp();
 58 
 59     // Called by native. The number of arguments for each command is
 60     // reported to the DCmdFramework as a hardcoded number in native.
 61     // This is to avoid an upcall as part of DcmdFramework enumerating existing commands.
 62     // Remember to keep the two sides in synch.
 63     public abstract Argument[] getArgumentInfos();
 64 
 65     protected abstract void execute(ArgumentParser parser) throws DCmdException;
</pre>
<hr />
<pre>
115     protected final String[] getResult() {
116         return output.getLines().toArray(new String[0]);
117     }
118 
119     protected void logWarning(String message) {
120         if (source.equals(&quot;internal&quot;)) { // -XX:StartFlightRecording
121             Logger.log(LogTag.JFR_START, LogLevel.WARN, message);
122         } else { // DiagnosticMXBean or JCMD
123             println(&quot;Warning! &quot; + message);
124         }
125     }
126 
127     public String getPid() {
128         // Invoking ProcessHandle.current().pid() would require loading more
129         // classes during startup so instead JVM.getPid() is used.
130         // The pid will not be exposed to running Java application, only when starting
131         // JFR from command line (-XX:StartFlightRecording) or jcmd (JFR.start and JFR.check)
132         return JVM.getPid();
133     }
134 
<span class="line-modified">135     protected Path resolvePath(Recording recording, String filename) throws InvalidPathException {</span>
136         if (filename == null) {
137             return makeGenerated(recording, Paths.get(&quot;.&quot;));
138         }
139         Path path = Paths.get(filename);
140         if (Files.isDirectory(path)) {
141             return makeGenerated(recording, path);
142         }
<span class="line-modified">143         return path.toAbsolutePath().normalize();</span>
144     }
145 
<span class="line-modified">146     private Path makeGenerated(Recording recording, Path directory) {</span>
<span class="line-modified">147         return directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize();</span>
148     }
149 
150     protected final Recording findRecording(String name) throws DCmdException {
151         try {
152             return findRecordingById(Integer.parseInt(name));
153         } catch (NumberFormatException nfe) {
154             // User specified a name, not an id.
155             return findRecordingByName(name);
156         }
157     }
158 
<span class="line-modified">159     protected final void reportOperationComplete(String actionPrefix, String name, Path file) {</span>
160         print(actionPrefix);
161         print(&quot; recording&quot;);
162         if (name != null) {
163             print(&quot; \&quot;&quot; + name + &quot;\&quot;&quot;);
164         }
165         if (file != null) {
166             print(&quot;,&quot;);
167             try {
168                 print(&quot; &quot;);
<span class="line-modified">169                 long bytes = Files.size(file);</span>
170                 printBytes(bytes);
171             } catch (IOException e) {
172                 // Ignore, not essential
173             }
174             println(&quot; written to:&quot;);
175             println();
176             printPath(file);
177         } else {
178             println(&quot;.&quot;);
179         }
180     }
181 
182     protected final List&lt;Recording&gt; getRecordings() {
183         List&lt;Recording&gt; list = new ArrayList&lt;&gt;(getFlightRecorder().getRecordings());
184         list.sort(Comparator.comparingLong(Recording::getId));
185         return list;
186     }
187 
188     static String quoteIfNeeded(String text) {
189         if (text.contains(&quot; &quot;)) {
</pre>
<hr />
<pre>
200     protected final void print(String s) {
201         output.print(s);
202     }
203 
204     protected final void print(String s, Object... args) {
205         output.print(s, args);
206     }
207 
208     protected final void println(String s, Object... args) {
209         output.println(s, args);
210     }
211 
212     protected final void printBytes(long bytes) {
213         print(ValueFormatter.formatBytes(bytes));
214     }
215 
216     protected final void printTimespan(Duration timespan, String separator) {
217         print(ValueFormatter.formatTimespan(timespan, separator));
218     }
219 
<span class="line-modified">220     protected final void printPath(Path path) {</span>
221         if (path == null) {
222             print(&quot;N/A&quot;);
223             return;
224         }
<span class="line-modified">225         println(path.toAbsolutePath().toString());</span>




226     }
227 
228     protected final void printHelpText() {
229         for (String line : getHelp()) {
230             println(line);
231         }
232     }
233 









234     private Recording findRecordingById(int id) throws DCmdException {
235         for (Recording r : getFlightRecorder().getRecordings()) {
236             if (r.getId() == id) {
237                 return r;
238             }
239         }
240         throw new DCmdException(&quot;Could not find %d.\n\nUse JFR.check without options to see list of all available recordings.&quot;, id);
241     }
242 
243     private Recording findRecordingByName(String name) throws DCmdException {
244         for (Recording recording : getFlightRecorder().getRecordings()) {
245             if (name.equals(recording.getName())) {
246                 return recording;
247             }
248         }
249         throw new DCmdException(&quot;Could not find %s.\n\nUse JFR.check without options to see list of all available recordings.&quot;, name);
250     }
251 
252     protected final String exampleRepository() {
253         if (&quot;\r\n&quot;.equals(System.lineSeparator())) {
</pre>
</td>
</tr>
</table>
<center><a href="../consumer/filter/ChunkWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>