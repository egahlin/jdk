diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,35 +25,21 @@
 
 package jdk.jfr.internal.event;
 
 import jdk.internal.misc.Unsafe;
 import jdk.jfr.internal.Bits;
-import jdk.jfr.internal.EventWriterKey;
 import jdk.jfr.internal.StringPool;
 import jdk.jfr.internal.JVM;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.consumer.StringParser;
 
 // User code should not be able to get access to an EventWriter instance as it
 // would allow it to write arbitrary data into buffers, potentially from
 // different threads.
 //
-// This is prevented in three ways:
-//
-// 1. For code to access the jdk.jfr.internal.event package
-//    at least one event class (for a particular module) must be
-//    registered having FlightRecorderPermission("registerEvent").
-//
-// 2. The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from
-//    the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.
-//    (The EventWriterFactory class is dynamically generated before the first event
-//    is instrumented. See EventWriterFactoryRecipe)
-//
-// 3. Steps 1 and 2 are sufficient to make it fully secure, with or without a Security
-//    Manager, but as an additional measure, the method EventWriterFactory::getEventWriter(long)
-//    requires the caller to provide a key that is hard to guess. The key is generated
-//    into the bytecode of the method invoking getEventWriter(long).
+// The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from
+// the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.
 //
 public final class EventWriter {
 
     // Event may not exceed size for a padded integer
     private static final long MAX_EVENT_SIZE = (1 << 28) -1;
@@ -69,10 +55,18 @@
     boolean excluded;
 
     private PlatformEventType eventType;
     private boolean largeSize = false;
 
+    public static EventWriter getEventWriter() {
+        EventWriter ew = JVM.getEventWriter();
+        if (ew != null) {
+            return ew;
+        }
+        return JVM.newEventWriter();
+    }
+
     // User code must not be able to instantiate
     private EventWriter() {
         threadID = 0;
     }
 
@@ -237,15 +231,13 @@
     private void flush(int usedSize, int requestedSize) {
         JVM.flush(this, usedSize, requestedSize);
     }
 
     public boolean beginEvent(EventConfiguration configuration, long typeId) {
-        // Malicious code could take the EventConfiguration object from one
-        // event class field and assign it to another. This check makes sure
-        // the event type matches what was added by instrumentation.
+        // This check makes sure the event type matches what was added by instrumentation.
         if (configuration.getId() != typeId) {
-            EventWriterKey.block();
+            throw new InternalError("Unexpected type id " + typeId);
         }
         if (excluded) {
             // thread is excluded from writing events
             return false;
         }
