<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.tool;
 27 
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.IOError;
 31 import java.io.IOException;
 32 import java.io.PrintStream;
 33 import java.io.RandomAccessFile;
 34 import java.nio.file.Files;
 35 import java.nio.file.InvalidPathException;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.util.ArrayList;
 39 import java.util.Collections;
 40 import java.util.Deque;
 41 import java.util.List;
 42 
 43 import jdk.jfr.internal.util.UserDataException;
 44 import jdk.jfr.internal.util.UserSyntaxException;
 45 
 46 abstract class Command {
 47     public static final String title = &quot;Tool for working with Flight Recorder files&quot;;
 48     private static final Command HELP = new Help();
 49     private static final List&lt;Command&gt; COMMANDS = createCommands();
 50 
 51     private static List&lt;Command&gt; createCommands() {
 52         List&lt;Command&gt; commands = new ArrayList&lt;&gt;();
 53         commands.add(new Print());
 54         // Uncomment when developing new queries for the view command
<a name="2" id="anc2"></a><span class="line-modified"> 55         // commands.add(new Query());</span>
 56         commands.add(new View());
 57         commands.add(new Configure());
 58         commands.add(new Metadata());
 59         commands.add(new Scrub());
 60         commands.add(new Summary());
 61         commands.add(new Assemble());
 62         commands.add(new Disassemble());
 63         commands.add(new Version());
 64         commands.add(HELP);
 65         return Collections.unmodifiableList(commands);
 66     }
 67 
 68     static void displayHelp() {
 69         System.out.println(title);
 70         System.out.println();
 71         displayAvailableCommands(System.out);
 72     }
 73 
 74     public abstract String getName();
 75 
 76     public abstract String getDescription();
 77 
 78     public abstract void execute(Deque&lt;String&gt; argList) throws UserSyntaxException, UserDataException;
 79 
 80     protected String getTitle() {
 81         return getDescription();
 82     }
 83 
 84     static void displayAvailableCommands(PrintStream stream) {
 85         boolean first = true;
 86         for (Command c : Command.COMMANDS) {
 87             if (!first) {
 88                 System.out.println();
 89             }
 90             displayCommand(stream, c);
 91             stream.println(&quot;     &quot; + c.getDescription());
 92             first = false;
 93         }
 94     }
 95 
 96     protected static void displayCommand(PrintStream stream, Command c) {
 97         boolean firstSyntax = true;
 98         String alias = buildAlias(c);
 99         String initial = &quot; jfr &quot; + c.getName();
100         for (String syntaxLine : c.getOptionSyntax()) {
101             if (firstSyntax) {
102                 if (syntaxLine.length() != 0) {
103                    stream.println(initial + &quot; &quot; + syntaxLine + alias);
104                 } else {
105                    stream.println(initial + alias);
106                 }
107             } else {
108                 for (int i = 0; i &lt; initial.length(); i++) {
109                     stream.print(&quot; &quot;);
110                 }
111                 stream.println(&quot; &quot; + syntaxLine);
112             }
113             firstSyntax = false;
114         }
115     }
116 
117     private static String buildAlias(Command c) {
118         List&lt;String&gt; aliases = c.getAliases();
119         if (aliases.isEmpty()) {
120             return &quot;&quot;;
121         }
122         StringBuilder sb = new StringBuilder();
123         if (aliases.size() == 1) {
124             sb.append(&quot; (alias &quot;);
125             sb.append(aliases.getFirst());
126             sb.append(&quot;)&quot;);
127             return sb.toString();
128          }
129          sb.append(&quot; (aliases &quot;);
130          for (int i = 0; i&lt; aliases.size(); i ++ ) {
131              sb.append(aliases.get(i));
132              if (i &lt; aliases.size() -1) {
133                  sb.append(&quot;, &quot;);
134              }
135          }
136          sb.append(&quot;)&quot;);
137          return sb.toString();
138     }
139 
140     public static List&lt;Command&gt; getCommands() {
141         return COMMANDS;
142     }
143 
144     public static Command valueOf(String commandName) {
145         for (Command command : COMMANDS) {
146             if (command.getName().equals(commandName)) {
147                 return command;
148             }
149         }
150         return null;
151     }
152 
153     public List&lt;String&gt; getOptionSyntax() {
154         return Collections.singletonList(&quot;&quot;);
155     }
156 
157     public void displayOptionUsage(PrintStream stream) {
158     }
159 
160     protected boolean acceptSwitch(Deque&lt;String&gt; options, String expected) throws UserSyntaxException {
161         if (!options.isEmpty() &amp;&amp; options.peek().equals(expected)) {
162             options.remove();
163             return true;
164         }
165         return false;
166     }
167 
168     protected boolean acceptOption(Deque&lt;String&gt; options, String expected) throws UserSyntaxException {
169         if (expected.equals(options.peek())) {
170             if (options.size() &lt; 2) {
171                 throw new UserSyntaxException(&quot;missing value for &quot; + options.peek());
172             }
173             options.remove();
174             return true;
175         }
176         return false;
177     }
178 
179     protected int acceptInt(Deque&lt;String&gt; options, String text) throws UserSyntaxException {
180         if (options.size() &lt; 1) {
181             throw new UserSyntaxException(&quot;missing integer value&quot;);
182         }
183         String t = options.remove();
184         try {
185             return Integer.parseInt(t);
186         } catch (NumberFormatException nfe) {
187             throw new UserSyntaxException(&quot;could not parse integer value &quot; + t);
188         }
189     }
190 
191     protected void warnForWildcardExpansion(String option, String filter) throws UserDataException {
192         // Users should quote their wildcards to avoid expansion by the shell
193         try {
194             if (!filter.contains(File.pathSeparator)) {
195                 Path p = Path.of(&quot;.&quot;, filter);
196                 if (!Files.exists(p)) {
197                     return;
198                 }
199             }
200             throw new UserDataException(&quot;wildcards should be quoted, for example &quot; + option + &quot; \&quot;Foo*\&quot;&quot;);
201         } catch (InvalidPathException ipe) {
202             // ignore
203         }
204     }
205 
206     protected boolean acceptFilterOption(Deque&lt;String&gt; options, String expected) throws UserSyntaxException {
207         if (!acceptOption(options, expected)) {
208             return false;
209         }
210         if (options.isEmpty()) {
211             throw new UserSyntaxException(&quot;missing filter after &quot; + expected);
212         }
213         String filter = options.peek();
214         if (filter.startsWith(&quot;--&quot;)) {
215             throw new UserSyntaxException(&quot;missing filter after &quot; + expected);
216         }
217         return true;
218     }
219 
220     protected final void ensureMaxArgumentCount(Deque&lt;String&gt; options, int maxCount) throws UserSyntaxException {
221         if (options.size() &gt; maxCount) {
222             throw new UserSyntaxException(&quot;too many arguments&quot;);
223         }
224     }
225 
226     protected final void ensureMinArgumentCount(Deque&lt;String&gt; options, int minCount) throws UserSyntaxException {
227         if (options.size() &lt; minCount) {
228             throw new UserSyntaxException(&quot;too few arguments&quot;);
229         }
230     }
231 
232     protected final Path getDirectory(String pathText) throws UserDataException {
233         try {
234             Path path = Paths.get(pathText).toAbsolutePath();
235             if (!Files.exists((path))) {
236                 throw new UserDataException(&quot;directory does not exist, &quot; + pathText);
237             }
238             if (!Files.isDirectory(path)) {
239                 throw new UserDataException(&quot;path must be directory, &quot; + pathText);
240             }
241             return path;
242         } catch (InvalidPathException ipe) {
243             throw new UserDataException(&quot;invalid path &#39;&quot; + pathText + &quot;&#39;&quot;);
244         }
245     }
246 
247     protected final Path getJFRInputFile(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
248         if (options.isEmpty()) {
249             throw new UserSyntaxException(&quot;missing file&quot;);
250         }
251         String file = options.removeLast();
252         if (file.startsWith(&quot;--&quot;)) {
253             throw new UserSyntaxException(&quot;missing file&quot;);
254         }
255         try {
256             Path path = Paths.get(file).toAbsolutePath();
257             ensureAccess(path);
258             ensureFileExtension(path, &quot;.jfr&quot;);
259             return path;
260         } catch (IOError ioe) {
261             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + file + &quot;&#39;, &quot; + ioe.getMessage());
262         } catch (InvalidPathException ipe) {
263             throw new UserDataException(&quot;invalid path &#39;&quot; + file + &quot;&#39;&quot;);
264         }
265     }
266 
267     protected final void ensureAccess(Path path) throws UserDataException {
268         try (RandomAccessFile rad = new RandomAccessFile(path.toFile(), &quot;r&quot;)) {
269             if (rad.length() == 0) {
270                 throw new UserDataException(&quot;file is empty &#39;&quot; + path + &quot;&#39;&quot;);
271             }
272             rad.read(); // try to read 1 byte
273         } catch (FileNotFoundException e) {
274             throw new UserDataException(&quot;could not open file &quot; + e.getMessage());
275         } catch (IOException e) {
276             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + path + &quot;&#39;, &quot; + e.getMessage());
277         }
278     }
279 
280     protected final void couldNotReadError(Path p, IOException e) throws UserDataException {
281         throw new UserDataException(&quot;could not read recording at &quot; + p.toAbsolutePath() + &quot;. &quot; + e.getMessage());
282     }
283 
284     protected final Path ensureFileDoesNotExist(Path file) throws UserDataException {
285         if (Files.exists(file)) {
286             throw new UserDataException(&quot;file &#39;&quot; + file + &quot;&#39; already exists&quot;);
287         }
288         return file;
289     }
290 
291     protected final void ensureFileExtension(Path path, String extension) throws UserDataException {
292         if (!path.toString().endsWith(extension)) {
293             throw new UserDataException(&quot;filename must end with &#39;&quot; + extension + &quot;&#39;&quot;);
294         }
295     }
296 
297     protected void displayUsage(PrintStream stream) {
298         displayCommand(stream, this);
299         stream.println();
300         displayOptionUsage(stream);
301     }
302 
303     protected static char quoteCharacter() {
304         return File.pathSeparatorChar == &#39;;&#39; ? &#39;&quot;&#39; : &#39;\&#39;&#39;;
305     }
306 
307     protected final void println() {
308         System.out.println();
309     }
310 
311     protected final void print(String text) {
312         System.out.print(text);
313     }
314 
315     protected final void println(String text) {
316         System.out.println(text);
317     }
318 
319     public static void checkCommonError(Deque&lt;String&gt; options, String typo, String correct) throws UserSyntaxException {
320         if (typo.equals(options.peek())) {
321             throw new UserSyntaxException(&quot;unknown option &quot; + typo + &quot;, did you mean &quot; + correct + &quot;?&quot;);
322         }
323     }
324 
325     protected final boolean matches(String command) {
326         for (String s : getNames()) {
327             if (s.equals(command)) {
328                 return true;
329             }
330         }
331         return false;
332     }
333 
334     protected List&lt;String&gt; getAliases() {
335         return Collections.emptyList();
336     }
337 
338     public List&lt;String&gt; getNames() {
339         List&lt;String&gt; names = new ArrayList&lt;&gt;();
340         names.add(getName());
341         names.addAll(getAliases());
342         return names;
343     }
344 
345 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>