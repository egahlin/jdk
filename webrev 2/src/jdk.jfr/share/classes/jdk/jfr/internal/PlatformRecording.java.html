<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogLevel.ERROR;
 30 import static jdk.jfr.internal.LogLevel.INFO;
 31 import static jdk.jfr.internal.LogLevel.WARN;
 32 import static jdk.jfr.internal.LogTag.JFR;
 33 
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.nio.channels.FileChannel;
 37 import java.nio.file.NoSuchFileException;
 38 import java.nio.file.Path;
 39 import java.nio.file.StandardOpenOption;
 40 import java.time.Duration;
 41 import java.time.Instant;
 42 import java.time.LocalDateTime;
 43 import java.util.ArrayList;
 44 import java.util.Collections;
 45 import java.util.Date;
 46 import java.util.Iterator;
 47 import java.util.LinkedHashMap;
 48 import java.util.LinkedList;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.StringJoiner;
 52 import java.util.TimerTask;
 53 import java.util.TreeMap;
 54 
 55 import jdk.jfr.Configuration;
 56 import jdk.jfr.FlightRecorderListener;
 57 import jdk.jfr.Recording;
 58 import jdk.jfr.RecordingState;
 59 import jdk.jfr.internal.util.Utils;
 60 import jdk.jfr.internal.util.ValueFormatter;
 61 
 62 public final class PlatformRecording implements AutoCloseable {
 63 
 64     private final PlatformRecorder recorder;
 65     private final long id;
 66     // Recording settings
 67     private Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();
 68     private Duration duration;
 69     private Duration maxAge;
 70     private long maxSize;
 71 
 72     private WriteablePath destination;
 73 
 74     private boolean toDisk = true;
 75     private String name;
 76     private boolean dumpOnExit;
 77     private Path dumpDirectory;
 78     // Timestamp information
 79     private Instant stopTime;
 80     private Instant startTime;
 81 
 82     // Misc, information
 83     private RecordingState state = RecordingState.NEW;
 84     private long size;
 85     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 86     private volatile Recording recording;
 87     private TimerTask stopTask;
 88     private TimerTask startTask;
 89     private boolean shouldWriteActiveRecordingEvent = true;
 90     private Duration flushInterval = Duration.ofSeconds(1);
 91     private long finalStartChunkNanos = Long.MIN_VALUE;
 92     private long startNanos = -1;
 93 
 94     @SuppressWarnings(&quot;removal&quot;)
 95     PlatformRecording(PlatformRecorder recorder, long id) {
 96         this.id = id;
 97         this.recorder = recorder;
 98         this.name = String.valueOf(id);
 99     }
100 
101     public long start() {
102         RecordingState oldState;
103         RecordingState newState;
104         synchronized (recorder) {
105             oldState = getState();
106             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
107                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
108             }
109             if (startTask != null) {
110                 startTask.cancel();
111                 startTask = null;
112                 startTime = null;
113             }
114             startNanos = recorder.start(this);
115             if (Logger.shouldLog(LogTag.JFR, LogLevel.INFO)) {
116                 // Only print non-default values so it easy to see
117                 // which options were added
118                 StringJoiner options = new StringJoiner(&quot;, &quot;);
119                 if (!toDisk) {
120                     options.add(&quot;disk=false&quot;);
121                 }
122                 if (maxAge != null) {
123                     options.add(&quot;maxage=&quot; + ValueFormatter.formatTimespan(maxAge, &quot;&quot;));
124                 }
125                 if (maxSize != 0) {
126                     options.add(&quot;maxsize=&quot; + ValueFormatter.formatBytesCompact(maxSize));
127                 }
128                 if (dumpOnExit) {
129                     options.add(&quot;dumponexit=true&quot;);
130                 }
131                 if (duration != null) {
132                     options.add(&quot;duration=&quot; + ValueFormatter.formatTimespan(duration, &quot;&quot;));
133                 }
134                 if (destination != null) {
135                     options.add(&quot;filename=&quot; + destination.getRealPathText());
136                 }
137                 String optionText = options.toString();
138                 if (optionText.length() != 0) {
139                     optionText = &quot;{&quot; + optionText + &quot;}&quot;;
140                 }
141                 Logger.log(LogTag.JFR, LogLevel.INFO,
142                         &quot;Started recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) &quot; + optionText);
143             };
144             newState = getState();
145         }
146         notifyIfStateChanged(oldState, newState);
147 
148         return startNanos;
149     }
150 
151     public boolean stop(String reason) {
152         RecordingState oldState;
153         RecordingState newState;
154         synchronized (recorder) {
155             oldState = getState();
156             if (stopTask != null) {
157                 stopTask.cancel();
158                 stopTask = null;
159             }
160             recorder.stop(this);
161             String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
162             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
163             newState = getState();
164         }
165         WriteablePath dest = getDestination();
166         if (dest == null &amp;&amp; dumpDirectory != null) {
167             dest = makeDumpPath();
168         }
169         if (dest != null) {
170             try {
171                 dumpStopped(dest);
172                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getRealPathText());
173                 notifyIfStateChanged(newState, oldState);
174                 close(); // remove if copied out
175             } catch(IOException e) {
176                 Logger.log(LogTag.JFR, LogLevel.ERROR,
177                            &quot;Unable to complete I/O operation when dumping recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
178             }
179         } else {
180             notifyIfStateChanged(newState, oldState);
181         }
182         return true;
183     }
184 
185     public WriteablePath makeDumpPath() {
186         try {
187             String name = JVMSupport.makeFilename(getRecording());
188             Path p = dumpDirectory;
189             if (p == null) {
190                 p = Path.of(&quot;.&quot;);
191             }
192             return new WriteablePath(p.resolve(name));
193         } catch (IOException e) {
194             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not dump &quot; + recording.getId() + &quot; on exit. &quot; + e.getMessage());
195         }
196         return null;
197     }
198 
199 
200     public void scheduleStart(Duration delay) {
201         synchronized (recorder) {
202             ensureOkForSchedule();
203 
204             startTime = Instant.now().plus(delay);
205             LocalDateTime now = LocalDateTime.now().plus(delay);
206             setState(RecordingState.DELAYED);
207             startTask = createStartTask();
208             try {
209                 recorder.getTimer().schedule(startTask, delay.toMillis());
210                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Scheduled recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to start at &quot; + now);
211             } catch (IllegalStateException ise) {
212                 // This can happen in the unlikely case that a recording
213                 // is scheduled after the Timer has been cancelled in
214                 // the shutdown hook. Just ignore.
215             }
216         }
217     }
218 
219     private void ensureOkForSchedule() {
220         if (getState() != RecordingState.NEW) {
221             throw new IllegalStateException(&quot;Only a new recording can be scheduled for start&quot;);
222         }
223     }
224 
225     private TimerTask createStartTask() {
226         // Taking ref. to recording here.
227         // Opens up for memory leaks.
228         return new TimerTask() {
229             @Override
230             public void run() {
231                 synchronized (recorder) {
232                     if (getState() != RecordingState.DELAYED) {
233                         return;
234                     }
235                     start();
236                 }
237             }
238         };
239     }
240 
241     void scheduleStart(Instant startTime) {
242         synchronized (recorder) {
243             ensureOkForSchedule();
244             this.startTime = startTime;
245             setState(RecordingState.DELAYED);
246             startTask = createStartTask();
247             recorder.getTimer().schedule(startTask, startTime.toEpochMilli());
248         }
249     }
250 
251     public Map&lt;String, String&gt; getSettings() {
252         synchronized (recorder) {
253             return settings;
254         }
255     }
256 
257     public long getSize() {
258         return size;
259     }
260 
261     public Instant getStopTime() {
262         synchronized (recorder) {
263             return stopTime;
264         }
265     }
266 
267     public Instant getStartTime() {
268         synchronized (recorder) {
269             return startTime;
270         }
271     }
272 
273     public Long getMaxSize() {
274         synchronized (recorder) {
275             return maxSize;
276         }
277     }
278 
279     public Duration getMaxAge() {
280         synchronized (recorder) {
281             return maxAge;
282         }
283     }
284 
285     public String getName() {
286         synchronized (recorder) {
287             return name;
288         }
289     }
290 
291     public RecordingState getState() {
292         synchronized (recorder) {
293             return state;
294         }
295     }
296 
297     @Override
298     public void close() {
299         RecordingState oldState;
300         RecordingState newState;
301 
302         synchronized (recorder) {
303             oldState = getState();
304             if (RecordingState.CLOSED != getState()) {
305                 if (startTask != null) {
306                     startTask.cancel();
307                     startTask = null;
308                 }
309                 recorder.finish(this);
310                 for (RepositoryChunk c : chunks) {
311                     removed(c);
312                 }
313                 chunks.clear();
314                 setState(RecordingState.CLOSED);
315                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Closed recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
316             }
317             newState = getState();
318         }
319         notifyIfStateChanged(newState, oldState);
320     }
321 
322     // To be used internally when doing dumps.
323     // Caller must have recorder lock and close recording before releasing lock
324     public PlatformRecording newSnapshotClone(String reason, Boolean pathToGcRoots) throws IOException {
325         if(!Thread.holdsLock(recorder)) {
326             throw new InternalError(&quot;Caller must have recorder lock&quot;);
327         }
328         RecordingState state = getState();
329         if (state == RecordingState.CLOSED) {
330             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has been closed, no content to write&quot;);
331         }
332         if (state == RecordingState.DELAYED || state == RecordingState.NEW) {
333             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has not started, no content to write&quot;);
334         }
335 
336         if (state == RecordingState.STOPPED) {
337             if (!isToDisk()) {
338                 throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;)&quot;
339                     + &quot; is an in memory recording. No data to copy after it has been stopped.&quot;);
340             }
341             PlatformRecording clone = recorder.newTemporaryRecording();
342             for (RepositoryChunk r : chunks) {
343                 clone.add(r);
344             }
345             return clone;
346         }
347 
348         // Recording is RUNNING, create a clone
349         PlatformRecording clone = recorder.newTemporaryRecording();
350         clone.setShouldWriteActiveRecordingEvent(false);
351         clone.setName(getName());
352         clone.setToDisk(true);
353         clone.setMaxAge(getMaxAge());
354         clone.setMaxSize(getMaxSize());
355         // We purposely don&#39;t clone settings here, since
356         // a union a == a
357         if (!isToDisk()) {
358             // force memory contents to disk
359             clone.start();
360         } else {
361             // using existing chunks on disk
362             for (RepositoryChunk c : chunks) {
363                 clone.add(c);
364             }
365             clone.setState(RecordingState.RUNNING);
366             clone.setStartTime(getStartTime());
367         }
368         if (pathToGcRoots == null) {
369             clone.setSettings(getSettings()); // needed for old object sample
370             clone.stop(reason); // dumps to destination path here
371         } else {
372             // Risk of violating lock order here, since
373             // clone.stop() will take recorder lock inside
374             // metadata lock, but OK if we already
375             // have recorder lock when we entered metadata lock
376             synchronized (MetadataRepository.getInstance()) {
377                 clone.setSettings(OldObjectSample.createSettingsForSnapshot(this, pathToGcRoots));
378                 clone.stop(reason);
379             }
380         }
381         return clone;
382     }
383 
384     public boolean isToDisk() {
385         synchronized (recorder) {
386             return toDisk;
387         }
388     }
389 
390     public void setMaxSize(long maxSize) {
391         synchronized (recorder) {
392             if (getState() == RecordingState.CLOSED) {
393                 throw new IllegalStateException(&quot;Can&#39;t set max size when recording is closed&quot;);
394             }
395             this.maxSize = maxSize;
396             trimToSize();
397         }
398     }
399 
400     public void setDestination(WriteablePath destination) throws IOException {
401         synchronized (recorder) {
402             checkSetDestination(destination);
403             this.destination = destination;
404         }
405     }
406 
407     public void checkSetDestination(WriteablePath writeablePath) throws IOException {
408         // The writeablePath argument is not checked. It&#39;s sufficient that an instance has
409         // been created.
410         synchronized (recorder) {
411             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
412                 throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
413             }
414         }
415     }
416 
417     public WriteablePath getDestination() {
418         synchronized (recorder) {
419             return destination;
420         }
421     }
422 
423     void setState(RecordingState state) {
424         synchronized (recorder) {
425             this.state = state;
426         }
427     }
428 
429     void setStartTime(Instant startTime) {
430         synchronized (recorder) {
431             this.startTime = startTime;
432         }
433     }
434 
435     void setStopTime(Instant timeStamp) {
436         synchronized (recorder) {
437             stopTime = timeStamp;
438         }
439     }
440 
441     public long getId() {
442         synchronized (recorder) {
443             return id;
444         }
445     }
446 
447     public void setName(String name) {
448         synchronized (recorder) {
449             ensureNotClosed();
450             this.name = name;
451         }
452     }
453 
454     private void ensureNotClosed() {
455         if (getState() == RecordingState.CLOSED) {
456             throw new IllegalStateException(&quot;Can&#39;t change name on a closed recording&quot;);
457         }
458     }
459 
460     public void setDumpOnExit(boolean dumpOnExit) {
461         synchronized (recorder) {
462             this.dumpOnExit = dumpOnExit;
463         }
464     }
465 
466     public boolean getDumpOnExit() {
467         synchronized (recorder) {
468             return dumpOnExit;
469         }
470     }
471 
472     public void setToDisk(boolean toDisk) {
473         synchronized (recorder) {
474             if (Utils.isState(getState(), RecordingState.NEW, RecordingState.DELAYED)) {
475                 this.toDisk = toDisk;
476             } else {
477                 throw new IllegalStateException(&quot;Recording option disk can&#39;t be changed after recording has started&quot;);
478             }
479         }
480     }
481 
482     public void setSetting(String id, String value) {
483         synchronized (recorder) {
484             this.settings.put(id, value);
485             if (getState() == RecordingState.RUNNING) {
486                 recorder.updateSettings(true);
487             }
488         }
489     }
490 
491     public void setSettings(Map&lt;String, String&gt; settings) {
492         setSettings(settings, true);
493     }
494 
495     private void setSettings(Map&lt;String, String&gt; settings, boolean update) {
496         if (Logger.shouldLog(LogTag.JFR_SETTING, LogLevel.INFO) &amp;&amp; update) {
497             TreeMap&lt;String, String&gt; ordered = new TreeMap&lt;&gt;(settings);
498             Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, &quot;New settings for recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
499             for (Map.Entry&lt;String, String&gt; entry : ordered.entrySet()) {
500                 String text = entry.getKey() + &quot;=\&quot;&quot; + entry.getValue() + &quot;\&quot;&quot;;
501                 Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, text);
502             }
503         }
504         synchronized (recorder) {
505             this.settings = new LinkedHashMap&lt;&gt;(settings);
506             if (getState() == RecordingState.RUNNING &amp;&amp; update) {
507                 recorder.updateSettings(true);
508             }
509         }
510     }
511 
512     private void notifyIfStateChanged(RecordingState newState, RecordingState oldState) {
513         if (oldState == newState) {
514             return;
515         }
516         for (FlightRecorderListener cl : PlatformRecorder.getListeners()) {
517             try {
518                 // Skip internal recordings
519                 if (recording != null) {
520                     cl.recordingStateChanged(recording);
521                 }
522             } catch (RuntimeException re) {
523                 Logger.log(JFR, WARN, &quot;Error notifying recorder listener:&quot; + re.getMessage());
524             }
525         }
526     }
527 
528     public void setRecording(Recording recording) {
529         this.recording = recording;
530     }
531 
532     public Recording getRecording() {
533         return recording;
534     }
535 
536     @Override
537     public String toString() {
538         return getName() + &quot; (id=&quot; + getId() + &quot;) &quot; + getState();
539     }
540 
541     public void setConfiguration(Configuration c) {
542         setSettings(c.getSettings());
543     }
544 
545     public void setMaxAge(Duration maxAge) {
546         synchronized (recorder) {
547             if (getState() == RecordingState.CLOSED) {
548                 throw new IllegalStateException(&quot;Can&#39;t set max age when recording is closed&quot;);
549             }
550             this.maxAge = maxAge;
551             if (maxAge != null) {
552                 trimToAge(Instant.now().minus(maxAge));
553             }
554         }
555     }
556 
557     void appendChunk(RepositoryChunk chunk) {
558         if (!chunk.isFinished()) {
559             throw new Error(&quot;not finished chunk &quot; + chunk.getStartTime());
560         }
561         synchronized (recorder) {
562             if (!toDisk) {
563                 return;
564             }
565             if (maxAge != null) {
566                 trimToAge(chunk.getEndTime().minus(maxAge));
567             }
568             chunks.addLast(chunk);
569             added(chunk);
570             trimToSize();
571         }
572     }
573 
574     private void trimToSize() {
575         if (maxSize == 0) {
576             return;
577         }
578         while (size &gt; maxSize &amp;&amp; chunks.size() &gt; 1) {
579             RepositoryChunk c = chunks.removeFirst();
580             removed(c);
581         }
582     }
583 
584     private void trimToAge(Instant oldest) {
585         while (!chunks.isEmpty()) {
586             RepositoryChunk oldestChunk = chunks.peek();
587             if (oldestChunk.getEndTime().isAfter(oldest)) {
588                 return;
589             }
590             chunks.removeFirst();
591             removed(oldestChunk);
592         }
593     }
594 
595     void add(RepositoryChunk c) {
596         chunks.add(c);
597         added(c);
598     }
599 
600     private void added(RepositoryChunk c) {
601         c.use();
602         size += c.getSize();
603         if (Logger.shouldLog(JFR, DEBUG)) {
604             Logger.log(JFR, DEBUG, &quot;Recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) added chunk &quot; + c.toString() + &quot;, current size=&quot; + size);
605         }
606     }
607 
608     private void removed(RepositoryChunk c) {
609         size -= c.getSize();
610         if (Logger.shouldLog(JFR, DEBUG)) {
611             Logger.log(JFR, DEBUG, &quot;Recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) removed chunk &quot; + c.toString() + &quot;, current size=&quot; + size);
612         }
613         c.release();
614     }
615 
616     public List&lt;RepositoryChunk&gt; getChunks() {
617         return chunks;
618     }
619 
620     public InputStream open(Instant start, Instant end) throws IOException {
621         synchronized (recorder) {
622             if (getState() != RecordingState.STOPPED) {
623                 throw new IOException(&quot;Recording must be stopped before it can be read.&quot;);
624             }
625             List&lt;RepositoryChunk&gt; chunksToUse = new ArrayList&lt;RepositoryChunk&gt;();
626             for (RepositoryChunk chunk : chunks) {
627                 if (chunk.isFinished()) {
628                     Instant chunkStart = chunk.getStartTime();
629                     Instant chunkEnd = chunk.getEndTime();
630                     if (start == null || !chunkEnd.isBefore(start)) {
631                         if (end == null || !chunkStart.isAfter(end)) {
632                             chunksToUse.add(chunk);
633                         }
634                     }
635                 }
636             }
637             if (chunksToUse.isEmpty()) {
638                 return null;
639             }
640             return new ChunkInputStream(chunksToUse);
641         }
642     }
643 
644     public Duration getDuration() {
645         synchronized (recorder) {
646             return duration;
647         }
648     }
649 
650     void setInternalDuration(Duration duration) {
651         this.duration = duration;
652     }
653 
654     public void setDuration(Duration duration) {
655         synchronized (recorder) {
656             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
657                 throw new IllegalStateException(&quot;Duration can&#39;t be set after a recording has been stopped/closed&quot;);
658             }
659             setInternalDuration(duration);
660             if (getState() != RecordingState.NEW) {
661                 updateTimer();
662             }
663         }
664     }
665 
666     void updateTimer() {
667         if (stopTask != null) {
668             stopTask.cancel();
669             stopTask = null;
670         }
671         if (getState() == RecordingState.CLOSED) {
672             return;
673         }
674         if (duration != null) {
675             stopTask = createStopTask();
676             recorder.getTimer().schedule(stopTask, new Date(startTime.plus(duration).toEpochMilli()));
677         }
678     }
679 
680     TimerTask createStopTask() {
681         return new TimerTask() {
682             @Override
683             public void run() {
684                 try {
685                     stop(&quot;End of duration reached&quot;);
686                 } catch (Throwable t) {
687                     Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not stop recording. &quot; + t.getMessage());
688                 }
689             }
690         };
691     }
692 
693     public Recording newCopy(boolean stop) {
694         return recorder.newCopy(this, stop);
695     }
696 
697     void setStopTask(TimerTask stopTask) {
698         synchronized (recorder) {
699             this.stopTask = stopTask;
700         }
701     }
702 
703     void clearDestination() {
704         destination = null;
705     }
706 
707     void setShouldWriteActiveRecordingEvent(boolean shouldWrite) {
708         this.shouldWriteActiveRecordingEvent = shouldWrite;
709     }
710 
711     boolean shouldWriteMetadataEvent() {
712         return shouldWriteActiveRecordingEvent;
713     }
714 
715     // Dump running and stopped recordings
716     public void dump(WriteablePath writeablePath) throws IOException {
717         synchronized (recorder) {
718             try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
719                 p.dumpStopped(writeablePath);
720             }
721         }
722     }
723 
724     public void dumpStopped(WriteablePath path) throws IOException {
725         synchronized (recorder) {
726             transferChunksWithRetry(path);
727         }
728     }
729 
730     private void transferChunksWithRetry(WriteablePath path) throws IOException {
731         try {
732             transferChunks(path);
733         } catch (NoSuchFileException nsfe) {
734             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Missing chunkfile when writing recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) to &quot; + path.getRealPathText() + &quot;.&quot;);
735             // if one chunkfile was missing, its likely more are missing
736             removeNonExistantPaths();
737             // and try the transfer again
738             transferChunks(path);
739         }
740     }
741 
742     private void transferChunks(WriteablePath path) throws IOException {
743         try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
744             long bytes = cc.transferTo(fc);
745             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Transferred &quot; + bytes + &quot; bytes from the disk repository&quot;);
746             // No need to force if no data was transferred, which avoids IOException when device is /dev/null
747             if (bytes != 0) {
748                 fc.force(true);
749             }
750         }
751     }
752 
753     public void filter(Instant begin, Instant end, Long maxSize) {
754         synchronized (recorder) {
755             List&lt;RepositoryChunk&gt; result = removeAfter(end, removeBefore(begin, new ArrayList&lt;&gt;(chunks)));
756             if (maxSize != null) {
757                 if (begin != null &amp;&amp; end == null) {
758                     result = reduceFromBeginning(maxSize, result);
759                 } else {
760                     result = reduceFromEnd(maxSize, result);
761                 }
762             }
763             long size = 0;
764             for (RepositoryChunk r : result) {
765                 size += r.getSize();
766                 r.use();
767             }
768             this.size = size;
769             for (RepositoryChunk r : chunks) {
770                 r.release();
771             }
772             chunks.clear();
773             chunks.addAll(result);
774         }
775     }
776 
777     private static List&lt;RepositoryChunk&gt; removeBefore(Instant time, List&lt;RepositoryChunk&gt; input) {
778         if (time == null) {
779             return input;
780         }
781         List&lt;RepositoryChunk&gt; result = new ArrayList&lt;&gt;(input.size());
782         for (RepositoryChunk r : input) {
783             if (!r.getEndTime().isBefore(time)) {
784                 result.add(r);
785             }
786         }
787         return result;
788     }
789 
790     private static List&lt;RepositoryChunk&gt; removeAfter(Instant time, List&lt;RepositoryChunk&gt; input) {
791         if (time == null) {
792             return input;
793         }
794         List&lt;RepositoryChunk&gt; result = new ArrayList&lt;&gt;(input.size());
795         for (RepositoryChunk r : input) {
796             if (!r.getStartTime().isAfter(time)) {
797                 result.add(r);
798             }
799         }
800         return result;
801     }
802 
803     private static List&lt;RepositoryChunk&gt; reduceFromBeginning(Long maxSize, List&lt;RepositoryChunk&gt; input) {
804         if (maxSize == null || input.isEmpty()) {
805             return input;
806         }
807         List&lt;RepositoryChunk&gt; result = new ArrayList&lt;&gt;(input.size());
808         long total = 0;
809         for (RepositoryChunk r : input) {
810             total += r.getSize();
811             if (total &gt; maxSize) {
812                 break;
813             }
814             result.add(r);
815         }
816         // always keep at least one chunk
817         if (result.isEmpty()) {
818             result.add(input.getFirst());
819         }
820         return result;
821     }
822 
823     private static List&lt;RepositoryChunk&gt; reduceFromEnd(Long maxSize, List&lt;RepositoryChunk&gt; input) {
824         Collections.reverse(input);
825         List&lt;RepositoryChunk&gt; result = reduceFromBeginning(maxSize, input);
826         Collections.reverse(result);
827         return result;
828     }
829 
830     /**
831      * Sets the dump directory.
832      * &lt;p&gt;
833      * Only to be used by DCmdStart.
834      */
835     public void setDumpDirectory(Path directory) {
836        this.dumpDirectory = directory;
837     }
838 
839     public void setFlushInterval(Duration interval) {
840         synchronized (recorder) {
841             if (getState() == RecordingState.CLOSED) {
842                 throw new IllegalStateException(&quot;Can&#39;t set stream interval when recording is closed&quot;);
843             }
844             this.flushInterval = interval;
845         }
846     }
847 
848     public Duration getFlushInterval() {
849         synchronized (recorder) {
850             return flushInterval;
851         }
852     }
853 
854     public long getStreamIntervalMillis() {
855         synchronized (recorder) {
856             if (flushInterval != null) {
857                 return flushInterval.toMillis();
858             }
859             return Long.MAX_VALUE;
860         }
861     }
862 
863     public long getStartNanos() {
864         return startNanos;
865     }
866 
867     public long getFinalChunkStartNanos() {
868         return finalStartChunkNanos;
869     }
870 
871     public void setFinalStartnanos(long chunkStartNanos) {
872        this.finalStartChunkNanos = chunkStartNanos;
873     }
874 
875     public void removeBefore(Instant timestamp) {
876         synchronized (recorder) {
877             while (!chunks.isEmpty()) {
878                 RepositoryChunk oldestChunk = chunks.peek();
879                 if (!oldestChunk.getEndTime().isBefore(timestamp)) {
880                     return;
881                 }
882                 chunks.removeFirst();
883                 removed(oldestChunk);
884             }
885         }
886 
887     }
888 
889     public void removePath(Path path) {
890         synchronized (recorder) {
891             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
892             while (it.hasNext()) {
893                 RepositoryChunk c = it.next();
894                 if (c.getFile().equals(path)) {
895                     it.remove();
896                     removed(c);
897                     return;
898                 }
899             }
900         }
901     }
902 
903     void removeNonExistantPaths() {
904         synchronized (recorder) {
905             Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
906             Logger.log(JFR, INFO, &quot;Checking for missing chunkfiles for recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;)&quot;);
907             while (it.hasNext()) {
908                 RepositoryChunk chunk = it.next();
909                 if (chunk.isMissingFile()) {
910                     String msg = &quot;Chunkfile \&quot;&quot; + chunk.getFile() + &quot;\&quot; is missing. &quot; +
911                                  &quot;Data loss might occur from &quot; + chunk.getStartTime();
912                     if (chunk.getEndTime() != null) {
913                         msg += &quot; to &quot; + chunk.getEndTime();
914                     }
915                     Logger.log(JFR, ERROR, msg);
916 
917                     JVM.emitDataLoss(chunk.getSize());
918 
919                     it.remove();
920                     removed(chunk);
921                 }
922             }
923         }
924     }
925 }
    </pre>
  </body>
</html>