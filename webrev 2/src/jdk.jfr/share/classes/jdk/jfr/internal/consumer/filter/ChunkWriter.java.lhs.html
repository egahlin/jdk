<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2022, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.consumer.filter;
 26 
 27 import java.io.Closeable;
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.util.ArrayDeque;
 32 import java.util.Deque;
 33 import java.util.Map;
 34 import java.util.HashMap;
 35 import java.util.function.Predicate;
 36 
 37 import jdk.jfr.consumer.RecordedEvent;
 38 import jdk.jfr.internal.LongMap;
 39 import jdk.jfr.internal.Type;
 40 import jdk.jfr.internal.consumer.ChunkHeader;
<a name="2" id="anc2"></a><span class="line-removed"> 41 import jdk.jfr.internal.consumer.FileAccess;</span>
 42 import jdk.jfr.internal.Logger;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.consumer.RecordingInput;
 46 import jdk.jfr.internal.consumer.Reference;
 47 
 48 /**
 49  * Class that can filter out events and associated constants from a recording
 50  * file.
 51  * &lt;p&gt;
 52  * All positional values are relative to file start, not the chunk.
 53  */
 54 public final class ChunkWriter implements Closeable {
 55     private LongMap&lt;Constants&gt; pools = new LongMap&lt;&gt;();
 56     private final Deque&lt;CheckpointEvent&gt; checkpoints = new ArrayDeque&lt;&gt;();
 57     private final Path destination;
 58     private final RecordingInput input;
 59     private final RecordingOutput output;
 60     private final Predicate&lt;RecordedEvent&gt; filter;
 61     private final Map&lt;String, Long&gt; waste = new HashMap&lt;&gt;();
 62 
 63     private long chunkStartPosition;
 64     private boolean chunkComplete;
 65     private long lastCheckpoint;
 66 
 67     public ChunkWriter(Path source, Path destination, Predicate&lt;RecordedEvent&gt; filter) throws IOException {
 68         this.destination = destination;
 69         this.output = new RecordingOutput(destination.toFile());
<a name="3" id="anc3"></a><span class="line-modified"> 70         this.input = new RecordingInput(source.toFile(), FileAccess.UNPRIVILEGED);</span>
 71         this.filter = filter;
 72     }
 73 
 74     Constants getPool(Type type) {
 75         long typeId = type.getId();
 76         Constants pool = pools.get(typeId);
 77         if (pool == null) {
 78             pool = new Constants(type);
 79             pools.put(typeId, pool);
 80         }
 81         return pool;
 82     }
 83 
 84     public CheckpointEvent newCheckpointEvent(long startPosition) {
 85         CheckpointEvent event = new CheckpointEvent(this, startPosition);
 86         checkpoints.add(event);
 87         return event;
 88     }
 89 
 90     public boolean accept(RecordedEvent event) {
 91         return filter.test(event);
 92     }
 93 
 94     public void touch(Object object) {
 95         if (object instanceof Object[] array) {
 96             for (int i = 0; i &lt; array.length; i++) {
 97                 touch(array[i]);
 98             }
 99             return;
100         }
101         if (object instanceof Reference ref) {
102             touchRef(ref);
103         }
104     }
105 
106     private void touchRef(Reference ref) {
107         Constants pool = pools.get(ref.type().getId());
108         if (pool == null) {
109             String msg = &quot;Can&#39;t resolve &quot; + ref.type().getName() + &quot;[&quot; + ref.key() + &quot;]&quot;;
110             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);
111             return;
112         }
113         PoolEntry entry = pool.get(ref.key());
114         if (entry != null &amp;&amp; !entry.isTouched()) {
115             entry.touch();
116             touch(entry.getReferences());
117         }
118     }
119     public void writeEvent(long startPosition, long endPosition) throws IOException {
120         writeCheckpointEvents(startPosition);
121         write(startPosition, endPosition);
122     }
123 
124     // Write check point events before a position
125     private void writeCheckpointEvents(long before) throws IOException {
126         CheckpointEvent cp = checkpoints.peek();
127         while (cp != null &amp;&amp; cp.getStartPosition() &lt; before) {
128             checkpoints.poll();
129             long delta = 0;
130             if (lastCheckpoint != 0) {
131                 delta = lastCheckpoint - output.position();
132             }
133             lastCheckpoint = output.position();
134             write(cp, delta);
135             cp = checkpoints.peek();
136         }
137     }
138 
139     public void write(long startPosition, long endPosition) throws IOException {
140         if (endPosition &lt; startPosition) {
141             throw new IOException(&quot;Start position must come before end position, start=&quot; + startPosition + &quot;, end=&quot; + endPosition);
142         }
143         long backup = input.position();
144         input.position(startPosition);
145         long n = endPosition - startPosition;
146         for (long i = 0; i &lt; n; i++) {
147             output.writeByte(input.readByte());
148         }
149         input.position(backup);
150     }
151 
152     @Override
153     public void close() throws IOException {
154         try {
155             output.close();
156         } finally {
157             if (!chunkComplete) {
158                 // Error occurred, clean up
159                 if (Files.exists(destination)) {
160                     Files.delete(destination);
161                 }
162             }
163         }
164     }
165 
166     public void beginChunk(ChunkHeader header) throws IOException {
167         this.chunkComplete = false;
168         this.chunkStartPosition = output.position();
169         input.position(header.getAbsoluteChunkStart());
170         for (int i = 0; i &lt; ChunkHeader.HEADER_SIZE; i++) {
171             output.writeByte(input.readByte());
172         }
173     }
174 
175     public void endChunk(ChunkHeader header) throws IOException {
176         // write all outstanding checkpoints
177         writeCheckpointEvents(Long.MAX_VALUE);
178         long metadata = output.position();
179         writeMetadataEvent(header);
180         updateHeader(output.position(), lastCheckpoint, metadata);
181         pools = new LongMap&lt;&gt;();
182         chunkComplete = true;
183         lastCheckpoint = 0;
184         if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {
185             // Log largest waste first
186             waste.entrySet().stream()
187                  .sorted((a, b) -&gt; b.getValue().compareTo(a.getValue()))
188                  .forEach(entry -&gt; {
189                      String msg = &quot;Total chunk waste by &quot; + entry.getKey() + &quot;: &quot; + entry.getValue() + &quot; bytes.&quot;;
190                      Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);
191                  });
192         }
193         waste.clear();
194     }
195 
196     private void writeMetadataEvent(ChunkHeader header) throws IOException {
197         long metadataposition = header.getMetadataPosition() + header.getAbsoluteChunkStart();
198         input.position(metadataposition);
199         long size = input.readLong();
200         input.position(metadataposition);
201         for (int i = 0; i &lt; size; i++) {
202             output.writeByte(input.readByte());
203         }
204     }
205 
206     private void write(CheckpointEvent event, long delta) throws IOException {
207         input.position(event.getStartPosition());
208         long startPosition = output.position();
209 
210         input.readLong(); // Read size
211         output.writePaddedUnsignedInt(0); // Size, 4 bytes reserved
212         output.writeLong(input.readLong()); // Constant pool id
213         output.writeLong(input.readLong()); // Start time
214         output.writeLong(input.readLong()); // Duration
215         input.readLong(); // Read delta
216         output.writeLong(delta); // Delta
217         output.writeByte(input.readByte()); // flush marker
218 
219         // Write even if touched pools are zero, checkpoint works as sync point
220         output.writeLong(event.touchedPools()); // Pool count
221         for (CheckpointPool pool : event.getPools()) {
222             if (pool.isTouched()) {
223                 output.writeLong(pool.getTypeId());
224                 output.writeLong(pool.getTouchedCount());
225                 for (PoolEntry pe : pool.getEntries()) {
226                     if (pe.isTouched()) {
227                         write(pe.getStartPosition(), pe.getEndPosition()); // key + value
228                     }
229                 }
230             }
231         }
232         if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {
233             for (CheckpointPool pool : event.getPools()) {
234                 for (PoolEntry pe : pool.getEntries()) {
235                     if (!pe.isTouched()) {
236                         String name = pe.getType().getName();
237                         long amount = pe.getEndPosition() - pe.getStartPosition();
238                         waste.merge(pe.getType().getName(), amount, Long::sum);
239                         String msg = &quot;Unreferenced constant ID &quot; + pe.getId() +
240                                      &quot; of type &quot;+ name + &quot; using &quot; + amount + &quot; bytes.&quot;;
241                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, msg);
242                     }
243                 }
244             }
245         }
246         long endPosition = output.position();
247         long size = endPosition - startPosition;
248         output.position(startPosition);
249         output.writePaddedUnsignedInt(size);
250         output.position(endPosition);
251     }
252 
253     private void updateHeader(long size, long constantPosition, long metadataPosition) throws IOException {
254         long backup = output.position();
255         output.position(ChunkHeader.CHUNK_SIZE_POSITION + chunkStartPosition);
256         // Write chunk relative values
257         output.writeRawLong(size - chunkStartPosition);
258         output.writeRawLong(constantPosition - chunkStartPosition);
259         output.writeRawLong(metadataPosition - chunkStartPosition);
260         output.position(backup);
261     }
262 
263     public RecordingInput getInput() {
264         return input;
265     }
266 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>