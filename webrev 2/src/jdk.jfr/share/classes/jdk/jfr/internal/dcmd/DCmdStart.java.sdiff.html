<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DCmdDump.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DCmdStop.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
<span class="line-removed"> 32 import java.security.AccessControlContext;</span>
<span class="line-removed"> 33 import java.security.AccessController;</span>
 34 import java.text.ParseException;
 35 import java.time.Duration;
 36 import java.util.HashSet;
 37 import java.util.LinkedHashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Set;
 41 
 42 import jdk.jfr.FlightRecorder;
 43 import jdk.jfr.Recording;
 44 import jdk.jfr.internal.JVM;
 45 import jdk.jfr.internal.LogLevel;
 46 import jdk.jfr.internal.LogTag;
 47 import jdk.jfr.internal.Logger;
 48 import jdk.jfr.internal.OldObjectSample;
 49 import jdk.jfr.internal.PlatformRecording;
 50 import jdk.jfr.internal.PrivateAccess;
<span class="line-removed"> 51 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
<span class="line-removed"> 52 import jdk.jfr.internal.SecuritySupport;</span>
 53 import jdk.jfr.internal.Type;
 54 import jdk.jfr.internal.jfc.JFC;
 55 import jdk.jfr.internal.jfc.model.JFCModel;
 56 import jdk.jfr.internal.jfc.model.JFCModelException;
 57 import jdk.jfr.internal.jfc.model.XmlInput;
 58 import jdk.jfr.internal.util.Utils;
 59 
 60 /**
 61  * JFR.start
 62  *
 63  */
 64 //Instantiated by native
 65 final class DCmdStart extends AbstractDCmd {
 66 
 67     @Override
 68     public void execute(ArgumentParser parser) throws DCmdException {
 69         String name = parser.getOption(&quot;name&quot;);
 70         List&lt;String&gt; list = parser.getOption(&quot;settings&quot;);
 71         String[] settings = null;
 72         if (list == null) {
</pre>
<hr />
<pre>
137         }
138 
139         Recording recording = new Recording();
140         if (name != null) {
141             recording.setName(name);
142         }
143 
144         if (disk != null) {
145             if (!disk) {
146                 if (maxAge != null) {
147                     logWarning(&quot;Option maxage has no effect with disk=false.&quot;);
148                 }
149                 if (maxSize != null) {
150                     logWarning(&quot;Option maxsize has no effect with disk=false.&quot;);
151                 }
152             }
153             recording.setToDisk(disk.booleanValue());
154         }
155 
156         recording.setSettings(s);
<span class="line-modified">157         SafePath safePath = null;</span>
158 
159         // Generate dump filename if user has specified a time-bound recording
160         if (duration != null &amp;&amp; path == null) {
161             path = resolvePath(recording, null).toString();
162         }
163 
164         if (path != null) {
165             try {
166                 if (dumpOnExit == null) {
167                     // default to dumponexit=true if user specified filename
168                     dumpOnExit = Boolean.TRUE;
169                 }
170                 Path p = Paths.get(path);
171                 if (Files.isDirectory(p)) {
172                     // Decide destination filename at dump time
173                     // Purposely avoid generating filename in Recording#setDestination due to
174                     // security concerns
175                     PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">176                     pr.setDumpDirectory(new SafePath(p));</span>
177                 } else {
<span class="line-modified">178                     safePath = resolvePath(recording, path);</span>
<span class="line-modified">179                     recording.setDestination(safePath.toPath());</span>
180                 }
181             } catch (IOException | InvalidPathException e) {
182                 recording.close();
183                 throw new DCmdException(&quot;Could not start recording, not able to write to file %s. %s &quot;, path, e.getMessage());
184             }
185         }
186 
187         if (maxAge != null) {
188             recording.setMaxAge(Duration.ofNanos(maxAge));
189         }
190 
191         if (flush != null) {
192             PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);
193             p.setFlushInterval(Duration.ofNanos(flush));
194         }
195 
196         if (maxSize != null) {
197             recording.setMaxSize(maxSize);
198         }
199 
</pre>
<hr />
<pre>
204         if (dumpOnExit != null) {
205             recording.setDumpOnExit(dumpOnExit);
206         }
207 
208         if (delay != null) {
209             Duration dDelay = Duration.ofNanos(delay);
210             recording.scheduleStart(dDelay);
211             print(&quot;Recording &quot; + recording.getId() + &quot; scheduled to start in &quot;);
212             printTimespan(dDelay, &quot; &quot;);
213             print(&quot;.&quot;);
214         } else {
215             recording.start();
216             print(&quot;Started recording &quot; + recording.getId() + &quot;.&quot;);
217         }
218 
219         if (recording.isToDisk() &amp;&amp; duration == null &amp;&amp; maxAge == null &amp;&amp; maxSize == null) {
220             print(&quot; No limit specified, using maxsize=250MB as default.&quot;);
221             recording.setMaxSize(250*1024L*1024L);
222         }
223 
<span class="line-modified">224         if (safePath != null &amp;&amp; duration != null) {</span>
225             println(&quot; The result will be written to:&quot;);
226             println();
<span class="line-modified">227             printPath(safePath);</span>
228         } else {
229             println();
230             println();
231             String cmd = duration == null ? &quot;dump&quot; : &quot;stop&quot;;
232             String fileOption = path == null ? &quot;filename=FILEPATH &quot; : &quot;&quot;;
233             String recordingspecifier = &quot;name=&quot; + recording.getId();
234             // if user supplied a name, use it.
235             if (name != null) {
236                 recordingspecifier = &quot;name=&quot; + quoteIfNeeded(name);
237             }
238             print(&quot;Use jcmd &quot; + getPid() + &quot; JFR.&quot; + cmd + &quot; &quot; + recordingspecifier + &quot; &quot; + fileOption + &quot;to copy recording data to file.&quot;);
239             println();
240         }
241     }
242 
243     private LinkedHashMap&lt;String, String&gt; configureStandard(String[] settings) throws DCmdException {
244         LinkedHashMap&lt;String, String&gt; s = LinkedHashMap.newLinkedHashMap(settings.length);
245         for (String configName : settings) {
246             try {
247                 s.putAll(JFC.createKnown(configName).getSettings());
248             } catch (InvalidPathException | IOException | ParseException e) {
249                 throw new DCmdException(JFC.formatException(&quot;Could not&quot;, e, configName), e);
250             }
251         }
252         return s;
253     }
254 
255     private LinkedHashMap&lt;String, String&gt; configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {
256         JFCModel model = new JFCModel(l -&gt; logWarning(l));
257         for (String setting : settings) {
258             try {
<span class="line-modified">259                 model.parse(JFC.createSafePath(setting));</span>
260             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
261                 throw new DCmdException(JFC.formatException(&quot;Could not&quot;, e, setting), e);
262             }
263         }
264         try {
265             Set&lt;String&gt; jfcOptions = new HashSet&lt;&gt;();
266             for (XmlInput input : model.getInputs()) {
267                 jfcOptions.add(input.getName());
268             }
269             parser.checkSpelling(jfcOptions);
270             Map&lt;String, String&gt; jfcSettings = model.getSettings();
271             for (var entry : parser.getExtendedOptions().entrySet()) {
272                 String value = (String)entry.getValue();
273                 String optionName = entry.getKey();
274                 boolean added = optionName.startsWith(&quot;+&quot;);
275                 if (!added &amp;&amp; !jfcOptions.contains(optionName) &amp;&amp; !jfcSettings.containsKey(optionName)) {
276                     // Option/setting doesn&#39;t exist and it is not a spelling error.
277                     // By not throwing an exception, and instead print a warning,
278                     // it is easier migrate to a newer JDK version without
279                     // breaking startup scripts
</pre>
<hr />
<pre>
446                 $SOURCEfilename=dump.jfr
447                 $SOURCEfilename=$DIRECTORY
448                 $SOURCEdumponexit=true
449                 $SOURCEmaxage=1h$DELIMITERmaxsize=1000M
450                 $SOURCEsettings=profile
451                 $SOURCEdelay=5m$DELIMITERsettings=my.jfc
452                 $SOURCEgc=high$DELIMITERmethod-profiling=high
453                 $SOURCEjdk.JavaMonitorEnter#threshold=1ms
454                 $SOURCE+HelloWorld#enabled=true$DELIMITER+HelloWorld#stackTrace=true
455                 $SOURCEsettings=user.jfc$DELIMITERcom.example.UserDefined#enabled=true
456                 $SOURCEsettings=none$DELIMITER+Hello#enabled=true
457 
458                Note, if the default event settings are modified, overhead may exceed 1%.
459 
460                &quot;&quot;&quot;;
461     }
462 
463     private static String jfcOptions() {
464         try {
465             StringBuilder sb = new StringBuilder();
<span class="line-modified">466             for (SafePath s : SecuritySupport.getPredefinedJFCFiles()) {</span>
<span class="line-modified">467                 String name = JFC.nameFromPath(s.toPath());</span>
468                 JFCModel model = JFCModel.create(s, l -&gt; {});
469                 sb.append(&#39;\n&#39;);
470                 sb.append(&quot;Options for &quot;).append(name).append(&quot;:\n&quot;);
471                 sb.append(&#39;\n&#39;);
472                 for (XmlInput input : model.getInputs()) {
473                     sb.append(&quot;  &quot;).append(input.getOptionSyntax()).append(&#39;\n&#39;);
474                     sb.append(&#39;\n&#39;);
475                 }
476             }
477             return sb.toString();
478         } catch (IOException | JFCModelException | ParseException  e) {
479             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Could not list .jfc options for JFR.start. &quot; + e.getMessage());
480             return &quot;&quot;;
481         }
482     }
483 
484     @Override
485     public Argument[] getArgumentInfos() {
486         return new Argument[] {
487             new Argument(&quot;name&quot;,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;


 32 import java.text.ParseException;
 33 import java.time.Duration;
 34 import java.util.HashSet;
 35 import java.util.LinkedHashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Set;
 39 
 40 import jdk.jfr.FlightRecorder;
 41 import jdk.jfr.Recording;
 42 import jdk.jfr.internal.JVM;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;
 46 import jdk.jfr.internal.OldObjectSample;
 47 import jdk.jfr.internal.PlatformRecording;
 48 import jdk.jfr.internal.PrivateAccess;


 49 import jdk.jfr.internal.Type;
 50 import jdk.jfr.internal.jfc.JFC;
 51 import jdk.jfr.internal.jfc.model.JFCModel;
 52 import jdk.jfr.internal.jfc.model.JFCModelException;
 53 import jdk.jfr.internal.jfc.model.XmlInput;
 54 import jdk.jfr.internal.util.Utils;
 55 
 56 /**
 57  * JFR.start
 58  *
 59  */
 60 //Instantiated by native
 61 final class DCmdStart extends AbstractDCmd {
 62 
 63     @Override
 64     public void execute(ArgumentParser parser) throws DCmdException {
 65         String name = parser.getOption(&quot;name&quot;);
 66         List&lt;String&gt; list = parser.getOption(&quot;settings&quot;);
 67         String[] settings = null;
 68         if (list == null) {
</pre>
<hr />
<pre>
133         }
134 
135         Recording recording = new Recording();
136         if (name != null) {
137             recording.setName(name);
138         }
139 
140         if (disk != null) {
141             if (!disk) {
142                 if (maxAge != null) {
143                     logWarning(&quot;Option maxage has no effect with disk=false.&quot;);
144                 }
145                 if (maxSize != null) {
146                     logWarning(&quot;Option maxsize has no effect with disk=false.&quot;);
147                 }
148             }
149             recording.setToDisk(disk.booleanValue());
150         }
151 
152         recording.setSettings(s);
<span class="line-modified">153         Path dumpPath = null;</span>
154 
155         // Generate dump filename if user has specified a time-bound recording
156         if (duration != null &amp;&amp; path == null) {
157             path = resolvePath(recording, null).toString();
158         }
159 
160         if (path != null) {
161             try {
162                 if (dumpOnExit == null) {
163                     // default to dumponexit=true if user specified filename
164                     dumpOnExit = Boolean.TRUE;
165                 }
166                 Path p = Paths.get(path);
167                 if (Files.isDirectory(p)) {
168                     // Decide destination filename at dump time
169                     // Purposely avoid generating filename in Recording#setDestination due to
170                     // security concerns
171                     PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
<span class="line-modified">172                     pr.setDumpDirectory(p);</span>
173                 } else {
<span class="line-modified">174                     dumpPath = resolvePath(recording, path);</span>
<span class="line-modified">175                     recording.setDestination(dumpPath);</span>
176                 }
177             } catch (IOException | InvalidPathException e) {
178                 recording.close();
179                 throw new DCmdException(&quot;Could not start recording, not able to write to file %s. %s &quot;, path, e.getMessage());
180             }
181         }
182 
183         if (maxAge != null) {
184             recording.setMaxAge(Duration.ofNanos(maxAge));
185         }
186 
187         if (flush != null) {
188             PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);
189             p.setFlushInterval(Duration.ofNanos(flush));
190         }
191 
192         if (maxSize != null) {
193             recording.setMaxSize(maxSize);
194         }
195 
</pre>
<hr />
<pre>
200         if (dumpOnExit != null) {
201             recording.setDumpOnExit(dumpOnExit);
202         }
203 
204         if (delay != null) {
205             Duration dDelay = Duration.ofNanos(delay);
206             recording.scheduleStart(dDelay);
207             print(&quot;Recording &quot; + recording.getId() + &quot; scheduled to start in &quot;);
208             printTimespan(dDelay, &quot; &quot;);
209             print(&quot;.&quot;);
210         } else {
211             recording.start();
212             print(&quot;Started recording &quot; + recording.getId() + &quot;.&quot;);
213         }
214 
215         if (recording.isToDisk() &amp;&amp; duration == null &amp;&amp; maxAge == null &amp;&amp; maxSize == null) {
216             print(&quot; No limit specified, using maxsize=250MB as default.&quot;);
217             recording.setMaxSize(250*1024L*1024L);
218         }
219 
<span class="line-modified">220         if (dumpPath != null &amp;&amp; duration != null) {</span>
221             println(&quot; The result will be written to:&quot;);
222             println();
<span class="line-modified">223             printPath(dumpPath);</span>
224         } else {
225             println();
226             println();
227             String cmd = duration == null ? &quot;dump&quot; : &quot;stop&quot;;
228             String fileOption = path == null ? &quot;filename=FILEPATH &quot; : &quot;&quot;;
229             String recordingspecifier = &quot;name=&quot; + recording.getId();
230             // if user supplied a name, use it.
231             if (name != null) {
232                 recordingspecifier = &quot;name=&quot; + quoteIfNeeded(name);
233             }
234             print(&quot;Use jcmd &quot; + getPid() + &quot; JFR.&quot; + cmd + &quot; &quot; + recordingspecifier + &quot; &quot; + fileOption + &quot;to copy recording data to file.&quot;);
235             println();
236         }
237     }
238 
239     private LinkedHashMap&lt;String, String&gt; configureStandard(String[] settings) throws DCmdException {
240         LinkedHashMap&lt;String, String&gt; s = LinkedHashMap.newLinkedHashMap(settings.length);
241         for (String configName : settings) {
242             try {
243                 s.putAll(JFC.createKnown(configName).getSettings());
244             } catch (InvalidPathException | IOException | ParseException e) {
245                 throw new DCmdException(JFC.formatException(&quot;Could not&quot;, e, configName), e);
246             }
247         }
248         return s;
249     }
250 
251     private LinkedHashMap&lt;String, String&gt; configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {
252         JFCModel model = new JFCModel(l -&gt; logWarning(l));
253         for (String setting : settings) {
254             try {
<span class="line-modified">255                 model.parse(JFC.ofPath(setting));</span>
256             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
257                 throw new DCmdException(JFC.formatException(&quot;Could not&quot;, e, setting), e);
258             }
259         }
260         try {
261             Set&lt;String&gt; jfcOptions = new HashSet&lt;&gt;();
262             for (XmlInput input : model.getInputs()) {
263                 jfcOptions.add(input.getName());
264             }
265             parser.checkSpelling(jfcOptions);
266             Map&lt;String, String&gt; jfcSettings = model.getSettings();
267             for (var entry : parser.getExtendedOptions().entrySet()) {
268                 String value = (String)entry.getValue();
269                 String optionName = entry.getKey();
270                 boolean added = optionName.startsWith(&quot;+&quot;);
271                 if (!added &amp;&amp; !jfcOptions.contains(optionName) &amp;&amp; !jfcSettings.containsKey(optionName)) {
272                     // Option/setting doesn&#39;t exist and it is not a spelling error.
273                     // By not throwing an exception, and instead print a warning,
274                     // it is easier migrate to a newer JDK version without
275                     // breaking startup scripts
</pre>
<hr />
<pre>
442                 $SOURCEfilename=dump.jfr
443                 $SOURCEfilename=$DIRECTORY
444                 $SOURCEdumponexit=true
445                 $SOURCEmaxage=1h$DELIMITERmaxsize=1000M
446                 $SOURCEsettings=profile
447                 $SOURCEdelay=5m$DELIMITERsettings=my.jfc
448                 $SOURCEgc=high$DELIMITERmethod-profiling=high
449                 $SOURCEjdk.JavaMonitorEnter#threshold=1ms
450                 $SOURCE+HelloWorld#enabled=true$DELIMITER+HelloWorld#stackTrace=true
451                 $SOURCEsettings=user.jfc$DELIMITERcom.example.UserDefined#enabled=true
452                 $SOURCEsettings=none$DELIMITER+Hello#enabled=true
453 
454                Note, if the default event settings are modified, overhead may exceed 1%.
455 
456                &quot;&quot;&quot;;
457     }
458 
459     private static String jfcOptions() {
460         try {
461             StringBuilder sb = new StringBuilder();
<span class="line-modified">462             for (Path s : JFC.getPredefined()) {</span>
<span class="line-modified">463                 String name = JFC.nameFromPath(s);</span>
464                 JFCModel model = JFCModel.create(s, l -&gt; {});
465                 sb.append(&#39;\n&#39;);
466                 sb.append(&quot;Options for &quot;).append(name).append(&quot;:\n&quot;);
467                 sb.append(&#39;\n&#39;);
468                 for (XmlInput input : model.getInputs()) {
469                     sb.append(&quot;  &quot;).append(input.getOptionSyntax()).append(&#39;\n&#39;);
470                     sb.append(&#39;\n&#39;);
471                 }
472             }
473             return sb.toString();
474         } catch (IOException | JFCModelException | ParseException  e) {
475             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Could not list .jfc options for JFR.start. &quot; + e.getMessage());
476             return &quot;&quot;;
477         }
478     }
479 
480     @Override
481     public Argument[] getArgumentInfos() {
482         return new Argument[] {
483             new Argument(&quot;name&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="DCmdDump.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DCmdStop.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>