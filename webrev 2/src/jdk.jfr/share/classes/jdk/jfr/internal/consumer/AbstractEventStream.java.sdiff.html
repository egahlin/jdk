<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TypeLibrary.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventDirectoryStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
<span class="line-removed"> 29 import java.security.AccessControlContext;</span>
<span class="line-removed"> 30 import java.security.AccessController;</span>
<span class="line-removed"> 31 import java.security.PrivilegedAction;</span>
 32 import java.time.Duration;
 33 import java.time.Instant;
 34 import java.util.List;
 35 import java.util.Objects;
 36 import java.util.concurrent.CountDownLatch;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.concurrent.atomic.AtomicLong;
 39 import java.util.function.Consumer;
 40 
 41 import jdk.jfr.Configuration;
 42 import jdk.jfr.EventType;
 43 import jdk.jfr.consumer.EventStream;
 44 import jdk.jfr.consumer.MetadataEvent;
 45 import jdk.jfr.consumer.RecordedEvent;
 46 import jdk.jfr.internal.LogLevel;
 47 import jdk.jfr.internal.LogTag;
 48 import jdk.jfr.internal.Logger;
<span class="line-removed"> 49 import jdk.jfr.internal.SecuritySupport;</span>
 50 
 51 /*
 52  * Purpose of this class is to simplify the implementation of
 53  * an event stream.
 54  */
 55 public abstract class AbstractEventStream implements EventStream {
 56     private static final AtomicLong counter = new AtomicLong();
 57 
 58     private final CountDownLatch terminated = new CountDownLatch(1);
 59     private final Runnable flushOperation = () -&gt; dispatcher().runFlushActions();
<span class="line-removed"> 60     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed"> 61     private final AccessControlContext accessControllerContext;</span>
 62     private final StreamConfiguration streamConfiguration = new StreamConfiguration();
 63     private final List&lt;Configuration&gt; configurations;
 64     private final ParserState parserState = new ParserState();
 65     private volatile boolean closeOnComplete = true;
 66     private Dispatcher dispatcher;
 67     private boolean daemon = false;
 68 
 69 
<span class="line-modified"> 70     AbstractEventStream(@SuppressWarnings(&quot;removal&quot;) AccessControlContext acc, List&lt;Configuration&gt; configurations) throws IOException {</span>
<span class="line-removed"> 71         this.accessControllerContext = Objects.requireNonNull(acc);</span>
 72         this.configurations = configurations;
 73     }
 74 
 75     @Override
 76     public abstract void start();
 77 
 78     @Override
 79     public abstract void startAsync();
 80 
 81     @Override
 82     public abstract void close();
 83 
 84     protected final Dispatcher dispatcher() {
 85         if (streamConfiguration.hasChanged()) { // quick check
 86             synchronized (streamConfiguration) {
 87                 dispatcher = new Dispatcher(streamConfiguration);
 88                 streamConfiguration.setChanged(false);
 89                 if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG)) {
 90                     Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, dispatcher.toString());
 91                 }
</pre>
<hr />
<pre>
204     }
205 
206     protected abstract void process() throws IOException;
207 
208     protected abstract boolean isRecordingStream();
209 
210     protected final void closeParser() {
211         parserState.close();
212     }
213 
214     protected final boolean isClosed() {
215         return parserState.isClosed();
216     }
217 
218     protected final ParserState parserState() {
219         return parserState;
220     }
221 
222     public final void startAsync(long startNanos) {
223         startInternal(startNanos);
<span class="line-modified">224         Runnable r = () -&gt; run(accessControllerContext);</span>
<span class="line-modified">225         Thread thread = SecuritySupport.createThreadWitNoPermissions(nextThreadName(), r);</span>
<span class="line-modified">226         SecuritySupport.setDaemonThread(thread, daemon);</span>
227         thread.start();
228     }
229 
230     public final void start(long startNanos) {
231         startInternal(startNanos);
<span class="line-modified">232         run(accessControllerContext);</span>
233     }
234 
235     protected final Runnable getFlushOperation() {
236         return flushOperation;
237     }
238 
<span class="line-removed">239 </span>
240     protected final void onFlush() {
241        Runnable r = getFlushOperation();
242        if (r != null) {
243            r.run();
244        }
245     }
246 
247     private void startInternal(long startNanos) {
248         synchronized (streamConfiguration) {
249             if (streamConfiguration.started) {
250                 throw new IllegalStateException(&quot;Event stream can only be started once&quot;);
251             }
252             if (isRecordingStream() &amp;&amp; streamConfiguration.startTime == null) {
253                 streamConfiguration.setStartNanos(startNanos);
254             }
255             streamConfiguration.setStarted(true);
256         }
257     }
258 
259     private void execute() {
260         try {
261             process();
262         } catch (IOException ioe) {
263             // This can happen if a chunk file is removed, or
264             // a file is access that has been closed
265             // This is &quot;normal&quot; behavior for streaming and the
266             // stream will be closed when this happens.
267         } finally {
268             Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;Execution of stream ended.&quot;);
269             try {
270                 if (closeOnComplete) {
271                     close();
272                 }
273             } finally {
274                 terminated.countDown();
275             }
276         }
277     }
278 
<span class="line-removed">279     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">280     private void run(AccessControlContext accessControlContext) {</span>
<span class="line-removed">281         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-removed">282             @Override</span>
<span class="line-removed">283             public Void run() {</span>
<span class="line-removed">284                 execute();</span>
<span class="line-removed">285                 return null;</span>
<span class="line-removed">286             }</span>
<span class="line-removed">287         }, accessControlContext);</span>
<span class="line-removed">288     }</span>
<span class="line-removed">289 </span>
290     private String nextThreadName() {
291         return &quot;JFR Event Stream &quot; + counter.incrementAndGet();
292     }
293 
294     @Override
295     public void onMetadata(Consumer&lt;MetadataEvent&gt; action) {
296         Objects.requireNonNull(action, &quot;action&quot;);
297         synchronized (streamConfiguration) {
298             if (streamConfiguration.started) {
299                 throw new IllegalStateException(&quot;Stream is already started&quot;);
300             }
301         }
302         streamConfiguration.addMetadataAction(action);
303     }
304 
305     protected final void onMetadata(ChunkParser parser) {
306         if (parser.hasStaleMetadata()) {
307             if (dispatcher.hasMetadataHandler()) {
308                 List&lt;EventType&gt; ce = parser.getEventTypes();
309                 List&lt;EventType&gt; pe = parser.getPreviousEventTypes();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;



 29 import java.time.Duration;
 30 import java.time.Instant;
 31 import java.util.List;
 32 import java.util.Objects;
 33 import java.util.concurrent.CountDownLatch;
 34 import java.util.concurrent.TimeUnit;
 35 import java.util.concurrent.atomic.AtomicLong;
 36 import java.util.function.Consumer;
 37 
 38 import jdk.jfr.Configuration;
 39 import jdk.jfr.EventType;
 40 import jdk.jfr.consumer.EventStream;
 41 import jdk.jfr.consumer.MetadataEvent;
 42 import jdk.jfr.consumer.RecordedEvent;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;

 46 
 47 /*
 48  * Purpose of this class is to simplify the implementation of
 49  * an event stream.
 50  */
 51 public abstract class AbstractEventStream implements EventStream {
 52     private static final AtomicLong counter = new AtomicLong();
 53 
 54     private final CountDownLatch terminated = new CountDownLatch(1);
 55     private final Runnable flushOperation = () -&gt; dispatcher().runFlushActions();


 56     private final StreamConfiguration streamConfiguration = new StreamConfiguration();
 57     private final List&lt;Configuration&gt; configurations;
 58     private final ParserState parserState = new ParserState();
 59     private volatile boolean closeOnComplete = true;
 60     private Dispatcher dispatcher;
 61     private boolean daemon = false;
 62 
 63 
<span class="line-modified"> 64     AbstractEventStream(List&lt;Configuration&gt; configurations) throws IOException {</span>

 65         this.configurations = configurations;
 66     }
 67 
 68     @Override
 69     public abstract void start();
 70 
 71     @Override
 72     public abstract void startAsync();
 73 
 74     @Override
 75     public abstract void close();
 76 
 77     protected final Dispatcher dispatcher() {
 78         if (streamConfiguration.hasChanged()) { // quick check
 79             synchronized (streamConfiguration) {
 80                 dispatcher = new Dispatcher(streamConfiguration);
 81                 streamConfiguration.setChanged(false);
 82                 if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG)) {
 83                     Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, dispatcher.toString());
 84                 }
</pre>
<hr />
<pre>
197     }
198 
199     protected abstract void process() throws IOException;
200 
201     protected abstract boolean isRecordingStream();
202 
203     protected final void closeParser() {
204         parserState.close();
205     }
206 
207     protected final boolean isClosed() {
208         return parserState.isClosed();
209     }
210 
211     protected final ParserState parserState() {
212         return parserState;
213     }
214 
215     public final void startAsync(long startNanos) {
216         startInternal(startNanos);
<span class="line-modified">217         Runnable r = () -&gt; execute();</span>
<span class="line-modified">218         Thread thread = new Thread(r, nextThreadName());</span>
<span class="line-modified">219         thread.setDaemon(daemon);</span>
220         thread.start();
221     }
222 
223     public final void start(long startNanos) {
224         startInternal(startNanos);
<span class="line-modified">225         execute();</span>
226     }
227 
228     protected final Runnable getFlushOperation() {
229         return flushOperation;
230     }
231 

232     protected final void onFlush() {
233        Runnable r = getFlushOperation();
234        if (r != null) {
235            r.run();
236        }
237     }
238 
239     private void startInternal(long startNanos) {
240         synchronized (streamConfiguration) {
241             if (streamConfiguration.started) {
242                 throw new IllegalStateException(&quot;Event stream can only be started once&quot;);
243             }
244             if (isRecordingStream() &amp;&amp; streamConfiguration.startTime == null) {
245                 streamConfiguration.setStartNanos(startNanos);
246             }
247             streamConfiguration.setStarted(true);
248         }
249     }
250 
251     private void execute() {
252         try {
253             process();
254         } catch (IOException ioe) {
255             // This can happen if a chunk file is removed, or
256             // a file is access that has been closed
257             // This is &quot;normal&quot; behavior for streaming and the
258             // stream will be closed when this happens.
259         } finally {
260             Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;Execution of stream ended.&quot;);
261             try {
262                 if (closeOnComplete) {
263                     close();
264                 }
265             } finally {
266                 terminated.countDown();
267             }
268         }
269     }
270 











271     private String nextThreadName() {
272         return &quot;JFR Event Stream &quot; + counter.incrementAndGet();
273     }
274 
275     @Override
276     public void onMetadata(Consumer&lt;MetadataEvent&gt; action) {
277         Objects.requireNonNull(action, &quot;action&quot;);
278         synchronized (streamConfiguration) {
279             if (streamConfiguration.started) {
280                 throw new IllegalStateException(&quot;Stream is already started&quot;);
281             }
282         }
283         streamConfiguration.addMetadataAction(action);
284     }
285 
286     protected final void onMetadata(ChunkParser parser) {
287         if (parser.hasStaleMetadata()) {
288             if (dispatcher.hasMetadataHandler()) {
289                 List&lt;EventType&gt; ce = parser.getEventTypes();
290                 List&lt;EventType&gt; pe = parser.getPreviousEventTypes();
</pre>
</td>
</tr>
</table>
<center><a href="../TypeLibrary.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventDirectoryStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>