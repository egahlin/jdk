<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformRecorder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,15 ***</span>
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.nio.channels.FileChannel;
  import java.nio.file.NoSuchFileException;
  import java.nio.file.StandardOpenOption;
<span class="line-removed">- import java.security.AccessControlContext;</span>
<span class="line-removed">- import java.security.AccessController;</span>
<span class="line-removed">- import java.security.PrivilegedActionException;</span>
<span class="line-removed">- import java.security.PrivilegedExceptionAction;</span>
  import java.time.Duration;
  import java.time.Instant;
  import java.time.LocalDateTime;
  import java.util.ArrayList;
  import java.util.Collections;
<span class="line-new-header">--- 33,12 ---</span>
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.nio.channels.FileChannel;
  import java.nio.file.NoSuchFileException;
<span class="line-added">+ import java.nio.file.Path;</span>
  import java.nio.file.StandardOpenOption;
  import java.time.Duration;
  import java.time.Instant;
  import java.time.LocalDateTime;
  import java.util.ArrayList;
  import java.util.Collections;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,11 ***</span>
  
  import jdk.jfr.Configuration;
  import jdk.jfr.FlightRecorderListener;
  import jdk.jfr.Recording;
  import jdk.jfr.RecordingState;
<span class="line-removed">- import jdk.jfr.internal.SecuritySupport.SafePath;</span>
  import jdk.jfr.internal.util.Utils;
  import jdk.jfr.internal.util.ValueFormatter;
  
  public final class PlatformRecording implements AutoCloseable {
  
<span class="line-new-header">--- 54,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,16 ***</span>
      private Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();
      private Duration duration;
      private Duration maxAge;
      private long maxSize;
  
<span class="line-modified">!     private WriteableUserPath destination;</span>
  
      private boolean toDisk = true;
      private String name;
      private boolean dumpOnExit;
<span class="line-modified">!     private SafePath dumpDirectory;</span>
      // Timestamp information
      private Instant stopTime;
      private Instant startTime;
  
      // Misc, information
<span class="line-new-header">--- 67,16 ---</span>
      private Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();
      private Duration duration;
      private Duration maxAge;
      private long maxSize;
  
<span class="line-modified">!     private WriteablePath destination;</span>
  
      private boolean toDisk = true;
      private String name;
      private boolean dumpOnExit;
<span class="line-modified">!     private Path dumpDirectory;</span>
      // Timestamp information
      private Instant stopTime;
      private Instant startTime;
  
      // Misc, information
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,26 ***</span>
      private long size;
      private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
      private volatile Recording recording;
      private TimerTask stopTask;
      private TimerTask startTask;
<span class="line-removed">-     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">-     private final AccessControlContext dumpDirectoryControlContext;</span>
      private boolean shouldWriteActiveRecordingEvent = true;
      private Duration flushInterval = Duration.ofSeconds(1);
      private long finalStartChunkNanos = Long.MIN_VALUE;
      private long startNanos = -1;
  
      @SuppressWarnings(&quot;removal&quot;)
      PlatformRecording(PlatformRecorder recorder, long id) {
<span class="line-removed">-         // Typically the access control context is taken</span>
<span class="line-removed">-         // when you call dump(Path) or setDestination(Path),</span>
<span class="line-removed">-         // but if no destination is set and the filename is auto-generated,</span>
<span class="line-removed">-         // the control context of the recording is taken when the</span>
<span class="line-removed">-         // Recording object is constructed. This works well for</span>
<span class="line-removed">-         // -XX:StartFlightRecording and JFR.dump</span>
<span class="line-removed">-         this.dumpDirectoryControlContext = AccessController.getContext();</span>
          this.id = id;
          this.recorder = recorder;
          this.name = String.valueOf(id);
      }
  
<span class="line-new-header">--- 84,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,11 ***</span>
              recorder.stop(this);
              String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
              newState = getState();
          }
<span class="line-modified">!         WriteableUserPath dest = getDestination();</span>
          if (dest == null &amp;&amp; dumpDirectory != null) {
              dest = makeDumpPath();
          }
          if (dest != null) {
              try {
<span class="line-new-header">--- 160,11 ---</span>
              recorder.stop(this);
              String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
              newState = getState();
          }
<span class="line-modified">!         WriteablePath dest = getDestination();</span>
          if (dest == null &amp;&amp; dumpDirectory != null) {
              dest = makeDumpPath();
          }
          if (dest != null) {
              try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,34 ***</span>
              notifyIfStateChanged(newState, oldState);
          }
          return true;
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">-     public WriteableUserPath makeDumpPath() {</span>
          try {
              String name = JVMSupport.makeFilename(getRecording());
<span class="line-modified">!             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;WriteableUserPath&gt;() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 public WriteableUserPath run() throws Exception {</span>
<span class="line-removed">-                     SafePath p = dumpDirectory;</span>
<span class="line-removed">-                     if (p == null) {</span>
<span class="line-removed">-                         p = new SafePath(&quot;.&quot;);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     return new WriteableUserPath(p.toPath().resolve(name));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }, dumpDirectoryControlContext);</span>
<span class="line-removed">-         } catch (PrivilegedActionException e) {</span>
<span class="line-removed">-             Throwable t = e.getCause();</span>
<span class="line-removed">-             if (t instanceof SecurityException) {</span>
<span class="line-removed">-                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Not allowed to create dump path for recording &quot; + recording.getId() + &quot; on exit.&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (t instanceof IOException) {</span>
<span class="line-removed">-                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not dump &quot; + recording.getId() + &quot; on exit.&quot;);</span>
              }
<span class="line-modified">!             return null;</span>
          }
      }
  
  
      public void scheduleStart(Duration delay) {
          synchronized (recorder) {
<span class="line-new-header">--- 180,22 ---</span>
              notifyIfStateChanged(newState, oldState);
          }
          return true;
      }
  
<span class="line-modified">!     public WriteablePath makeDumpPath() {</span>
          try {
              String name = JVMSupport.makeFilename(getRecording());
<span class="line-modified">!             Path p = dumpDirectory;</span>
<span class="line-modified">!             if (p == null) {</span>
<span class="line-modified">!                 p = Path.of(&quot;.&quot;);</span>
              }
<span class="line-modified">!             return new WriteablePath(p.resolve(name));</span>
<span class="line-added">+         } catch (IOException e) {</span>
<span class="line-added">+             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not dump &quot; + recording.getId() + &quot; on exit. &quot; + e.getMessage());</span>
          }
<span class="line-added">+         return null;</span>
      }
  
  
      public void scheduleStart(Duration delay) {
          synchronized (recorder) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,26 ***</span>
              this.maxSize = maxSize;
              trimToSize();
          }
      }
  
<span class="line-modified">!     public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>
          synchronized (recorder) {
<span class="line-modified">!             checkSetDestination(userSuppliedPath);</span>
<span class="line-modified">!             this.destination = userSuppliedPath;</span>
          }
      }
  
<span class="line-modified">!     public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>
          synchronized (recorder) {
              if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
                  throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
              }
          }
      }
  
<span class="line-modified">!     public WriteableUserPath getDestination() {</span>
          synchronized (recorder) {
              return destination;
          }
      }
  
<span class="line-new-header">--- 395,28 ---</span>
              this.maxSize = maxSize;
              trimToSize();
          }
      }
  
<span class="line-modified">!     public void setDestination(WriteablePath destination) throws IOException {</span>
          synchronized (recorder) {
<span class="line-modified">!             checkSetDestination(destination);</span>
<span class="line-modified">!             this.destination = destination;</span>
          }
      }
  
<span class="line-modified">!     public void checkSetDestination(WriteablePath writeablePath) throws IOException {</span>
<span class="line-added">+         // The writeablePath argument is not checked. It&#39;s sufficient that an instance has</span>
<span class="line-added">+         // been created.</span>
          synchronized (recorder) {
              if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
                  throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
              }
          }
      }
  
<span class="line-modified">!     public WriteablePath getDestination() {</span>
          synchronized (recorder) {
              return destination;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,12 ***</span>
              @Override
              public void run() {
                  try {
                      stop(&quot;End of duration reached&quot;);
                  } catch (Throwable t) {
<span class="line-modified">!                     // Prevent malicious user to propagate exception callback in the wrong context</span>
<span class="line-removed">-                     Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not stop recording.&quot;);</span>
                  }
              }
          };
      }
  
<span class="line-new-header">--- 682,11 ---</span>
              @Override
              public void run() {
                  try {
                      stop(&quot;End of duration reached&quot;);
                  } catch (Throwable t) {
<span class="line-modified">!                     Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not stop recording. &quot; + t.getMessage());</span>
                  }
              }
          };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,41 ***</span>
      boolean shouldWriteMetadataEvent() {
          return shouldWriteActiveRecordingEvent;
      }
  
      // Dump running and stopped recordings
<span class="line-modified">!     public void dump(WriteableUserPath writeableUserPath) throws IOException {</span>
          synchronized (recorder) {
              try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
<span class="line-modified">!                 p.dumpStopped(writeableUserPath);</span>
              }
          }
      }
  
<span class="line-modified">!     public void dumpStopped(WriteableUserPath userPath) throws IOException {</span>
          synchronized (recorder) {
<span class="line-modified">!             transferChunksWithRetry(userPath);</span>
          }
      }
  
<span class="line-modified">!     private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {</span>
<span class="line-modified">!         userPath.doPrivilegedIO(() -&gt; {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 transferChunks(userPath);</span>
<span class="line-modified">!             } catch (NoSuchFileException nsfe) {</span>
<span class="line-modified">!                 Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Missing chunkfile when writing recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) to &quot; + userPath.getRealPathText() + &quot;.&quot;);</span>
<span class="line-modified">!                 // if one chunkfile was missing, its likely more are missing</span>
<span class="line-modified">!                 removeNonExistantPaths();</span>
<span class="line-modified">!                 // and try the transfer again</span>
<span class="line-modified">!                 transferChunks(userPath);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         });</span>
      }
  
<span class="line-modified">!     private void transferChunks(WriteableUserPath userPath) throws IOException {</span>
<span class="line-modified">!         try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {</span>
              long bytes = cc.transferTo(fc);
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Transferred &quot; + bytes + &quot; bytes from the disk repository&quot;);
              // No need to force if no data was transferred, which avoids IOException when device is /dev/null
              if (bytes != 0) {
                  fc.force(true);
<span class="line-new-header">--- 711,38 ---</span>
      boolean shouldWriteMetadataEvent() {
          return shouldWriteActiveRecordingEvent;
      }
  
      // Dump running and stopped recordings
<span class="line-modified">!     public void dump(WriteablePath writeablePath) throws IOException {</span>
          synchronized (recorder) {
              try(PlatformRecording p = newSnapshotClone(&quot;Dumped by user&quot;, null))  {
<span class="line-modified">!                 p.dumpStopped(writeablePath);</span>
              }
          }
      }
  
<span class="line-modified">!     public void dumpStopped(WriteablePath path) throws IOException {</span>
          synchronized (recorder) {
<span class="line-modified">!             transferChunksWithRetry(path);</span>
          }
      }
  
<span class="line-modified">!     private void transferChunksWithRetry(WriteablePath path) throws IOException {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             transferChunks(path);</span>
<span class="line-modified">!         } catch (NoSuchFileException nsfe) {</span>
<span class="line-modified">!             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Missing chunkfile when writing recording \&quot;&quot; + name + &quot;\&quot; (&quot; + id + &quot;) to &quot; + path.getRealPathText() + &quot;.&quot;);</span>
<span class="line-modified">!             // if one chunkfile was missing, its likely more are missing</span>
<span class="line-modified">!             removeNonExistantPaths();</span>
<span class="line-modified">!             // and try the transfer again</span>
<span class="line-modified">!             transferChunks(path);</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     private void transferChunks(WriteablePath path) throws IOException {</span>
<span class="line-modified">!         try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {</span>
              long bytes = cc.transferTo(fc);
              Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Transferred &quot; + bytes + &quot; bytes from the disk repository&quot;);
              // No need to force if no data was transferred, which avoids IOException when device is /dev/null
              if (bytes != 0) {
                  fc.force(true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,11 ***</span>
      /**
       * Sets the dump directory.
       * &lt;p&gt;
       * Only to be used by DCmdStart.
       */
<span class="line-modified">!     public void setDumpDirectory(SafePath directory) {</span>
         this.dumpDirectory = directory;
      }
  
      public void setFlushInterval(Duration interval) {
          synchronized (recorder) {
<span class="line-new-header">--- 830,11 ---</span>
      /**
       * Sets the dump directory.
       * &lt;p&gt;
       * Only to be used by DCmdStart.
       */
<span class="line-modified">!     public void setDumpDirectory(Path directory) {</span>
         this.dumpDirectory = directory;
      }
  
      public void setFlushInterval(Duration interval) {
          synchronized (recorder) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,11 ***</span>
              }
          }
  
      }
  
<span class="line-modified">!     public void removePath(SafePath path) {</span>
          synchronized (recorder) {
              Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
              while (it.hasNext()) {
                  RepositoryChunk c = it.next();
                  if (c.getFile().equals(path)) {
<span class="line-new-header">--- 884,11 ---</span>
              }
          }
  
      }
  
<span class="line-modified">!     public void removePath(Path path) {</span>
          synchronized (recorder) {
              Iterator&lt;RepositoryChunk&gt; it = chunks.iterator();
              while (it.hasNext()) {
                  RepositoryChunk c = it.next();
                  if (c.getFile().equals(path)) {
</pre>
<center><a href="PlatformRecorder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PrivateAccess.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>