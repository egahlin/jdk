diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,10 +26,11 @@
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.file.DirectoryIteratorException;
 import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.attribute.FileTime;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -43,11 +44,10 @@
 
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.management.HiddenWait;;
 
 public final class RepositoryFiles {
     private static final HiddenWait WAIT_OBJECT = new HiddenWait();
     private static final String DIRECTORY_PATTERN = "DDDD_DD_DD_DD_DD_DD_";
@@ -55,21 +55,19 @@
         synchronized (WAIT_OBJECT) {
             WAIT_OBJECT.notifyAll();
         }
     }
 
-    private final FileAccess fileAccess;
     private final NavigableMap<Long, Path> pathSet = new TreeMap<>();
     private final Map<Path, Long> pathLookup = new HashMap<>();
     private final HiddenWait waitObject;
     private boolean allowSubDirectory;
     private volatile boolean closed;
     private Path repository;
 
-    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {
+    public RepositoryFiles(Path repository, boolean allowSubDirectory) {
         this.repository = repository;
-        this.fileAccess = fileAccess;
         this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();
         this.allowSubDirectory = allowSubDirectory;
     }
 
     long getTimestamp(Path p) {
@@ -170,18 +168,18 @@
         }
 
         if (repoPath == null) {
             // Always get the latest repository if 'jcmd JFR.configure
             // repositorypath=...' has been executed
-            SafePath sf = Repository.getRepository().getRepositoryPath();
-            if (sf == null) {
+            Path path = Repository.getRepository().getRepositoryPath();
+            if (path == null) {
                 return false; // not initialized
             }
-            repoPath = sf.toPath();
+            repoPath = path;
         }
 
-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {
+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {
             List<Path> added = new ArrayList<>();
             Set<Path> current = new HashSet<>();
             for (Path p : dirStream) {
                 if (!pathLookup.containsKey(p)) {
                     String s = p.toString();
@@ -206,11 +204,11 @@
             }
             Collections.sort(added);
             for (Path p : added) {
                 // Only add files that have a complete header
                 // as the JVM may be in progress writing the file
-                long size = fileAccess.fileSize(p);
+                long size = Files.size(p);
                 if (size >= ChunkHeader.headerSize()) {
                     long startNanos = readStartTime(p);
                     if (startNanos != -1) {
                         pathSet.put(startNanos, p);
                         pathLookup.put(p, startNanos);
@@ -230,14 +228,14 @@
     }
 
     private Path findSubDirectory(Path repoPath) {
         FileTime latestTimestamp = null;
         Path latestPath = null;
-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {
+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {
             for (Path p : dirStream) {
                 String filename = p.getFileName().toString();
-                if (isRepository(filename) && fileAccess.isDirectory(p)) {
+                if (isRepository(filename) && Files.isDirectory(p)) {
                     FileTime timestamp = getLastModified(p);
                     if (timestamp != null) {
                         if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {
                             latestPath = p;
                             latestTimestamp = timestamp;
@@ -251,11 +249,11 @@
         return latestPath;
     }
 
     private FileTime getLastModified(Path p) {
         try {
-            return fileAccess.getLastModified(p);
+            return Files.getLastModifiedTime(p);
         } catch (IOException e) {
             return null;
         }
     }
 
@@ -275,11 +273,11 @@
         }
         return true;
     }
 
     private long readStartTime(Path p) {
-        try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {
+        try (RecordingInput in = new RecordingInput(p.toFile(), 100)) {
             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, "Parsing header for chunk start time");
             ChunkHeader c = new ChunkHeader(in);
             return c.getStartNanos();
         } catch (IOException ioe) {
             return -1;
