diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,16 +25,14 @@
 
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.file.Path;
-import java.security.AccessControlContext;
 import java.time.Instant;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 
 import jdk.jfr.Configuration;
 import jdk.jfr.RecordingState;
@@ -42,11 +40,10 @@
 import jdk.jfr.internal.JVM;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.PlatformRecording;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.management.StreamBarrier;
 
 /**
  * Implementation of an {@code EventStream}} that operates against a directory
@@ -56,35 +53,27 @@
 public final class EventDirectoryStream extends AbstractEventStream {
 
     private static final Comparator<? super RecordedEvent> EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 
     private final RepositoryFiles repositoryFiles;
-    private final FileAccess fileAccess;
     private final PlatformRecording recording;
     private final StreamBarrier barrier = new StreamBarrier();
     private final AtomicLong streamId = new AtomicLong();
     private ChunkParser currentParser;
     private long currentChunkStartNanos;
     private RecordedEvent[] sortedCache;
     private int threadExclusionLevel = 0;
     private volatile Consumer<Long> onCompleteHandler;
 
     public EventDirectoryStream(
-            @SuppressWarnings("removal")
-            AccessControlContext acc,
             Path p,
-            FileAccess fileAccess,
             PlatformRecording recording,
             List<Configuration> configurations,
             boolean allowSubDirectories) throws IOException {
-        super(acc, configurations);
+        super(configurations);
         this.recording = recording;
-        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {
-            throw new SecurityException("Priviliged file access not allowed with potentially malicious Path implementation");
-        }
-        this.fileAccess = Objects.requireNonNull(fileAccess);
-        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);
+        this.repositoryFiles = new RepositoryFiles(p, allowSubDirectories);
         this.streamId.incrementAndGet();
         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, "Stream " + streamId + " started.");
     }
 
     @Override
@@ -151,11 +140,11 @@
         if (path == null) { // closed
             logStreamEnd("no first chunk file found.");
             return;
         }
         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
-        try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {
+        try (RecordingInput input = new RecordingInput(path.toFile())) {
             input.setStreamed();
             currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
             long filterStart = validStartTime ? disp.startNanos : segmentStart;
             long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
