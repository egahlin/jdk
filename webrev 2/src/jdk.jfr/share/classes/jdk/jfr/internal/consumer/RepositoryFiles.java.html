<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.DirectoryIteratorException;
 30 import java.nio.file.DirectoryStream;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.attribute.FileTime;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.NavigableMap;
 41 import java.util.Set;
 42 import java.util.SortedMap;
 43 import java.util.TreeMap;
 44 
 45 import jdk.jfr.internal.LogLevel;
 46 import jdk.jfr.internal.LogTag;
 47 import jdk.jfr.internal.Logger;
 48 import jdk.jfr.internal.Repository;
 49 import jdk.jfr.internal.management.HiddenWait;;
 50 
 51 public final class RepositoryFiles {
 52     private static final HiddenWait WAIT_OBJECT = new HiddenWait();
 53     private static final String DIRECTORY_PATTERN = &quot;DDDD_DD_DD_DD_DD_DD_&quot;;
 54     public static void notifyNewFile() {
 55         synchronized (WAIT_OBJECT) {
 56             WAIT_OBJECT.notifyAll();
 57         }
 58     }
 59 
 60     private final NavigableMap&lt;Long, Path&gt; pathSet = new TreeMap&lt;&gt;();
 61     private final Map&lt;Path, Long&gt; pathLookup = new HashMap&lt;&gt;();
 62     private final HiddenWait waitObject;
 63     private boolean allowSubDirectory;
 64     private volatile boolean closed;
 65     private Path repository;
 66 
 67     public RepositoryFiles(Path repository, boolean allowSubDirectory) {
 68         this.repository = repository;
 69         this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();
 70         this.allowSubDirectory = allowSubDirectory;
 71     }
 72 
 73     long getTimestamp(Path p) {
 74         return pathLookup.get(p);
 75     }
 76 
 77     public Path lastPath(boolean wait) {
 78         if (updatePaths(wait)) {
 79             return pathSet.lastEntry().getValue();
 80         }
 81         return null; // closed
 82     }
 83 
 84     public Path firstPath(long startTimeNanos, boolean wait) {
 85         if (updatePaths(wait)) {
 86             // Pick closest chunk before timestamp
 87             Long time = pathSet.floorKey(startTimeNanos);
 88             if (time != null) {
 89                 startTimeNanos = time;
 90             }
 91             return path(startTimeNanos, wait);
 92         }
 93         return null; // closed
 94     }
 95 
 96     private boolean updatePaths(boolean wait) {
 97         int beforeSize = pathLookup.size();
 98         while (!closed) {
 99             try {
100                 if (updatePaths()) {
101                     break;
102                 }
103             } catch (IOException | DirectoryIteratorException e) {
104                 Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;Exception during repository file scan &quot; + e.getMessage());
105                 // This can happen if a chunk is being removed
106                 // between the file was discovered and an instance
107                 // was accessed. Just ignore, and retry later.
108             }
109             if (wait) {
110                 waitObject.takeNap(1000);
111             } else {
112                 return pathLookup.size() &gt; beforeSize;
113             }
114         }
115         return !closed;
116     }
117 
118     public Path nextPath(long startTimeNanos, boolean wait) {
119         if (closed) {
120             return null;
121         }
122         // Try to get the &#39;exact&#39; path first
123         // to avoid skipping files if repository
124         // is updated while DirectoryStream
125         // is traversing it
126         Path path = pathSet.get(startTimeNanos);
127         if (path != null) {
128             return path;
129         }
130         // Update paths
131         try {
132             updatePaths();
133         } catch (IOException | DirectoryIteratorException e) {
134             // ignore
135         }
136         // try to get the next file
137         return path(startTimeNanos, wait);
138     }
139 
140     private Path path(long timestamp, boolean wait) {
141         if (closed) {
142             return null;
143         }
144         while (true) {
145             SortedMap&lt;Long, Path&gt; after = pathSet.tailMap(timestamp);
146             if (!after.isEmpty()) {
147                 Path path = after.get(after.firstKey());
148                 if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE)) {
149                     Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE, &quot;Return path &quot; + path + &quot; for start time nanos &quot; + timestamp);
150                 }
151                 return path;
152             }
153             if (!updatePaths(wait)) {
154                 return null; // closed
155             }
156         }
157     }
158 
159     private boolean updatePaths() throws IOException, DirectoryIteratorException {
160         boolean foundNew = false;
161         Path repoPath = repository;
162 
163         if (allowSubDirectory) {
164             Path subDirectory = findSubDirectory(repoPath);
165             if (subDirectory != null) {
166                 repoPath = subDirectory;
167             }
168         }
169 
170         if (repoPath == null) {
171             // Always get the latest repository if &#39;jcmd JFR.configure
172             // repositorypath=...&#39; has been executed
173             Path path = Repository.getRepository().getRepositoryPath();
174             if (path == null) {
175                 return false; // not initialized
176             }
177             repoPath = path;
178         }
179 
180         try (DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(repoPath)) {
181             List&lt;Path&gt; added = new ArrayList&lt;&gt;();
182             Set&lt;Path&gt; current = new HashSet&lt;&gt;();
183             for (Path p : dirStream) {
184                 if (!pathLookup.containsKey(p)) {
185                     String s = p.toString();
186                     if (s.endsWith(&quot;.jfr&quot;)) {
187                         added.add(p);
188                         Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;New file found: &quot; + p.toAbsolutePath());
189                     }
190                     current.add(p);
191                 }
192             }
193             List&lt;Path&gt; removed = new ArrayList&lt;&gt;();
194             for (Path p : pathLookup.keySet()) {
195                 if (!current.contains(p)) {
196                     removed.add(p);
197                 }
198             }
199 
200             for (Path remove : removed) {
201                 Long time = pathLookup.get(remove);
202                 pathSet.remove(time);
203                 pathLookup.remove(remove);
204             }
205             Collections.sort(added);
206             for (Path p : added) {
207                 // Only add files that have a complete header
208                 // as the JVM may be in progress writing the file
209                 long size = Files.size(p);
210                 if (size &gt;= ChunkHeader.headerSize()) {
211                     long startNanos = readStartTime(p);
212                     if (startNanos != -1) {
213                         pathSet.put(startNanos, p);
214                         pathLookup.put(p, startNanos);
215                         foundNew = true;
216                     }
217                 }
218             }
219             if (allowSubDirectory &amp;&amp; foundNew) {
220                 // Found a valid file, possibly in a subdirectory.
221                 // Use the same (sub)directory from now on.
222                 repository = repoPath;
223                 allowSubDirectory = false;
224             }
225 
226             return foundNew;
227         }
228     }
229 
230     private Path findSubDirectory(Path repoPath) {
231         FileTime latestTimestamp = null;
232         Path latestPath = null;
233         try (DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(repoPath)) {
234             for (Path p : dirStream) {
235                 String filename = p.getFileName().toString();
236                 if (isRepository(filename) &amp;&amp; Files.isDirectory(p)) {
237                     FileTime timestamp = getLastModified(p);
238                     if (timestamp != null) {
239                         if (latestPath == null || latestTimestamp.compareTo(timestamp) &lt;= 0) {
240                             latestPath = p;
241                             latestTimestamp = timestamp;
242                         }
243                     }
244                 }
245             }
246         } catch (IOException | DirectoryIteratorException e) {
247             // Ignore
248         }
249         return latestPath;
250     }
251 
252     private FileTime getLastModified(Path p) {
253         try {
254             return Files.getLastModifiedTime(p);
255         } catch (IOException e) {
256             return null;
257         }
258     }
259 
260     private static boolean isRepository(String filename) {
261         if (filename.length() &lt; DIRECTORY_PATTERN.length()) {
262             return false;
263         }
264         for (int i = 0; i &lt; DIRECTORY_PATTERN.length(); i++) {
265             char expected = DIRECTORY_PATTERN.charAt(i);
266             char c = filename.charAt(i);
267             if (expected == &#39;D&#39; &amp;&amp; !Character.isDigit(c)) {
268                 return false;
269             }
270             if (expected == &#39;_&#39; &amp;&amp; c != &#39;_&#39;) {
271                 return false;
272             }
273         }
274         return true;
275     }
276 
277     private long readStartTime(Path p) {
278         try (RecordingInput in = new RecordingInput(p.toFile(), 100)) {
279             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Parsing header for chunk start time&quot;);
280             ChunkHeader c = new ChunkHeader(in);
281             return c.getStartNanos();
282         } catch (IOException ioe) {
283             return -1;
284         }
285     }
286 
287     void close() {
288         synchronized (waitObject) {
289             this.closed = true;
290             waitObject.notify();
291         }
292     }
293 
294     public boolean hasFixedPath() {
295         return repository != null;
296     }
297 }
    </pre>
  </body>
</html>