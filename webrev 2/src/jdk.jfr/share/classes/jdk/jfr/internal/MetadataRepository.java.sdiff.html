<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MetadataLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Options.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
106                 eventTypes.add(ec.getEventType());
107             }
108         }
109         for (EventType t : nativeEventTypes.values()) {
110             if (PrivateAccess.getInstance().isVisible(t)) {
111                 eventTypes.add(t);
112             }
113         }
114         return eventTypes;
115     }
116 
117     public synchronized EventType getEventType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
118         EventConfiguration ec = getConfiguration(eventClass, false);
119         if (ec != null &amp;&amp; ec.isRegistered()) {
120             return ec.getEventType();
121         }
122         throw new IllegalStateException(&quot;Event class &quot; + eventClass.getName() + &quot; is not registered&quot;);
123     }
124 
125     public synchronized void unregister(Class&lt;? extends Event&gt; eventClass) {
<span class="line-removed">126         SecuritySupport.checkRegisterPermission();</span>
127         EventConfiguration configuration = getConfiguration(eventClass, false);
128         if (configuration != null) {
129             configuration.getPlatformEventType().setRegistered(false);
130         }
131         // never registered, ignore call
132     }
133     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
134         return register(eventClass, Collections.emptyList(), Collections.emptyList());
135     }
136 
137     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) {
<span class="line-removed">138         SecuritySupport.checkRegisterPermission();</span>
139         if (JVM.isExcluded(eventClass)) {
140             // Event classes are marked as excluded during class load
141             // if they override methods in the jdk.jfr.Event class, i.e. commit().
142             // An excluded class lacks a configuration field and can&#39;t be used by JFR.
143             // The Event::commit() is marked as final, so javac won&#39;t
144             // compile an override, but it can be constructed by other means.
145             throw new IllegalArgumentException(&quot;Must not override methods declared in jdk.jfr.Event&quot;);
146         }
147         EventConfiguration configuration = getConfiguration(eventClass, true);
148         if (configuration == null) {
149             PlatformEventType pe = findMirrorType(eventClass);
150             configuration = makeConfiguration(eventClass, pe, dynamicAnnotations, dynamicFields);
151         }
152         configuration.getPlatformEventType().setRegistered(true);
153         TypeLibrary.addType(configuration.getPlatformEventType());
154         if (JVM.isRecording()) {
155             settingsManager.setEventControl(configuration.getEventControl(), true, JVM.counterTime());
156             settingsManager.updateRetransform(Collections.singletonList((eventClass)));
157        }
158        setStaleMetadata();
</pre>
<hr />
<pre>
169         TypeLibrary.removeType(et.getId());
170         long id = Type.getTypeId(eventClass);
171         et.setId(id);
172         return et;
173     }
174 
175     private EventConfiguration getConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, boolean ensureInitialized) {
176         Utils.ensureValidEventSubclass(eventClass);
177         SecuritySupport.makeVisibleToJFR(eventClass);
178         if (ensureInitialized) {
179             Utils.ensureInitialized(eventClass);
180         }
181         return JVMSupport.getConfiguration(eventClass);
182     }
183 
184     private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {
185         try {
186             if (cachedEventConfigurationConstructor == null) {
187                 var argClasses = new Class&lt;?&gt;[] { EventType.class, EventControl.class};
188                 Constructor&lt;EventConfiguration&gt; c = EventConfiguration.class.getDeclaredConstructor(argClasses);
<span class="line-modified">189                 SecuritySupport.setAccessible(c);</span>
190                 cachedEventConfigurationConstructor = c;
191             }
192             return cachedEventConfigurationConstructor.newInstance(eventType, ec);
193         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
194             throw new InternalError(e);
195         }
196     }
197 
198     private EventConfiguration makeConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, PlatformEventType pEventType, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) throws InternalError {
199         SecuritySupport.addInternalEventExport(eventClass);
200         if (pEventType == null) {
201             pEventType = (PlatformEventType) TypeLibrary.createType(eventClass, dynamicAnnotations, dynamicFields);
202         }
203         // Check for native mirror.
204         // Note, defining an event in metadata.xml is not a generic mechanism to emit
205         // native data in Java. For example, calling JVM.getStackTraceId(int, long)
206         // and assign the result to a long field is not enough to always get a proper
207         // stack trace. Purpose of the mechanism is to transfer metadata, such as
208         // native type IDs, without specialized Java logic for each type.
209         if (Utils.isJDKClass(eventClass)) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
106                 eventTypes.add(ec.getEventType());
107             }
108         }
109         for (EventType t : nativeEventTypes.values()) {
110             if (PrivateAccess.getInstance().isVisible(t)) {
111                 eventTypes.add(t);
112             }
113         }
114         return eventTypes;
115     }
116 
117     public synchronized EventType getEventType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
118         EventConfiguration ec = getConfiguration(eventClass, false);
119         if (ec != null &amp;&amp; ec.isRegistered()) {
120             return ec.getEventType();
121         }
122         throw new IllegalStateException(&quot;Event class &quot; + eventClass.getName() + &quot; is not registered&quot;);
123     }
124 
125     public synchronized void unregister(Class&lt;? extends Event&gt; eventClass) {

126         EventConfiguration configuration = getConfiguration(eventClass, false);
127         if (configuration != null) {
128             configuration.getPlatformEventType().setRegistered(false);
129         }
130         // never registered, ignore call
131     }
132     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
133         return register(eventClass, Collections.emptyList(), Collections.emptyList());
134     }
135 
136     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) {

137         if (JVM.isExcluded(eventClass)) {
138             // Event classes are marked as excluded during class load
139             // if they override methods in the jdk.jfr.Event class, i.e. commit().
140             // An excluded class lacks a configuration field and can&#39;t be used by JFR.
141             // The Event::commit() is marked as final, so javac won&#39;t
142             // compile an override, but it can be constructed by other means.
143             throw new IllegalArgumentException(&quot;Must not override methods declared in jdk.jfr.Event&quot;);
144         }
145         EventConfiguration configuration = getConfiguration(eventClass, true);
146         if (configuration == null) {
147             PlatformEventType pe = findMirrorType(eventClass);
148             configuration = makeConfiguration(eventClass, pe, dynamicAnnotations, dynamicFields);
149         }
150         configuration.getPlatformEventType().setRegistered(true);
151         TypeLibrary.addType(configuration.getPlatformEventType());
152         if (JVM.isRecording()) {
153             settingsManager.setEventControl(configuration.getEventControl(), true, JVM.counterTime());
154             settingsManager.updateRetransform(Collections.singletonList((eventClass)));
155        }
156        setStaleMetadata();
</pre>
<hr />
<pre>
167         TypeLibrary.removeType(et.getId());
168         long id = Type.getTypeId(eventClass);
169         et.setId(id);
170         return et;
171     }
172 
173     private EventConfiguration getConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, boolean ensureInitialized) {
174         Utils.ensureValidEventSubclass(eventClass);
175         SecuritySupport.makeVisibleToJFR(eventClass);
176         if (ensureInitialized) {
177             Utils.ensureInitialized(eventClass);
178         }
179         return JVMSupport.getConfiguration(eventClass);
180     }
181 
182     private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {
183         try {
184             if (cachedEventConfigurationConstructor == null) {
185                 var argClasses = new Class&lt;?&gt;[] { EventType.class, EventControl.class};
186                 Constructor&lt;EventConfiguration&gt; c = EventConfiguration.class.getDeclaredConstructor(argClasses);
<span class="line-modified">187                 c.setAccessible(true);</span>
188                 cachedEventConfigurationConstructor = c;
189             }
190             return cachedEventConfigurationConstructor.newInstance(eventType, ec);
191         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
192             throw new InternalError(e);
193         }
194     }
195 
196     private EventConfiguration makeConfiguration(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, PlatformEventType pEventType, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) throws InternalError {
197         SecuritySupport.addInternalEventExport(eventClass);
198         if (pEventType == null) {
199             pEventType = (PlatformEventType) TypeLibrary.createType(eventClass, dynamicAnnotations, dynamicFields);
200         }
201         // Check for native mirror.
202         // Note, defining an event in metadata.xml is not a generic mechanism to emit
203         // native data in Java. For example, calling JVM.getStackTraceId(int, long)
204         // and assign the result to a long field is not enough to always get a proper
205         // stack trace. Purpose of the mechanism is to transfer metadata, such as
206         // native type IDs, without specialized Java logic for each type.
207         if (Utils.isJDKClass(eventClass)) {
</pre>
</td>
</tr>
</table>
<center><a href="MetadataLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Options.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>