<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventControl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FilePurger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 72 
 73 /**
 74  * Class responsible for adding instrumentation to a subclass of {@link Event}.
 75  *
 76  */
 77 final class EventInstrumentation {
 78 
 79     private record SettingDesc(ClassDesc paramType, String methodName) {
 80     }
 81 
 82     private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, ImplicitFields.DURATION);
 83     private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, &quot;eventConfiguration&quot;);;
 84     private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, ImplicitFields.START_TIME);
 85     private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);
 86     private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);
 87     private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);
 88     private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);
 89     private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);
 90     private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);
 91     private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);
<span class="line-removed"> 92     private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of(&quot;jdk.jfr.internal.event.EventWriterFactory&quot;);</span>
 93     private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);
 94     private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);
 95     private static final MethodDesc METHOD_BEGIN = MethodDesc.of(&quot;begin&quot;, &quot;()V&quot;);
 96     private static final MethodDesc METHOD_COMMIT = MethodDesc.of(&quot;commit&quot;, &quot;()V&quot;);
 97     private static final MethodDesc METHOD_DURATION = MethodDesc.of(&quot;duration&quot;, &quot;(J)J&quot;);
 98     private static final MethodDesc METHOD_ENABLED = MethodDesc.of(&quot;enabled&quot;, &quot;()Z&quot;);
 99     private static final MethodDesc METHOD_END = MethodDesc.of(&quot;end&quot;, &quot;()V&quot;);
100     private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
101     private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(&quot;getSetting&quot;, SettingControl.class, int.class);
102     private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;()Z&quot;);
<span class="line-modified">103     private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of(&quot;getEventWriter&quot;, &quot;(J)&quot; + TYPE_EVENT_WRITER.descriptorString());</span>
104     private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(&quot;isEnabled&quot;, &quot;()Z&quot;);
105     private static final MethodDesc METHOD_RESET = MethodDesc.of(&quot;reset&quot;, &quot;()V&quot;);
106     private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
107     private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(&quot;timestamp&quot;, &quot;()J&quot;);
108 
109     private final ClassModel classModel;
110     private final List&lt;SettingDesc&gt; settingDescs;
111     private final List&lt;FieldDesc&gt; fieldDescs;;
112     private final String eventName;
113     private final String className;
114     private final Class&lt;?&gt; superClass;
115     private final boolean untypedEventConfiguration;
116     private final MethodDesc staticCommitMethod;
117     private final long eventTypeId;
118     private final boolean guardEventConfiguration;
119     private final boolean isJDK;
120     private final Map&lt;MethodDesc, Consumer&lt;CodeBuilder&gt;&gt; methodUpdates = new LinkedHashMap&lt;&gt;();
121     private final ImplicitFields implicitFields;
122 
123     EventInstrumentation(Class&lt;?&gt; superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {
</pre>
<hr />
<pre>
750             }
751         });
752     }
753 
754     private void updateIfStaticMethodExists(MethodDesc method, Consumer&lt;CodeBuilder&gt; code) {
755         if (hasStaticMethod(method)) {
756             updateMethod(method, code);
757         }
758     }
759 
760     private boolean hasStaticMethod(MethodDesc method) {
761         for (MethodModel m : classModel.methods()) {
762             if (m.methodName().equalsString(method.name()) &amp;&amp; m.methodTypeSymbol().equals(method.descriptor())) {
763                 return Modifier.isStatic(m.flags().flagsMask());
764             }
765         }
766         return false;
767     }
768 
769     private void getEventWriter(CodeBuilder codeBuilder) {
<span class="line-modified">770         codeBuilder.ldc(EventWriterKey.getKey());</span>
<span class="line-removed">771         invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);</span>
772     }
773 
774     private void getEventConfiguration(CodeBuilder codeBuilder) {
775         if (untypedEventConfiguration) {
776             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);
777             codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);
778         } else {
779             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);
780         }
781     }
782 
783     private void makeUninstrumented() {
784         updateExistingWithReturnFalse(METHOD_EVENT_SHOULD_COMMIT);
785         updateExistingWithReturnFalse(METHOD_IS_ENABLED);
786         updateExistingWithEmptyVoidMethod(METHOD_COMMIT);
787         if (staticCommitMethod != null) {
788             updateExistingWithEmptyVoidMethod(staticCommitMethod);
789         }
790         updateExistingWithEmptyVoidMethod(METHOD_BEGIN);
791         updateExistingWithEmptyVoidMethod(METHOD_END);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 72 
 73 /**
 74  * Class responsible for adding instrumentation to a subclass of {@link Event}.
 75  *
 76  */
 77 final class EventInstrumentation {
 78 
 79     private record SettingDesc(ClassDesc paramType, String methodName) {
 80     }
 81 
 82     private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, ImplicitFields.DURATION);
 83     private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, &quot;eventConfiguration&quot;);;
 84     private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, ImplicitFields.START_TIME);
 85     private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);
 86     private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);
 87     private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);
 88     private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);
 89     private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);
 90     private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);
 91     private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);

 92     private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);
 93     private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);
 94     private static final MethodDesc METHOD_BEGIN = MethodDesc.of(&quot;begin&quot;, &quot;()V&quot;);
 95     private static final MethodDesc METHOD_COMMIT = MethodDesc.of(&quot;commit&quot;, &quot;()V&quot;);
 96     private static final MethodDesc METHOD_DURATION = MethodDesc.of(&quot;duration&quot;, &quot;(J)J&quot;);
 97     private static final MethodDesc METHOD_ENABLED = MethodDesc.of(&quot;enabled&quot;, &quot;()Z&quot;);
 98     private static final MethodDesc METHOD_END = MethodDesc.of(&quot;end&quot;, &quot;()V&quot;);
 99     private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
100     private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(&quot;getSetting&quot;, SettingControl.class, int.class);
101     private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;()Z&quot;);
<span class="line-modified">102     private static final MethodDesc METHOD_GET_EVENT_WRITER = MethodDesc.of(&quot;getEventWriter&quot;, &quot;()&quot; + TYPE_EVENT_WRITER.descriptorString());</span>
103     private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(&quot;isEnabled&quot;, &quot;()Z&quot;);
104     private static final MethodDesc METHOD_RESET = MethodDesc.of(&quot;reset&quot;, &quot;()V&quot;);
105     private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
106     private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(&quot;timestamp&quot;, &quot;()J&quot;);
107 
108     private final ClassModel classModel;
109     private final List&lt;SettingDesc&gt; settingDescs;
110     private final List&lt;FieldDesc&gt; fieldDescs;;
111     private final String eventName;
112     private final String className;
113     private final Class&lt;?&gt; superClass;
114     private final boolean untypedEventConfiguration;
115     private final MethodDesc staticCommitMethod;
116     private final long eventTypeId;
117     private final boolean guardEventConfiguration;
118     private final boolean isJDK;
119     private final Map&lt;MethodDesc, Consumer&lt;CodeBuilder&gt;&gt; methodUpdates = new LinkedHashMap&lt;&gt;();
120     private final ImplicitFields implicitFields;
121 
122     EventInstrumentation(Class&lt;?&gt; superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {
</pre>
<hr />
<pre>
749             }
750         });
751     }
752 
753     private void updateIfStaticMethodExists(MethodDesc method, Consumer&lt;CodeBuilder&gt; code) {
754         if (hasStaticMethod(method)) {
755             updateMethod(method, code);
756         }
757     }
758 
759     private boolean hasStaticMethod(MethodDesc method) {
760         for (MethodModel m : classModel.methods()) {
761             if (m.methodName().equalsString(method.name()) &amp;&amp; m.methodTypeSymbol().equals(method.descriptor())) {
762                 return Modifier.isStatic(m.flags().flagsMask());
763             }
764         }
765         return false;
766     }
767 
768     private void getEventWriter(CodeBuilder codeBuilder) {
<span class="line-modified">769         invokestatic(codeBuilder, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);</span>

770     }
771 
772     private void getEventConfiguration(CodeBuilder codeBuilder) {
773         if (untypedEventConfiguration) {
774             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);
775             codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);
776         } else {
777             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);
778         }
779     }
780 
781     private void makeUninstrumented() {
782         updateExistingWithReturnFalse(METHOD_EVENT_SHOULD_COMMIT);
783         updateExistingWithReturnFalse(METHOD_IS_ENABLED);
784         updateExistingWithEmptyVoidMethod(METHOD_COMMIT);
785         if (staticCommitMethod != null) {
786             updateExistingWithEmptyVoidMethod(staticCommitMethod);
787         }
788         updateExistingWithEmptyVoidMethod(METHOD_BEGIN);
789         updateExistingWithEmptyVoidMethod(METHOD_END);
</pre>
</td>
</tr>
</table>
<center><a href="EventControl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FilePurger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>