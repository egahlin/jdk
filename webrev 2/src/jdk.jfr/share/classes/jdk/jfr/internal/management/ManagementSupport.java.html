<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.management;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.util.Collections;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.function.Consumer;
 37 import jdk.jfr.Configuration;
 38 import jdk.jfr.EventSettings;
 39 import jdk.jfr.EventType;
 40 import jdk.jfr.Recording;
 41 import jdk.jfr.consumer.EventStream;
 42 import jdk.jfr.internal.JDKEvents;
 43 import jdk.jfr.internal.JVMSupport;
 44 import jdk.jfr.internal.LogLevel;
 45 import jdk.jfr.internal.LogTag;
 46 import jdk.jfr.internal.Logger;
 47 import jdk.jfr.internal.MetadataRepository;
 48 import jdk.jfr.internal.PlatformRecording;
 49 import jdk.jfr.internal.PrivateAccess;
 50 import jdk.jfr.internal.util.Utils;
 51 import jdk.jfr.internal.util.ValueFormatter;
 52 import jdk.jfr.internal.util.ValueParser;
 53 import jdk.jfr.internal.WriteablePath;
 54 import jdk.jfr.internal.consumer.AbstractEventStream;
 55 import jdk.jfr.internal.consumer.EventDirectoryStream;
 56 
 57 /**
 58  * The management API in module jdk.management.jfr should be built on top of the
 59  * public API in jdk.jfr. Before putting more functionality here, consider if it
 60  * should not be part of the public API, and if not, please provide motivation
 61  *
 62  */
 63 public final class ManagementSupport {
 64 
 65     // Purpose of this method is to expose the event types to the
 66     // FlightRecorderMXBean without instantiating Flight Recorder.
 67     //
 68     // This allows:
 69     //
 70     // 1) discoverability, so event settings can be exposed without the need to
 71     // create a new Recording in FlightRecorderMXBean.
 72     //
 73     // 2) a graphical JMX client to list all attributes to the user, without
 74     // loading JFR memory buffers. This is especially important when there is
 75     // no intent to use Flight Recorder.
 76     //
 77     // An alternative design would be to make FlightRecorder#getEventTypes
 78     // static, but it would the make the API look strange
 79     //
 80     public static List&lt;EventType&gt; getEventTypes() {
 81         // would normally be checked when a Flight Recorder instance is created
 82         if (JVMSupport.isNotAvailable()) {
 83             return List.of();
 84         }
 85         JDKEvents.initialize(); // make sure JDK events are available
 86         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
 87     }
 88 
 89     // Reuse internal code for parsing a timespan
 90     public static long parseTimespan(String s) {
 91         return ValueParser.parseTimespan(s);
 92     }
 93 
 94     // Reuse internal code for converting nanoseconds since epoch to Instant
 95     public static Instant epochNanosToInstant(long epochNanos) {
 96       return Utils.epochNanosToInstant(epochNanos);
 97     }
 98 
 99     // Reuse internal code for formatting settings
100     public static final String formatTimespan(Duration dValue, String separation) {
101         return ValueFormatter.formatTimespan(dValue, separation);
102     }
103 
104     // Reuse internal logging mechanism
105     public static void logError(String message) {
106         Logger.log(LogTag.JFR, LogLevel.ERROR, message);
107     }
108 
109     // Reuse internal logging mechanism
110     public static void logDebug(String message) {
111         Logger.log(LogTag.JFR, LogLevel.DEBUG, message);
112     }
113 
114     // Get the textual representation when the destination was set, which
115     // requires access to jdk.jfr.internal.PlatformRecording
116     public static String getDestinationOriginalText(Recording recording) {
117         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
118         WriteablePath wp = pr.getDestination();
119         return wp == null ? null : wp.getPath().toString();
120     }
121 
122     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
123     // can abort if not all data is valid
124     public static void checkSetDestination(Recording recording, String destination) throws IOException {
125         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
126         if(destination != null){
127             pr.checkSetDestination(new WriteablePath(Paths.get(destination)));
128         }
129     }
130 
131     // Needed to modify setting using fluent API.
132     public static EventSettings newEventSettings(EventSettingsModifier esm) {
133         return PrivateAccess.getInstance().newEventSettings(esm);
134     }
135 
136     // Needed callback to detect when a chunk has been parsed.
137     public static void removePath(Recording recording, Path path) {
138         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
139         pr.removePath(path);
140     }
141 
142     // Needed callback to detect when a chunk has been parsed.
143     public static void setOnChunkCompleteHandler(EventStream stream, Consumer&lt;Long&gt; consumer) {
144         EventDirectoryStream eds = (EventDirectoryStream) stream;
145         eds.setChunkCompleteHandler(consumer);
146     }
147 
148     // Needed to start an ongoing stream at the right chunk, which
149     // can be identified by the start time with nanosecond precision.
150     public static long getStartTimeNanos(Recording recording) {
151         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
152         return pr.getStartNanos();
153     }
154 
155     // Needed to produce Configuration objects for MetadataEvent
156     public static Configuration newConfiguration(String name, String label, String description, String provider,
157           Map&lt;String, String&gt; settings, String contents) {
158         return PrivateAccess.getInstance().newConfiguration(name, label, description, provider, settings, contents);
159     }
160 
161     // Can&#39;t use EventStream.openRepository(...) because
162     // EventStream::onMetadataData need to supply MetadataEvent
163     // with configuration objects
164     public static EventStream newEventDirectoryStream(
165             Path directory,
166             List&lt;Configuration&gt; confs) throws IOException {
167         return new EventDirectoryStream(
168             directory,
169             null,
170             confs,
171             false
172         );
173     }
174 
175     // An EventStream is passive, so a stop() method doesn&#39;t fit well in the API.
176     // RemoteRecordingStream::stop() implementation need to prevent stream
177     // from being closed, so this method is needed
178     public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {
179         AbstractEventStream aes = (AbstractEventStream) stream;
180         aes.setCloseOnComplete(closeOnComplete);
181     }
182 
183     // Internal method needed to block parser
184     public static StreamBarrier activateStreamBarrier(EventStream stream) {
185         EventDirectoryStream aes = (EventDirectoryStream) stream;
186         return aes.activateStreamBarrier();
187     }
188 }
    </pre>
  </body>
</html>