<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdConfigure.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.dcmd;
 27 
 28 import java.io.IOException;
 29 
 30 import jdk.jfr.FlightRecorder;
 31 import jdk.jfr.internal.LogLevel;
 32 import jdk.jfr.internal.LogTag;
 33 import jdk.jfr.internal.Logger;
 34 import jdk.jfr.internal.Options;
 35 import jdk.jfr.internal.PrivateAccess;
 36 import jdk.jfr.internal.Repository;
 37 import jdk.jfr.internal.SecuritySupport.SafePath;
 38 
 39 /**
 40  * JFR.configure - invoked from native
 41  *
 42  */
 43 //Instantiated by native
 44 final class DCmdConfigure extends AbstractDCmd {
 45     /**
 46      * Execute JFR.configure.
 47      *
 48      * @param repositoryPath the path
 49      * @param dumpPath path to dump to on fatal error (oom)
 50      * @param stackDepth depth of stack traces
 51      * @param globalBufferCount number of global buffers
 52      * @param globalBufferSize size of global buffers
 53      * @param threadBufferSize size of thread buffer for events
 54      * @param memorySize Size of in memory buffer
 55      * @param maxChunkSize threshold at which a new chunk is created in the disk repository
 56      * @param preserveRepository if files in the repository should be deleted on exit.
 57      * @return result
 58 
 59      * @throws DCmdException
 60      *             if the dump could not be completed
 61      */
 62     public String[] execute
 63     (
 64             boolean verbose,
 65             String repositoryPath,
 66             String dumpPath,
 67             Integer stackDepth,
 68             Long globalBufferCount,
 69             Long globalBufferSize,
 70             Long threadBufferSize,
 71             Long memorySize,
 72             Long maxChunkSize,
 73             Boolean preserveRepository
 74 
 75     ) throws DCmdException {
 76         if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {
 77             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Executing DCmdConfigure: repositorypath=&quot; + repositoryPath +
 78                     &quot;, dumppath=&quot; + dumpPath +
 79                     &quot;, stackdepth=&quot; + stackDepth +
 80                     &quot;, globalbuffercount=&quot; + globalBufferCount +
 81                     &quot;, globalbuffersize=&quot; + globalBufferSize +
 82                     &quot;, thread_buffer_size=&quot; + threadBufferSize +
 83                     &quot;, memorysize=&quot; + memorySize +
 84                     &quot;, maxchunksize=&quot; + maxChunkSize +
 85                     &quot;, preserveRepository=&quot; + preserveRepository);
 86         }
 87 
 88 
 89         boolean updated = false;
 90         if (repositoryPath != null) {
 91             try {
 92                 SafePath s = new SafePath(repositoryPath);
 93                 if (FlightRecorder.isInitialized()) {
 94                     PrivateAccess.getInstance().getPlatformRecorder().migrate(s);
 95                 } else {
 96                     Repository.getRepository().setBasePath(s);
 97                 }
 98                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Base repository path set to &quot; + repositoryPath);
 99             } catch (Exception e) {
100                 throw new DCmdException(&quot;Could not use &quot; + repositoryPath + &quot; as repository. &quot; + e.getMessage(), e);
101             }
102             if (verbose) {
103                 printRepositoryPath();
104             }
105             updated = true;
106         }
107 
108         if (preserveRepository != null) {
109             Options.setPreserveRepository(preserveRepository.booleanValue());
110             if (verbose) {
111                 printPreserveRepository();
112             }
113             updated = true;
114         }
115 
116         if (dumpPath != null)  {
117             try {
118                 Options.setDumpPath(new SafePath(dumpPath));
119             } catch (IOException e) {
120                 throw new DCmdException(&quot;Could not set &quot; + dumpPath + &quot; to emergency dump path. &quot; + e.getMessage(), e);
121             }
122             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Emergency dump path set to &quot; + dumpPath);
123            if (verbose) {
124                printDumpPath();
125            }
126             updated = true;
127         }
128 
129         if (stackDepth != null)  {
130             Options.setStackDepth(stackDepth);
131             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stack depth set to &quot; + stackDepth);
132             if (verbose) {
133                 printStackDepth();
134             }
135             updated = true;
136         }
137 
138         if (globalBufferCount != null)  {
139             Options.setGlobalBufferCount(globalBufferCount);
140             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Global buffer count set to &quot; + globalBufferCount);
141             if (verbose) {
142                 printGlobalBufferCount();
143             }
144             updated = true;
145         }
146 
147         if (globalBufferSize != null)  {
148             Options.setGlobalBufferSize(globalBufferSize);
149             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Global buffer size set to &quot; + globalBufferSize);
150             if (verbose) {
151                 printGlobalBufferSize();
152             }
153             updated = true;
154         }
155 
156         if (threadBufferSize != null)  {
157             Options.setThreadBufferSize(threadBufferSize);
158             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Thread buffer size set to &quot; + threadBufferSize);
159             if (verbose) {
160                 printThreadBufferSize();
161             }
162             updated = true;
163         }
164 
165         if (memorySize != null) {
166             Options.setMemorySize(memorySize);
167             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Memory size set to &quot; + memorySize);
168             if (verbose) {
169                 printMemorySize();
170             }
171             updated = true;
172         }
173 
174         if (maxChunkSize != null)  {
175             Options.setMaxChunkSize(maxChunkSize);
176             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Max chunk size set to &quot; + maxChunkSize);
177             if (verbose) {
178                 printMaxChunkSize();
179             }
180             updated = true;
181         }
182 
183         if (!verbose) {
184             return new String[0];
185         }
186         if (!updated) {
187             println(&quot;Current configuration:&quot;);
188             println();
189             printPreserveRepository();
190             printRepositoryPath();
191             printDumpPath();
192             printStackDepth();
193             printGlobalBufferCount();
194             printGlobalBufferSize();
195             printThreadBufferSize();
196             printMemorySize();
197             printMaxChunkSize();
198         }
199         return getResult();
200     }
201 
202     private void printRepositoryPath() {
203         print(&quot;Repository path: &quot;);
204         printPath(Repository.getRepository().getRepositoryPath());
205         println();
206     }
207 
208     private void printPreserveRepository() {
209         println(&quot;Preserve repository: &quot; + Options.getPreserveRepository());
210     }
211 
212     private void printDumpPath() {
213         print(&quot;Dump path: &quot;);
214         printPath(Options.getDumpPath());
215         println();
216     }
217 
218     private void printStackDepth() {
219         println(&quot;Stack depth: &quot; +  Options.getStackDepth());
220     }
221 
222     private void printGlobalBufferCount() {
223         println(&quot;Global buffer count: &quot; +  Options.getGlobalBufferCount());
224     }
225 
226     private void printGlobalBufferSize() {
227         print(&quot;Global buffer size: &quot;);
228         printBytes(Options.getGlobalBufferSize());
229         println();
230     }
231 
232     private void printThreadBufferSize() {
233         print(&quot;Thread buffer size: &quot;);
234         printBytes(Options.getThreadBufferSize());
235         println();
236     }
237 
238     private void printMemorySize() {
239         print(&quot;Memory size: &quot;);
240         printBytes(Options.getMemorySize());
241         println();
242     }
243 
244     private void printMaxChunkSize() {
245         print(&quot;Max chunk size: &quot;);
246         printBytes(Options.getMaxChunkSize());
247         println();
248     }
249 
250     @Override
251     public String[] getHelp() {
252         throw new InternalError(&quot;Should not reach here!&quot;);
253     }
254 
255     @Override
256     public Argument[] getArgumentInfos() {
257         throw new InternalError(&quot;Should not reach here!&quot;);
258     }
259 
260     @Override
261     protected void execute(ArgumentParser parser) throws DCmdException {
262         throw new InternalError(&quot;Should not reach here!&quot;);
263     }
264 }
    </pre>
  </body>
</html>