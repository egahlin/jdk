<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../event/EventWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="model/JFCModel.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.Reader;
 32 import java.io.StringReader;
 33 import java.nio.charset.StandardCharsets;
 34 import java.nio.file.AccessDeniedException;
 35 import java.nio.file.Files;
 36 import java.nio.file.NoSuchFileException;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.text.ParseException;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;
 42 import java.util.List;
 43 
 44 import jdk.jfr.Configuration;
 45 import jdk.jfr.internal.jfc.model.JFCModelException;
 46 import jdk.jfr.internal.LogLevel;
 47 import jdk.jfr.internal.LogTag;
 48 import jdk.jfr.internal.Logger;
<span class="line-modified"> 49 import jdk.jfr.internal.SecuritySupport;</span>
<span class="line-removed"> 50 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 51 
 52 /**
 53  * {@link Configuration} factory for JFC files. *
 54  */
 55 public final class JFC {

 56     private static final int BUFFER_SIZE = 8192;
 57     private static final int MAXIMUM_FILE_SIZE = 1024 * 1024;
 58     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
 59     private static volatile List&lt;KnownConfiguration&gt; knownConfigurations;
 60 















 61     /**
 62      * Reads a known configuration file (located into a string, but doesn&#39;t
 63      * parse it until it&#39;s being used.
 64      */
 65     private static final class KnownConfiguration {
 66         private final String content;
 67         private final String filename;
 68         private final String name;
<span class="line-modified"> 69         private final SafePath path;</span>
 70         private Configuration configuration;
 71 
<span class="line-modified"> 72         public KnownConfiguration(SafePath knownPath) throws IOException {</span>
 73             this.path = knownPath;
 74             this.content = readContent(knownPath);
<span class="line-modified"> 75             this.name = nameFromPath(knownPath.toPath());</span>
<span class="line-modified"> 76             this.filename = nullSafeFileName(knownPath.toPath());</span>
 77         }
 78 
 79         public boolean isNamed(String name) {
 80             return filename.equals(name) || this.name.equals(name);
 81         }
 82 
 83         public Configuration getConfigurationFile() throws IOException, ParseException {
 84             if (configuration == null) {
 85                 configuration = JFCParser.createConfiguration(name, content);
 86             }
 87             return configuration;
 88         }
 89 
 90         public String getName() {
 91             return name;
 92         }
 93 
<span class="line-modified"> 94         private static String readContent(SafePath knownPath) throws IOException {</span>
<span class="line-modified"> 95             if (SecuritySupport.getFileSize(knownPath) &gt; MAXIMUM_FILE_SIZE) {</span>
 96                 throw new IOException(&quot;Configuration with more than &quot;
 97                         + MAXIMUM_FILE_SIZE + &quot; characters can&#39;t be read.&quot;);
 98             }
<span class="line-modified"> 99             try (InputStream r = SecuritySupport.newFileInputStream(knownPath)) {</span>
100                 return JFC.readContent(r);
101             }
102         }
103     }
104 
105     private JFC() {
106         // private utility class
107     }
108 
109     /**
110      * Reads a configuration from a file.
111      *
112      * @param path the file containing the configuration, not {@code null}
113      * @return {@link Configuration}, not {@code null}
114      * @throws ParseException if the file can&#39;t be parsed
115      * @throws IOException if the file can&#39;t be read
116      *
<span class="line-removed">117      * @throws SecurityException if a security manager exists and its</span>
<span class="line-removed">118      *         {@code checkRead} method denies read access to the file</span>
119      * @see java.io.File#getPath()
<span class="line-removed">120      * @see java.lang.SecurityManager#checkRead(java.lang.String)</span>
121      */
122     public static Configuration create(String name, Reader reader) throws IOException, ParseException {
123         try {
124             return JFCParser.createConfiguration(name, reader);
125         } catch (ParseException pe) {
126             throw new ParseException(&quot;Error reading JFC file. &quot; + pe.getMessage(), -1);
127         }
128     }
129 
130     /**
131      * Create a path to a .jfc file.
132      * &lt;p&gt;
133      * If the name is predefined name,
134      * i.e. &quot;default&quot; or &quot;profile.jfc&quot;, it will return the path for
135      * the predefined path in the JDK.
136      *
137      * @param path textual representation of the path
138      *
<span class="line-modified">139      * @return a safe path, not null</span>
140      */
<span class="line-modified">141     public static SafePath createSafePath(String path) {</span>
<span class="line-modified">142         for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {</span>
143             try {
<span class="line-modified">144                 String name = JFC.nameFromPath(predefined.toPath());</span>
145                 if (name.equals(path) || (name + &quot;.jfc&quot;).equals(path)) {
146                     return predefined;
147                 }
148             } catch (IOException e) {
149                 throw new InternalError(&quot;Error in predefined .jfc file&quot;, e);
150             }
151         }
<span class="line-modified">152         return new SafePath(path);</span>
153     }
154 
155 
156     private static String nullSafeFileName(Path file) throws IOException {
157         Path filename = file.getFileName();
158         if (filename == null) {
159             throw new IOException(&quot;Path has no file name&quot;);
160         }
161         return filename.toString();
162     }
163 
164     public static String nameFromPath(Path file) throws IOException {
165         String f = nullSafeFileName(file);
166         if (f.endsWith(JFCParser.FILE_EXTENSION)) {
167             return f.substring(0, f.length() - JFCParser.FILE_EXTENSION.length());
168         } else  {
169             return f;
170         }
171     }
172 
173     // Invoked by DCmdStart
174     public static Configuration createKnown(String name) throws IOException, ParseException {
<span class="line-removed">175         // Known name, no need for permission</span>
176         for (KnownConfiguration known : getKnownConfigurations()) {
177             if (known.isNamed(name)) {
178                 return known.getConfigurationFile();
179             }
180         }
181         // Check JFC directory
<span class="line-modified">182         SafePath path = SecuritySupport.JFC_DIRECTORY;</span>
<span class="line-modified">183         if (path != null &amp;&amp; SecuritySupport.exists(path)) {</span>
184             for (String extension : Arrays.asList(&quot;&quot;, JFCParser.FILE_EXTENSION)) {
<span class="line-modified">185                 SafePath file = new SafePath(path.toPath().resolveSibling(name + extension));</span>
<span class="line-modified">186                 if (SecuritySupport.exists(file) &amp;&amp; !SecuritySupport.isDirectory(file)) {</span>
<span class="line-modified">187                     try (Reader r = SecuritySupport.newFileReader(file)) {</span>
<span class="line-modified">188                         String jfcName = nameFromPath(file.toPath());</span>
189                         return JFCParser.createConfiguration(jfcName, r);
190                     }
191                 }
192             }
193         }
194 
195         // Assume path included in name
196 
197         Path localPath = Paths.get(name);
198         String jfcName = nameFromPath(localPath);
199         try (Reader r = Files.newBufferedReader(localPath)) {
200             return JFCParser.createConfiguration(jfcName, r);
201         }
202     }
203 
204     private static String readContent(InputStream source) throws IOException {
205         byte[] bytes = read(source, BUFFER_SIZE);
206         return new String(bytes, StandardCharsets.UTF_8);
207     }
208 
</pre>
<hr />
<pre>
243      *
244      * @return list of configurations, not null
245      */
246     public static List&lt;Configuration&gt; getConfigurations() {
247         List&lt;Configuration&gt; configs = new ArrayList&lt;&gt;();
248         for (KnownConfiguration knownConfig : getKnownConfigurations()) {
249             try {
250                 configs.add(knownConfig.getConfigurationFile());
251             } catch (IOException e) {
252                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not load configuration &quot; + knownConfig.getName() + &quot;. &quot; + e.getMessage());
253             } catch (ParseException e) {
254                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not parse configuration &quot; + knownConfig.getName() + &quot;. &quot; + e.getMessage());
255             }
256         }
257         return configs;
258     }
259 
260     private static List&lt;KnownConfiguration&gt; getKnownConfigurations() {
261         if (knownConfigurations == null) {
262             List&lt;KnownConfiguration&gt; configProxies = new ArrayList&lt;&gt;();
<span class="line-modified">263             for (SafePath p : SecuritySupport.getPredefinedJFCFiles()) {</span>
264                 try {
265                     configProxies.add(new KnownConfiguration(p));
266                 } catch (IOException ioe) {
267                     // ignore
268                 }
269             }
270             knownConfigurations = configProxies;
271         }
272         return knownConfigurations;
273     }
274 
275     public static Configuration getPredefined(String name) throws IOException, ParseException {
276         for (KnownConfiguration knownConfig : getKnownConfigurations()) {
277             if (knownConfig.getName().equals(name)) {
278                 return knownConfig.getConfigurationFile();
279             }
280         }
281         throw new NoSuchFileException(&quot;Could not locate configuration with name &quot; + name);
282     }
283 
<span class="line-modified">284     public static Reader newReader(SafePath sf) throws IOException {</span>
285         for (KnownConfiguration c : getKnownConfigurations()) {
286             if (c.path.equals(sf)) {
287                 return new StringReader(c.content);
288             }
289         }
290         return Files.newBufferedReader(sf.toFile().toPath(), StandardCharsets.UTF_8);
291     }
292 
293     public static String formatException(String prefix, Exception e, String input) {
294         String message = prefix + &quot; &quot; + JFC.exceptionToVerb(e) + &quot; file &#39;&quot; + input + &quot;&#39;&quot;;
295         String details = e.getMessage();
296         if (e instanceof JFCModelException) {
297             return message +  &quot;. &quot; + details;
298         }
299         if (e instanceof ParseException &amp;&amp; !details.isEmpty()) {
300             return message +  &quot;. &quot; + details;
301         }
302         return message;
303     }
304 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.Reader;
 32 import java.io.StringReader;
 33 import java.nio.charset.StandardCharsets;
 34 import java.nio.file.AccessDeniedException;
 35 import java.nio.file.Files;
 36 import java.nio.file.NoSuchFileException;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.text.ParseException;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;
 42 import java.util.List;
 43 
 44 import jdk.jfr.Configuration;
 45 import jdk.jfr.internal.jfc.model.JFCModelException;
 46 import jdk.jfr.internal.LogLevel;
 47 import jdk.jfr.internal.LogTag;
 48 import jdk.jfr.internal.Logger;
<span class="line-modified"> 49 import jdk.jfr.internal.util.Utils;</span>

 50 
 51 /**
 52  * {@link Configuration} factory for JFC files. *
 53  */
 54 public final class JFC {
<span class="line-added"> 55     private static final Path JFC_DIRECTORY = Utils.getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);</span>
 56     private static final int BUFFER_SIZE = 8192;
 57     private static final int MAXIMUM_FILE_SIZE = 1024 * 1024;
 58     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
 59     private static volatile List&lt;KnownConfiguration&gt; knownConfigurations;
 60 
<span class="line-added"> 61     public static List&lt;Path&gt; getPredefined() {</span>
<span class="line-added"> 62         List&lt;Path&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 63         try (var ds = Files.newDirectoryStream(JFC_DIRECTORY)) {</span>
<span class="line-added"> 64             for (Path path : ds) {</span>
<span class="line-added"> 65                 String text = path.toString();</span>
<span class="line-added"> 66                 if (text.endsWith(&quot;.jfc&quot;) &amp;&amp; !Files.isDirectory(path)) {</span>
<span class="line-added"> 67                     list.add(path);</span>
<span class="line-added"> 68                 }</span>
<span class="line-added"> 69             }</span>
<span class="line-added"> 70         } catch (IOException ioe) {</span>
<span class="line-added"> 71             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not access .jfc-files in &quot; + JFC_DIRECTORY + &quot;, &quot; + ioe.getMessage());</span>
<span class="line-added"> 72         }</span>
<span class="line-added"> 73         return list;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 </span>
 76     /**
 77      * Reads a known configuration file (located into a string, but doesn&#39;t
 78      * parse it until it&#39;s being used.
 79      */
 80     private static final class KnownConfiguration {
 81         private final String content;
 82         private final String filename;
 83         private final String name;
<span class="line-modified"> 84         private final Path path;</span>
 85         private Configuration configuration;
 86 
<span class="line-modified"> 87         public KnownConfiguration(Path knownPath) throws IOException {</span>
 88             this.path = knownPath;
 89             this.content = readContent(knownPath);
<span class="line-modified"> 90             this.name = nameFromPath(knownPath);</span>
<span class="line-modified"> 91             this.filename = nullSafeFileName(knownPath);</span>
 92         }
 93 
 94         public boolean isNamed(String name) {
 95             return filename.equals(name) || this.name.equals(name);
 96         }
 97 
 98         public Configuration getConfigurationFile() throws IOException, ParseException {
 99             if (configuration == null) {
100                 configuration = JFCParser.createConfiguration(name, content);
101             }
102             return configuration;
103         }
104 
105         public String getName() {
106             return name;
107         }
108 
<span class="line-modified">109         private static String readContent(Path knownPath) throws IOException {</span>
<span class="line-modified">110             if (Files.size(knownPath) &gt; MAXIMUM_FILE_SIZE) {</span>
111                 throw new IOException(&quot;Configuration with more than &quot;
112                         + MAXIMUM_FILE_SIZE + &quot; characters can&#39;t be read.&quot;);
113             }
<span class="line-modified">114             try (InputStream r = Files.newInputStream(knownPath);) {</span>
115                 return JFC.readContent(r);
116             }
117         }
118     }
119 
120     private JFC() {
121         // private utility class
122     }
123 
124     /**
125      * Reads a configuration from a file.
126      *
127      * @param path the file containing the configuration, not {@code null}
128      * @return {@link Configuration}, not {@code null}
129      * @throws ParseException if the file can&#39;t be parsed
130      * @throws IOException if the file can&#39;t be read
131      *


132      * @see java.io.File#getPath()

133      */
134     public static Configuration create(String name, Reader reader) throws IOException, ParseException {
135         try {
136             return JFCParser.createConfiguration(name, reader);
137         } catch (ParseException pe) {
138             throw new ParseException(&quot;Error reading JFC file. &quot; + pe.getMessage(), -1);
139         }
140     }
141 
142     /**
143      * Create a path to a .jfc file.
144      * &lt;p&gt;
145      * If the name is predefined name,
146      * i.e. &quot;default&quot; or &quot;profile.jfc&quot;, it will return the path for
147      * the predefined path in the JDK.
148      *
149      * @param path textual representation of the path
150      *
<span class="line-modified">151      * @return a path, not null</span>
152      */
<span class="line-modified">153     public static Path ofPath(String path) {</span>
<span class="line-modified">154         for (Path predefined : JFC.getPredefined()) {</span>
155             try {
<span class="line-modified">156                 String name = JFC.nameFromPath(predefined);</span>
157                 if (name.equals(path) || (name + &quot;.jfc&quot;).equals(path)) {
158                     return predefined;
159                 }
160             } catch (IOException e) {
161                 throw new InternalError(&quot;Error in predefined .jfc file&quot;, e);
162             }
163         }
<span class="line-modified">164         return Path.of(path);</span>
165     }
166 
167 
168     private static String nullSafeFileName(Path file) throws IOException {
169         Path filename = file.getFileName();
170         if (filename == null) {
171             throw new IOException(&quot;Path has no file name&quot;);
172         }
173         return filename.toString();
174     }
175 
176     public static String nameFromPath(Path file) throws IOException {
177         String f = nullSafeFileName(file);
178         if (f.endsWith(JFCParser.FILE_EXTENSION)) {
179             return f.substring(0, f.length() - JFCParser.FILE_EXTENSION.length());
180         } else  {
181             return f;
182         }
183     }
184 
185     // Invoked by DCmdStart
186     public static Configuration createKnown(String name) throws IOException, ParseException {

187         for (KnownConfiguration known : getKnownConfigurations()) {
188             if (known.isNamed(name)) {
189                 return known.getConfigurationFile();
190             }
191         }
192         // Check JFC directory
<span class="line-modified">193         Path path = JFC_DIRECTORY;</span>
<span class="line-modified">194         if (path != null &amp;&amp; Files.exists(path)) {</span>
195             for (String extension : Arrays.asList(&quot;&quot;, JFCParser.FILE_EXTENSION)) {
<span class="line-modified">196                 Path file = path.resolveSibling(name + extension);</span>
<span class="line-modified">197                 if (Files.exists(file) &amp;&amp; !Files.isDirectory(file)) {</span>
<span class="line-modified">198                     try (Reader r = Files.newBufferedReader(file);) {</span>
<span class="line-modified">199                         String jfcName = nameFromPath(file);</span>
200                         return JFCParser.createConfiguration(jfcName, r);
201                     }
202                 }
203             }
204         }
205 
206         // Assume path included in name
207 
208         Path localPath = Paths.get(name);
209         String jfcName = nameFromPath(localPath);
210         try (Reader r = Files.newBufferedReader(localPath)) {
211             return JFCParser.createConfiguration(jfcName, r);
212         }
213     }
214 
215     private static String readContent(InputStream source) throws IOException {
216         byte[] bytes = read(source, BUFFER_SIZE);
217         return new String(bytes, StandardCharsets.UTF_8);
218     }
219 
</pre>
<hr />
<pre>
254      *
255      * @return list of configurations, not null
256      */
257     public static List&lt;Configuration&gt; getConfigurations() {
258         List&lt;Configuration&gt; configs = new ArrayList&lt;&gt;();
259         for (KnownConfiguration knownConfig : getKnownConfigurations()) {
260             try {
261                 configs.add(knownConfig.getConfigurationFile());
262             } catch (IOException e) {
263                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not load configuration &quot; + knownConfig.getName() + &quot;. &quot; + e.getMessage());
264             } catch (ParseException e) {
265                 Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not parse configuration &quot; + knownConfig.getName() + &quot;. &quot; + e.getMessage());
266             }
267         }
268         return configs;
269     }
270 
271     private static List&lt;KnownConfiguration&gt; getKnownConfigurations() {
272         if (knownConfigurations == null) {
273             List&lt;KnownConfiguration&gt; configProxies = new ArrayList&lt;&gt;();
<span class="line-modified">274             for (Path p : JFC.getPredefined()) {</span>
275                 try {
276                     configProxies.add(new KnownConfiguration(p));
277                 } catch (IOException ioe) {
278                     // ignore
279                 }
280             }
281             knownConfigurations = configProxies;
282         }
283         return knownConfigurations;
284     }
285 
286     public static Configuration getPredefined(String name) throws IOException, ParseException {
287         for (KnownConfiguration knownConfig : getKnownConfigurations()) {
288             if (knownConfig.getName().equals(name)) {
289                 return knownConfig.getConfigurationFile();
290             }
291         }
292         throw new NoSuchFileException(&quot;Could not locate configuration with name &quot; + name);
293     }
294 
<span class="line-modified">295     public static Reader newReader(Path sf) throws IOException {</span>
296         for (KnownConfiguration c : getKnownConfigurations()) {
297             if (c.path.equals(sf)) {
298                 return new StringReader(c.content);
299             }
300         }
301         return Files.newBufferedReader(sf.toFile().toPath(), StandardCharsets.UTF_8);
302     }
303 
304     public static String formatException(String prefix, Exception e, String input) {
305         String message = prefix + &quot; &quot; + JFC.exceptionToVerb(e) + &quot; file &#39;&quot; + input + &quot;&#39;&quot;;
306         String details = e.getMessage();
307         if (e instanceof JFCModelException) {
308             return message +  &quot;. &quot; + details;
309         }
310         if (e instanceof ParseException &amp;&amp; !details.isEmpty()) {
311             return message +  &quot;. &quot; + details;
312         }
313         return message;
314     }
315 
</pre>
</td>
</tr>
</table>
<center><a href="../event/EventWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="model/JFCModel.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>