<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.management;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.util.Collections;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.function.Consumer;
 37 import java.security.AccessControlContext;
 38 
 39 import jdk.jfr.Configuration;
 40 import jdk.jfr.EventSettings;
 41 import jdk.jfr.EventType;
 42 import jdk.jfr.Recording;
 43 import jdk.jfr.consumer.EventStream;
 44 import jdk.jfr.internal.JDKEvents;
 45 import jdk.jfr.internal.JVMSupport;
 46 import jdk.jfr.internal.LogLevel;
 47 import jdk.jfr.internal.LogTag;
 48 import jdk.jfr.internal.Logger;
 49 import jdk.jfr.internal.MetadataRepository;
 50 import jdk.jfr.internal.PlatformRecording;
 51 import jdk.jfr.internal.PrivateAccess;
 52 import jdk.jfr.internal.SecuritySupport;
 53 import jdk.jfr.internal.SecuritySupport.SafePath;
 54 import jdk.jfr.internal.util.Utils;
 55 import jdk.jfr.internal.util.ValueFormatter;
 56 import jdk.jfr.internal.util.ValueParser;
 57 import jdk.jfr.internal.WriteableUserPath;
 58 import jdk.jfr.internal.consumer.AbstractEventStream;
 59 import jdk.jfr.internal.consumer.EventDirectoryStream;
 60 import jdk.jfr.internal.consumer.FileAccess;
 61 
 62 /**
 63  * The management API in module jdk.management.jfr should be built on top of the
 64  * public API in jdk.jfr. Before putting more functionality here, consider if it
 65  * should not be part of the public API, and if not, please provide motivation
 66  *
 67  */
 68 public final class ManagementSupport {
 69 
 70     // Purpose of this method is to expose the event types to the
 71     // FlightRecorderMXBean without instantiating Flight Recorder.
 72     //
 73     // This allows:
 74     //
 75     // 1) discoverability, so event settings can be exposed without the need to
 76     // create a new Recording in FlightRecorderMXBean.
 77     //
 78     // 2) a graphical JMX client to list all attributes to the user, without
 79     // loading JFR memory buffers. This is especially important when there is
 80     // no intent to use Flight Recorder.
 81     //
 82     // An alternative design would be to make FlightRecorder#getEventTypes
 83     // static, but it would the make the API look strange
 84     //
 85     public static List&lt;EventType&gt; getEventTypes() {
 86         // would normally be checked when a Flight Recorder instance is created
 87         SecuritySupport.checkAccessFlightRecorder();
 88         if (JVMSupport.isNotAvailable()) {
 89             return List.of();
 90         }
 91         JDKEvents.initialize(); // make sure JDK events are available
 92         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
 93     }
 94 
 95     // Reuse internal code for parsing a timespan
 96     public static long parseTimespan(String s) {
 97         return ValueParser.parseTimespan(s);
 98     }
 99 
100     // Reuse internal code for converting nanoseconds since epoch to Instant
101     public static Instant epochNanosToInstant(long epochNanos) {
102       return Utils.epochNanosToInstant(epochNanos);
103     }
104 
105     // Reuse internal code for formatting settings
106     public static final String formatTimespan(Duration dValue, String separation) {
107         return ValueFormatter.formatTimespan(dValue, separation);
108     }
109 
110     // Reuse internal logging mechanism
111     public static void logError(String message) {
112         Logger.log(LogTag.JFR, LogLevel.ERROR, message);
113     }
114 
115     // Reuse internal logging mechanism
116     public static void logDebug(String message) {
117         Logger.log(LogTag.JFR, LogLevel.DEBUG, message);
118     }
119 
120     // Get the textual representation when the destination was set, which
121     // requires access to jdk.jfr.internal.PlatformRecording
122     public static String getDestinationOriginalText(Recording recording) {
123         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
124         WriteableUserPath wup = pr.getDestination();
125         return wup == null ? null : wup.getOriginalText();
126     }
127 
128     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
129     // can abort if not all data is valid
130     public static void checkSetDestination(Recording recording, String destination) throws IOException{
131         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
132         if(destination != null){
133             WriteableUserPath wup = new WriteableUserPath(Paths.get(destination));
134             pr.checkSetDestination(wup);
135         }
136     }
137 
138     // Needed to modify setting using fluent API.
139     public static EventSettings newEventSettings(EventSettingsModifier esm) {
140         return PrivateAccess.getInstance().newEventSettings(esm);
141     }
142 
143     // Needed callback to detect when a chunk has been parsed.
144     public static void removePath(Recording recording, Path path) {
145         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
146         pr.removePath(new SafePath(path));
147     }
148 
149     // Needed callback to detect when a chunk has been parsed.
150     public static void setOnChunkCompleteHandler(EventStream stream, Consumer&lt;Long&gt; consumer) {
151         EventDirectoryStream eds = (EventDirectoryStream) stream;
152         eds.setChunkCompleteHandler(consumer);
153     }
154 
155     // Needed to start an ongoing stream at the right chunk, which
156     // can be identified by the start time with nanosecond precision.
157     public static long getStartTimeNanos(Recording recording) {
158         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
159         return pr.getStartNanos();
160     }
161 
162     // Needed to produce Configuration objects for MetadataEvent
163     public static Configuration newConfiguration(String name, String label, String description, String provider,
164           Map&lt;String, String&gt; settings, String contents) {
165         return PrivateAccess.getInstance().newConfiguration(name, label, description, provider, settings, contents);
166     }
167 
168     // Can&#39;t use EventStream.openRepository(...) because
169     // EventStream::onMetadataData need to supply MetadataEvent
170     // with configuration objects
171     public static EventStream newEventDirectoryStream(
172             @SuppressWarnings(&quot;removal&quot;)
173             AccessControlContext acc,
174             Path directory,
175             List&lt;Configuration&gt; confs) throws IOException {
176         return new EventDirectoryStream(
177             acc,
178             directory,
179             FileAccess.UNPRIVILEGED,
180             null,
181             confs,
182             false
183         );
184     }
185 
186     // An EventStream is passive, so a stop() method doesn&#39;t fit well in the API.
187     // RemoteRecordingStream::stop() implementation need to prevent stream
188     // from being closed, so this method is needed
189     public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {
190         AbstractEventStream aes = (AbstractEventStream) stream;
191         aes.setCloseOnComplete(closeOnComplete);
192     }
193 
194     // Internal method needed to block parser
195     public static StreamBarrier activateStreamBarrier(EventStream stream) {
196         EventDirectoryStream aes = (EventDirectoryStream) stream;
197         return aes.activateStreamBarrier();
198     }
199 }
    </pre>
  </body>
</html>