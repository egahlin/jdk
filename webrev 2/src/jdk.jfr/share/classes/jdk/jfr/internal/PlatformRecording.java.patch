diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,15 +33,12 @@
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.channels.FileChannel;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -57,11 +54,10 @@
 
 import jdk.jfr.Configuration;
 import jdk.jfr.FlightRecorderListener;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.util.ValueFormatter;
 
 public final class PlatformRecording implements AutoCloseable {
 
@@ -71,16 +67,16 @@
     private Map<String, String> settings = new LinkedHashMap<>();
     private Duration duration;
     private Duration maxAge;
     private long maxSize;
 
-    private WriteableUserPath destination;
+    private WriteablePath destination;
 
     private boolean toDisk = true;
     private String name;
     private boolean dumpOnExit;
-    private SafePath dumpDirectory;
+    private Path dumpDirectory;
     // Timestamp information
     private Instant stopTime;
     private Instant startTime;
 
     // Misc, information
@@ -88,26 +84,17 @@
     private long size;
     private final LinkedList<RepositoryChunk> chunks = new LinkedList<>();
     private volatile Recording recording;
     private TimerTask stopTask;
     private TimerTask startTask;
-    @SuppressWarnings("removal")
-    private final AccessControlContext dumpDirectoryControlContext;
     private boolean shouldWriteActiveRecordingEvent = true;
     private Duration flushInterval = Duration.ofSeconds(1);
     private long finalStartChunkNanos = Long.MIN_VALUE;
     private long startNanos = -1;
 
     @SuppressWarnings("removal")
     PlatformRecording(PlatformRecorder recorder, long id) {
-        // Typically the access control context is taken
-        // when you call dump(Path) or setDestination(Path),
-        // but if no destination is set and the filename is auto-generated,
-        // the control context of the recording is taken when the
-        // Recording object is constructed. This works well for
-        // -XX:StartFlightRecording and JFR.dump
-        this.dumpDirectoryControlContext = AccessController.getContext();
         this.id = id;
         this.recorder = recorder;
         this.name = String.valueOf(id);
     }
 
@@ -173,11 +160,11 @@
             recorder.stop(this);
             String endText = reason == null ? "" : ". Reason \"" + reason + "\".";
             Logger.log(LogTag.JFR, LogLevel.INFO, "Stopped recording \"" + getName() + "\" (" + getId() + ")" + endText);
             newState = getState();
         }
-        WriteableUserPath dest = getDestination();
+        WriteablePath dest = getDestination();
         if (dest == null && dumpDirectory != null) {
             dest = makeDumpPath();
         }
         if (dest != null) {
             try {
@@ -193,34 +180,22 @@
             notifyIfStateChanged(newState, oldState);
         }
         return true;
     }
 
-    @SuppressWarnings("removal")
-    public WriteableUserPath makeDumpPath() {
+    public WriteablePath makeDumpPath() {
         try {
             String name = JVMSupport.makeFilename(getRecording());
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<WriteableUserPath>() {
-                @Override
-                public WriteableUserPath run() throws Exception {
-                    SafePath p = dumpDirectory;
-                    if (p == null) {
-                        p = new SafePath(".");
-                    }
-                    return new WriteableUserPath(p.toPath().resolve(name));
-                }
-            }, dumpDirectoryControlContext);
-        } catch (PrivilegedActionException e) {
-            Throwable t = e.getCause();
-            if (t instanceof SecurityException) {
-                Logger.log(LogTag.JFR, LogLevel.WARN, "Not allowed to create dump path for recording " + recording.getId() + " on exit.");
-            }
-            if (t instanceof IOException) {
-                Logger.log(LogTag.JFR, LogLevel.WARN, "Could not dump " + recording.getId() + " on exit.");
+            Path p = dumpDirectory;
+            if (p == null) {
+                p = Path.of(".");
             }
-            return null;
+            return new WriteablePath(p.resolve(name));
+        } catch (IOException e) {
+            Logger.log(LogTag.JFR, LogLevel.WARN, "Could not dump " + recording.getId() + " on exit. " + e.getMessage());
         }
+        return null;
     }
 
 
     public void scheduleStart(Duration delay) {
         synchronized (recorder) {
@@ -420,26 +395,28 @@
             this.maxSize = maxSize;
             trimToSize();
         }
     }
 
-    public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {
+    public void setDestination(WriteablePath destination) throws IOException {
         synchronized (recorder) {
-            checkSetDestination(userSuppliedPath);
-            this.destination = userSuppliedPath;
+            checkSetDestination(destination);
+            this.destination = destination;
         }
     }
 
-    public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {
+    public void checkSetDestination(WriteablePath writeablePath) throws IOException {
+        // The writeablePath argument is not checked. It's sufficient that an instance has
+        // been created.
         synchronized (recorder) {
             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
                 throw new IllegalStateException("Destination can't be set on a recording that has been stopped/closed");
             }
         }
     }
 
-    public WriteableUserPath getDestination() {
+    public WriteablePath getDestination() {
         synchronized (recorder) {
             return destination;
         }
     }
 
@@ -705,12 +682,11 @@
             @Override
             public void run() {
                 try {
                     stop("End of duration reached");
                 } catch (Throwable t) {
-                    // Prevent malicious user to propagate exception callback in the wrong context
-                    Logger.log(LogTag.JFR, LogLevel.ERROR, "Could not stop recording.");
+                    Logger.log(LogTag.JFR, LogLevel.ERROR, "Could not stop recording. " + t.getMessage());
                 }
             }
         };
     }
 
@@ -735,41 +711,38 @@
     boolean shouldWriteMetadataEvent() {
         return shouldWriteActiveRecordingEvent;
     }
 
     // Dump running and stopped recordings
-    public void dump(WriteableUserPath writeableUserPath) throws IOException {
+    public void dump(WriteablePath writeablePath) throws IOException {
         synchronized (recorder) {
             try(PlatformRecording p = newSnapshotClone("Dumped by user", null))  {
-                p.dumpStopped(writeableUserPath);
+                p.dumpStopped(writeablePath);
             }
         }
     }
 
-    public void dumpStopped(WriteableUserPath userPath) throws IOException {
+    public void dumpStopped(WriteablePath path) throws IOException {
         synchronized (recorder) {
-            transferChunksWithRetry(userPath);
+            transferChunksWithRetry(path);
         }
     }
 
-    private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {
-        userPath.doPrivilegedIO(() -> {
-            try {
-                transferChunks(userPath);
-            } catch (NoSuchFileException nsfe) {
-                Logger.log(LogTag.JFR, LogLevel.ERROR, "Missing chunkfile when writing recording \"" + name + "\" (" + id + ") to " + userPath.getRealPathText() + ".");
-                // if one chunkfile was missing, its likely more are missing
-                removeNonExistantPaths();
-                // and try the transfer again
-                transferChunks(userPath);
-            }
-            return null;
-        });
+    private void transferChunksWithRetry(WriteablePath path) throws IOException {
+        try {
+            transferChunks(path);
+        } catch (NoSuchFileException nsfe) {
+            Logger.log(LogTag.JFR, LogLevel.ERROR, "Missing chunkfile when writing recording \"" + name + "\" (" + id + ") to " + path.getRealPathText() + ".");
+            // if one chunkfile was missing, its likely more are missing
+            removeNonExistantPaths();
+            // and try the transfer again
+            transferChunks(path);
+        }
     }
 
-    private void transferChunks(WriteableUserPath userPath) throws IOException {
-        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
+    private void transferChunks(WriteablePath path) throws IOException {
+        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
             long bytes = cc.transferTo(fc);
             Logger.log(LogTag.JFR, LogLevel.INFO, "Transferred " + bytes + " bytes from the disk repository");
             // No need to force if no data was transferred, which avoids IOException when device is /dev/null
             if (bytes != 0) {
                 fc.force(true);
@@ -857,11 +830,11 @@
     /**
      * Sets the dump directory.
      * <p>
      * Only to be used by DCmdStart.
      */
-    public void setDumpDirectory(SafePath directory) {
+    public void setDumpDirectory(Path directory) {
        this.dumpDirectory = directory;
     }
 
     public void setFlushInterval(Duration interval) {
         synchronized (recorder) {
@@ -911,11 +884,11 @@
             }
         }
 
     }
 
-    public void removePath(SafePath path) {
+    public void removePath(Path path) {
         synchronized (recorder) {
             Iterator<RepositoryChunk> it = chunks.iterator();
             while (it.hasNext()) {
                 RepositoryChunk c = it.next();
                 if (c.getFile().equals(path)) {
