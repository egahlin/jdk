<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="JVMSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MetadataLoader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 47      *
 48      * @param dummy2
 49      *            not used, but act as padding so bytesForEagerInstrumentation and
 50      *            onRetransform can have identical method signatures, which simplifies the
 51      *            invoke machinery in native
 52      *
 53      * @param clazz
 54      *            class being retransformed
 55      * @param oldBytes
 56      *            byte code
 57      * @return byte code to use
 58      * @throws Throwable
 59      */
 60     static byte[] onRetransform(long traceId, boolean dummy1, boolean dummy2, Class&lt;?&gt; clazz, byte[] oldBytes) throws Throwable {
 61         try {
 62             if (jdk.internal.event.Event.class.isAssignableFrom(clazz) &amp;&amp; !Modifier.isAbstract(clazz.getModifiers())) {
 63                 if (!JVMSupport.shouldInstrument(Utils.isJDKClass(clazz), clazz.getName())) {
 64                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + clazz.getName() + &quot; since container support is missing&quot;);
 65                     return oldBytes;
 66                 }
<span class="line-removed"> 67                 EventWriterKey.ensureEventWriterFactory();</span>
 68                 EventConfiguration configuration = JVMSupport.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));
 69                 if (configuration == null) {
 70                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;No event configuration found for &quot; + clazz.getName() + &quot;. Ignoring instrumentation request.&quot;);
 71                     // Probably triggered by some other agent
 72                     return oldBytes;
 73                 }
 74                 boolean jdkClass = Utils.isJDKClass(clazz);
 75                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding instrumentation to event class &quot; + clazz.getName() + &quot; using retransform&quot;);
 76                 EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId, jdkClass, false);
 77                 byte[] bytes = ei.buildInstrumented();
 78                 Bytecode.log(clazz.getName(), bytes);
 79                 return bytes;
 80             }
 81             return oldBytes;
 82         } catch (Throwable t) {
 83             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation to event class &quot; + clazz.getName());
 84         }
 85         return oldBytes;
 86     }
 87 
</pre>
<hr />
<pre>
107         String eventName = &quot;&lt;Unknown&gt;&quot;;
108         try {
109             EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId, bootClassLoader, true);
110             eventName = ei.getEventName();
111             if (!JVMSupport.shouldInstrument(bootClassLoader,  ei.getEventName())) {
112                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + eventName + &quot; since container support is missing&quot;);
113                 return oldBytes;
114             }
115 
116             if (!forceInstrumentation) {
117                 // Assume we are recording
118                 MetadataRepository mr = MetadataRepository.getInstance();
119                 // No need to generate bytecode if:
120                 // 1) Event class is disabled, and there is not an external configuration that overrides.
121                 // 2) Event class has @Registered(false)
122                 if (!mr.isEnabled(ei.getEventName()) &amp;&amp; !ei.isEnabled() || !ei.isRegistered()) {
123                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for event type &quot; + eventName + &quot; since event was disabled on class load&quot;);
124                     return oldBytes;
125                 }
126             }
<span class="line-removed">127             EventWriterKey.ensureEventWriterFactory();</span>
128             Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding &quot; + (forceInstrumentation ? &quot;forced &quot; : &quot;&quot;) + &quot;instrumentation for event type &quot; + eventName + &quot; during initial class load&quot;);
129             byte[] bytes = ei.buildInstrumented();
130             Bytecode.log(ei.getClassName() + &quot;(&quot; + traceId + &quot;)&quot;, bytes);
131             return bytes;
132         } catch (Throwable t) {
133             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation for event type &quot; + eventName);
134             return oldBytes;
135         }
136     }
137 
138     /**
139      * Called by the JVM to ensure metadata for internal events/types become public.
140      *
141      * Must be called after metadata repository has been initialized (JFR created).
142      *
143      */
144     static void unhideInternalTypes() {
145         MetadataRepository.unhideInternalTypes();
146     }
147 
148     /**
149      * Called by the JVM to create the recorder thread.
150      *
151      * @param systemThreadGroup  the system thread group
152      *
153      * @param contextClassLoader the context class loader.
154      *
155      * @return a new thread
156      */
157     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
<span class="line-modified">158         return SecuritySupport.createRecorderThread(systemThreadGroup, contextClassLoader);</span>


159     }
160 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 47      *
 48      * @param dummy2
 49      *            not used, but act as padding so bytesForEagerInstrumentation and
 50      *            onRetransform can have identical method signatures, which simplifies the
 51      *            invoke machinery in native
 52      *
 53      * @param clazz
 54      *            class being retransformed
 55      * @param oldBytes
 56      *            byte code
 57      * @return byte code to use
 58      * @throws Throwable
 59      */
 60     static byte[] onRetransform(long traceId, boolean dummy1, boolean dummy2, Class&lt;?&gt; clazz, byte[] oldBytes) throws Throwable {
 61         try {
 62             if (jdk.internal.event.Event.class.isAssignableFrom(clazz) &amp;&amp; !Modifier.isAbstract(clazz.getModifiers())) {
 63                 if (!JVMSupport.shouldInstrument(Utils.isJDKClass(clazz), clazz.getName())) {
 64                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + clazz.getName() + &quot; since container support is missing&quot;);
 65                     return oldBytes;
 66                 }

 67                 EventConfiguration configuration = JVMSupport.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));
 68                 if (configuration == null) {
 69                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;No event configuration found for &quot; + clazz.getName() + &quot;. Ignoring instrumentation request.&quot;);
 70                     // Probably triggered by some other agent
 71                     return oldBytes;
 72                 }
 73                 boolean jdkClass = Utils.isJDKClass(clazz);
 74                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding instrumentation to event class &quot; + clazz.getName() + &quot; using retransform&quot;);
 75                 EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId, jdkClass, false);
 76                 byte[] bytes = ei.buildInstrumented();
 77                 Bytecode.log(clazz.getName(), bytes);
 78                 return bytes;
 79             }
 80             return oldBytes;
 81         } catch (Throwable t) {
 82             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation to event class &quot; + clazz.getName());
 83         }
 84         return oldBytes;
 85     }
 86 
</pre>
<hr />
<pre>
106         String eventName = &quot;&lt;Unknown&gt;&quot;;
107         try {
108             EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId, bootClassLoader, true);
109             eventName = ei.getEventName();
110             if (!JVMSupport.shouldInstrument(bootClassLoader,  ei.getEventName())) {
111                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for &quot; + eventName + &quot; since container support is missing&quot;);
112                 return oldBytes;
113             }
114 
115             if (!forceInstrumentation) {
116                 // Assume we are recording
117                 MetadataRepository mr = MetadataRepository.getInstance();
118                 // No need to generate bytecode if:
119                 // 1) Event class is disabled, and there is not an external configuration that overrides.
120                 // 2) Event class has @Registered(false)
121                 if (!mr.isEnabled(ei.getEventName()) &amp;&amp; !ei.isEnabled() || !ei.isRegistered()) {
122                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Skipping instrumentation for event type &quot; + eventName + &quot; since event was disabled on class load&quot;);
123                     return oldBytes;
124                 }
125             }

126             Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, &quot;Adding &quot; + (forceInstrumentation ? &quot;forced &quot; : &quot;&quot;) + &quot;instrumentation for event type &quot; + eventName + &quot; during initial class load&quot;);
127             byte[] bytes = ei.buildInstrumented();
128             Bytecode.log(ei.getClassName() + &quot;(&quot; + traceId + &quot;)&quot;, bytes);
129             return bytes;
130         } catch (Throwable t) {
131             Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, &quot;Unexpected error when adding instrumentation for event type &quot; + eventName);
132             return oldBytes;
133         }
134     }
135 
136     /**
137      * Called by the JVM to ensure metadata for internal events/types become public.
138      *
139      * Must be called after metadata repository has been initialized (JFR created).
140      *
141      */
142     static void unhideInternalTypes() {
143         MetadataRepository.unhideInternalTypes();
144     }
145 
146     /**
147      * Called by the JVM to create the recorder thread.
148      *
149      * @param systemThreadGroup  the system thread group
150      *
151      * @param contextClassLoader the context class loader.
152      *
153      * @return a new thread
154      */
155     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
<span class="line-modified">156         Thread thread = new Thread(systemThreadGroup, &quot;JFR Recorder Thread&quot;);</span>
<span class="line-added">157         thread.setContextClassLoader(contextClassLoader);</span>
<span class="line-added">158         return thread;</span>
159     }
160 }
</pre>
</td>
</tr>
</table>
<center><a href="JVMSupport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MetadataLoader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>