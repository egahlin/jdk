diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,12 +32,10 @@
 import java.time.Instant;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Consumer;
-import java.security.AccessControlContext;
-
 import jdk.jfr.Configuration;
 import jdk.jfr.EventSettings;
 import jdk.jfr.EventType;
 import jdk.jfr.Recording;
 import jdk.jfr.consumer.EventStream;
@@ -47,19 +45,16 @@
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.MetadataRepository;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.util.ValueFormatter;
 import jdk.jfr.internal.util.ValueParser;
-import jdk.jfr.internal.WriteableUserPath;
+import jdk.jfr.internal.WriteablePath;
 import jdk.jfr.internal.consumer.AbstractEventStream;
 import jdk.jfr.internal.consumer.EventDirectoryStream;
-import jdk.jfr.internal.consumer.FileAccess;
 
 /**
  * The management API in module jdk.management.jfr should be built on top of the
  * public API in jdk.jfr. Before putting more functionality here, consider if it
  * should not be part of the public API, and if not, please provide motivation
@@ -82,11 +77,10 @@
     // An alternative design would be to make FlightRecorder#getEventTypes
     // static, but it would the make the API look strange
     //
     public static List<EventType> getEventTypes() {
         // would normally be checked when a Flight Recorder instance is created
-        SecuritySupport.checkAccessFlightRecorder();
         if (JVMSupport.isNotAvailable()) {
             return List.of();
         }
         JDKEvents.initialize(); // make sure JDK events are available
         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
@@ -119,21 +113,20 @@
 
     // Get the textual representation when the destination was set, which
     // requires access to jdk.jfr.internal.PlatformRecording
     public static String getDestinationOriginalText(Recording recording) {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-        WriteableUserPath wup = pr.getDestination();
-        return wup == null ? null : wup.getOriginalText();
+        WriteablePath wp = pr.getDestination();
+        return wp == null ? null : wp.getPath().toString();
     }
 
     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
     // can abort if not all data is valid
-    public static void checkSetDestination(Recording recording, String destination) throws IOException{
+    public static void checkSetDestination(Recording recording, String destination) throws IOException {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
         if(destination != null){
-            WriteableUserPath wup = new WriteableUserPath(Paths.get(destination));
-            pr.checkSetDestination(wup);
+            pr.checkSetDestination(new WriteablePath(Paths.get(destination)));
         }
     }
 
     // Needed to modify setting using fluent API.
     public static EventSettings newEventSettings(EventSettingsModifier esm) {
@@ -141,11 +134,11 @@
     }
 
     // Needed callback to detect when a chunk has been parsed.
     public static void removePath(Recording recording, Path path) {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-        pr.removePath(new SafePath(path));
+        pr.removePath(path);
     }
 
     // Needed callback to detect when a chunk has been parsed.
     public static void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer) {
         EventDirectoryStream eds = (EventDirectoryStream) stream;
@@ -167,18 +160,14 @@
 
     // Can't use EventStream.openRepository(...) because
     // EventStream::onMetadataData need to supply MetadataEvent
     // with configuration objects
     public static EventStream newEventDirectoryStream(
-            @SuppressWarnings("removal")
-            AccessControlContext acc,
             Path directory,
             List<Configuration> confs) throws IOException {
         return new EventDirectoryStream(
-            acc,
             directory,
-            FileAccess.UNPRIVILEGED,
             null,
             confs,
             false
         );
     }
