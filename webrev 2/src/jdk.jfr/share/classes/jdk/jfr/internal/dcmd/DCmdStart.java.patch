diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,12 +27,10 @@
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.text.ParseException;
 import java.time.Duration;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -46,12 +44,10 @@
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.OldObjectSample;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport.SafePath;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.jfc.JFC;
 import jdk.jfr.internal.jfc.model.JFCModel;
 import jdk.jfr.internal.jfc.model.JFCModelException;
 import jdk.jfr.internal.jfc.model.XmlInput;
@@ -152,11 +148,11 @@
             }
             recording.setToDisk(disk.booleanValue());
         }
 
         recording.setSettings(s);
-        SafePath safePath = null;
+        Path dumpPath = null;
 
         // Generate dump filename if user has specified a time-bound recording
         if (duration != null && path == null) {
             path = resolvePath(recording, null).toString();
         }
@@ -171,14 +167,14 @@
                 if (Files.isDirectory(p)) {
                     // Decide destination filename at dump time
                     // Purposely avoid generating filename in Recording#setDestination due to
                     // security concerns
                     PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-                    pr.setDumpDirectory(new SafePath(p));
+                    pr.setDumpDirectory(p);
                 } else {
-                    safePath = resolvePath(recording, path);
-                    recording.setDestination(safePath.toPath());
+                    dumpPath = resolvePath(recording, path);
+                    recording.setDestination(dumpPath);
                 }
             } catch (IOException | InvalidPathException e) {
                 recording.close();
                 throw new DCmdException("Could not start recording, not able to write to file %s. %s ", path, e.getMessage());
             }
@@ -219,14 +215,14 @@
         if (recording.isToDisk() && duration == null && maxAge == null && maxSize == null) {
             print(" No limit specified, using maxsize=250MB as default.");
             recording.setMaxSize(250*1024L*1024L);
         }
 
-        if (safePath != null && duration != null) {
+        if (dumpPath != null && duration != null) {
             println(" The result will be written to:");
             println();
-            printPath(safePath);
+            printPath(dumpPath);
         } else {
             println();
             println();
             String cmd = duration == null ? "dump" : "stop";
             String fileOption = path == null ? "filename=FILEPATH " : "";
@@ -254,11 +250,11 @@
 
     private LinkedHashMap<String, String> configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {
         JFCModel model = new JFCModel(l -> logWarning(l));
         for (String setting : settings) {
             try {
-                model.parse(JFC.createSafePath(setting));
+                model.parse(JFC.ofPath(setting));
             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
                 throw new DCmdException(JFC.formatException("Could not", e, setting), e);
             }
         }
         try {
@@ -461,12 +457,12 @@
     }
 
     private static String jfcOptions() {
         try {
             StringBuilder sb = new StringBuilder();
-            for (SafePath s : SecuritySupport.getPredefinedJFCFiles()) {
-                String name = JFC.nameFromPath(s.toPath());
+            for (Path s : JFC.getPredefined()) {
+                String name = JFC.nameFromPath(s);
                 JFCModel model = JFCModel.create(s, l -> {});
                 sb.append('\n');
                 sb.append("Options for ").append(name).append(":\n");
                 sb.append('\n');
                 for (XmlInput input : model.getInputs()) {
