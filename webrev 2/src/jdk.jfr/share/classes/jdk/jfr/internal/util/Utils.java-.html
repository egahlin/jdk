<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.util;
 27 
 28 import java.io.IOException;
 29 import java.io.RandomAccessFile;
 30 import java.lang.annotation.Annotation;
 31 import java.lang.annotation.Repeatable;
 32 import java.lang.reflect.Array;
 33 import java.lang.reflect.Field;
 34 import java.lang.reflect.InvocationTargetException;
 35 import java.lang.reflect.Method;
 36 import java.lang.reflect.Modifier;
 37 import java.nio.file.Path;
 38 import java.time.Instant;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.Comparator;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 
 47 import jdk.internal.module.Checks;
 48 import jdk.jfr.Event;
 49 import jdk.jfr.EventType;
 50 import jdk.jfr.RecordingState;
 51 import jdk.jfr.ValueDescriptor;
 52 import jdk.jfr.internal.LogLevel;
 53 import jdk.jfr.internal.LogTag;
 54 import jdk.jfr.internal.Logger;
 55 import jdk.jfr.internal.MirrorEvent;
 56 import jdk.jfr.internal.SecuritySupport;
 57 import jdk.jfr.internal.Type;
 58 import jdk.jfr.internal.management.HiddenWait;
 59 import jdk.jfr.internal.settings.PeriodSetting;
 60 import jdk.jfr.internal.settings.StackTraceSetting;
 61 import jdk.jfr.internal.settings.ThresholdSetting;
 62 
 63 public final class Utils {
 64     private static final HiddenWait flushObject = new HiddenWait();
 65     private static final String LEGACY_EVENT_NAME_PREFIX = &quot;com.oracle.jdk.&quot;;
 66 
 67     /**
 68      * Return all annotations as they are visible in the source code
 69      *
 70      * @param clazz class to return annotations from
 71      *
 72      * @return list of annotation
 73      *
 74      */
 75     public static List&lt;Annotation&gt; getAnnotations(Class&lt;?&gt; clazz) {
 76         List&lt;Annotation&gt; annos = new ArrayList&lt;&gt;();
 77         for (Annotation a : clazz.getAnnotations()) {
 78             annos.addAll(getAnnotation(a));
 79         }
 80         return annos;
 81     }
 82 
 83     private static List&lt;? extends Annotation&gt; getAnnotation(Annotation a) {
 84         Class&lt;?&gt; annotated = a.annotationType();
 85         Method valueMethod = getValueMethod(annotated);
 86         if (valueMethod != null) {
 87             Class&lt;?&gt; returnType = valueMethod.getReturnType();
 88             if (returnType.isArray()) {
 89                 Class&lt;?&gt; candidate = returnType.getComponentType();
 90                 Repeatable r = candidate.getAnnotation(Repeatable.class);
 91                 if (r != null) {
 92                     Class&lt;?&gt; repeatClass = r.value();
 93                     if (annotated == repeatClass) {
 94                         return getAnnotationValues(a, valueMethod);
 95                     }
 96                 }
 97             }
 98         }
 99         return List.of(a);
100     }
101 
102     public static boolean isAfter(RecordingState stateToTest, RecordingState b) {
103         return stateToTest.ordinal() &gt; b.ordinal();
104     }
105 
106     public static boolean isBefore(RecordingState stateToTest, RecordingState b) {
107         return stateToTest.ordinal() &lt; b.ordinal();
108     }
109 
110     public static boolean isState(RecordingState stateToTest, RecordingState... states) {
111         for (RecordingState s : states) {
112             if (s == stateToTest) {
113                 return true;
114             }
115         }
116         return false;
117     }
118 
119     private static List&lt;Annotation&gt; getAnnotationValues(Annotation a, Method valueMethod) {
120         try {
121             return Arrays.asList((Annotation[]) valueMethod.invoke(a, new Object[0]));
122         } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
123             return new ArrayList&lt;&gt;();
124         }
125     }
126 
127     private static Method getValueMethod(Class&lt;?&gt; annotated) {
128         try {
129             return annotated.getMethod(&quot;value&quot;, new Class&lt;?&gt;[0]);
130         } catch (NoSuchMethodException e) {
131             return null;
132         }
133     }
134 
135     public static void touch(Path dumpFile) throws IOException {
136         RandomAccessFile raf = new RandomAccessFile(dumpFile.toFile(), &quot;rw&quot;);
137         raf.close();
138     }
139 
140     public static Class&lt;?&gt; unboxType(Class&lt;?&gt; t) {
141         if (t == Integer.class) {
142             return int.class;
143         }
144         if (t == Long.class) {
145             return long.class;
146         }
147         if (t == Float.class) {
148             return float.class;
149         }
150         if (t == Double.class) {
151             return double.class;
152         }
153         if (t == Byte.class) {
154             return byte.class;
155         }
156         if (t == Short.class) {
157             return short.class;
158         }
159         if (t == Boolean.class) {
160             return boolean.class;
161         }
162         if (t == Character.class) {
163             return char.class;
164         }
165         return t;
166     }
167 
168     public static Map&lt;String, String&gt; sanitizeNullFreeStringMap(Map&lt;String, String&gt; settings) {
169         HashMap&lt;String, String&gt; map = HashMap.newHashMap(settings.size());
170         for (Map.Entry&lt;String, String&gt; e : settings.entrySet()) {
171             String key = e.getKey();
172             if (key == null) {
173                 throw new NullPointerException(&quot;Null key is not allowed in map&quot;);
174             }
175             String value = e.getValue();
176             if (value == null) {
177                 throw new NullPointerException(&quot;Null value is not allowed in map&quot;);
178             }
179             map.put(key, value);
180         }
181         return map;
182     }
183 
184     public static &lt;T&gt; boolean compareLists(List&lt;T&gt; a, List&lt;T&gt; b, Comparator&lt;T&gt; c) {
185         int size = a.size();
186         if (size != b.size()) {
187             return false;
188         }
189         for (int i = 0; i &lt; size; i++) {
190             if (c.compare(a.get(i), b.get(i)) != 0) {
191                 return false;
192             }
193         }
194         return true;
195     }
196 
197     public static &lt;T&gt; List&lt;T&gt; sanitizeNullFreeList(List&lt;T&gt; elements, Class&lt;T&gt; clazz) {
198         List&lt;T&gt; sanitized = new ArrayList&lt;&gt;(elements.size());
199         for (T element : elements) {
200             if (element == null) {
201                 throw new NullPointerException(&quot;Null is not an allowed element in list&quot;);
202             }
203             if (element.getClass() != clazz) {
204                 throw new ClassCastException();
205             }
206             sanitized.add(element);
207         }
208         return sanitized;
209     }
210 
211     public static List&lt;Field&gt; getVisibleEventFields(Class&lt;?&gt; clazz) {
212         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
213         for (Class&lt;?&gt; c = clazz; !Utils.isEventBaseClass(c); c = c.getSuperclass()) {
214             for (Field field : c.getDeclaredFields()) {
215                 // skip private field in base classes
216                 if (c == clazz || !Modifier.isPrivate(field.getModifiers())) {
217                     fields.add(field);
218                 }
219             }
220         }
221         return fields;
222     }
223 
224     public static boolean isEventBaseClass(Class&lt;?&gt; clazz) {
225         if (jdk.internal.event.Event.class == clazz) {
226             return true;
227         }
228         if (jdk.jfr.internal.MirrorEvent.class == clazz) {
229             return true;
230         }
231         return false;
232     }
233 
234     public static void ensureValidEventSubclass(Class&lt;?&gt; eventClass) {
235         if (jdk.internal.event.Event.class.isAssignableFrom(eventClass) &amp;&amp; Modifier.isAbstract(eventClass.getModifiers())) {
236             throw new IllegalArgumentException(&quot;Abstract event classes are not allowed&quot;);
237         }
238         if (eventClass == Event.class || eventClass == jdk.internal.event.Event.class || !jdk.internal.event.Event.class.isAssignableFrom(eventClass)) {
239             throw new IllegalArgumentException(&quot;Must be a subclass to &quot; + Event.class.getName());
240         }
241     }
242 
243     public static void ensureInitialized(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
244         SecuritySupport.ensureClassIsInitialized(eventClass);
245     }
246 
247     public static Object makePrimitiveArray(String typeName, List&lt;Object&gt; values) {
248         Class&lt;?&gt; componentType = makePrimitiveType(typeName);
249         if (componentType == null) {
250             return null;
251         }
252         int length = values.size();
253         Object array =  Array.newInstance(componentType, length);
254         for (int index = 0; index &lt; length; index++) {
255             Array.set(array, index, values.get(index));
256         }
257         return array;
258     }
259 
260     private static Class&lt;?&gt; makePrimitiveType(String typeName) {
261         return switch(typeName) {
262             case &quot;void&quot; -&gt; null;
263             case &quot;java.lang.String&quot; -&gt; String.class;
264             default -&gt; Class.forPrimitiveName(typeName);
265         };
266     }
267 
268     public static boolean isSettingVisible(long typeId, boolean hasEventHook) {
269         if (ThresholdSetting.isType(typeId)) {
270             return !hasEventHook;
271         }
272         if (PeriodSetting.isType(typeId)) {
273             return hasEventHook;
274         }
275         if (StackTraceSetting.isType(typeId)) {
276             return !hasEventHook;
277         }
278         return true;
279     }
280 
281     public static Type getValidType(Class&lt;?&gt; type, String name) {
282         Objects.requireNonNull(type, &quot;Null is not a valid type for value descriptor &quot; + name);
283         if (type.isArray()) {
284             type = type.getComponentType();
285             if (type != String.class &amp;&amp; !type.isPrimitive()) {
286                 throw new IllegalArgumentException(&quot;Only arrays of primitives and Strings are allowed&quot;);
287             }
288         }
289 
290         Type knownType = Type.getKnownType(type);
291         if (knownType == null || knownType == Type.STACK_TRACE) {
292             throw new IllegalArgumentException(&quot;Only primitive types, java.lang.Thread, java.lang.String and java.lang.Class are allowed for value descriptors. &quot; + type.getName());
293         }
294         return knownType;
295     }
296 
297     public static String upgradeLegacyJDKEvent(String eventName) {
298         if (eventName.length() &lt;= LEGACY_EVENT_NAME_PREFIX.length()) {
299             return eventName;
300         }
301         if (eventName.startsWith(LEGACY_EVENT_NAME_PREFIX)) {
302             int index = eventName.lastIndexOf(&quot;.&quot;);
303             if (index == LEGACY_EVENT_NAME_PREFIX.length() - 1) {
304                 return Type.EVENT_NAME_PREFIX + eventName.substring(index + 1);
305             }
306         }
307         return eventName;
308     }
309 
310     public static void verifyMirror(Class&lt;? extends MirrorEvent&gt; mirror, Class&lt;?&gt; real) {
311         Class&lt;?&gt; cMirror = Objects.requireNonNull(mirror);
312         Class&lt;?&gt; cReal = Objects.requireNonNull(real);
313 
314         Map&lt;String, Field&gt; mirrorFields = new HashMap&lt;&gt;();
315         while (cMirror != null) {
316             for (Field f : cMirror.getDeclaredFields()) {
317                 if (isSupportedType(f.getType())) {
318                     mirrorFields.put(f.getName(), f);
319                 }
320             }
321             cMirror = cMirror.getSuperclass();
322         }
323         while (cReal != null) {
324             for (Field realField : cReal.getDeclaredFields()) {
325                 if (isSupportedType(realField.getType()) &amp;&amp; !realField.isSynthetic()) {
326                     String fieldName = realField.getName();
327                     Field mirrorField = mirrorFields.get(fieldName);
328                     if (mirrorField == null) {
329                         throw new InternalError(&quot;Missing mirror field for &quot; + cReal.getName() + &quot;#&quot; + fieldName);
330                     }
331                     if (realField.getType() != mirrorField.getType()) {
332                         throw new InternalError(&quot;Incorrect type for mirror field &quot; + fieldName);
333                     }
334                     if (realField.getModifiers() != mirrorField.getModifiers()) {
335                         throw new InternalError(&quot;Incorrect modifier for mirror field &quot; + fieldName);
336                     }
337                     mirrorFields.remove(fieldName);
338                 }
339             }
340             cReal = cReal.getSuperclass();
341         }
342 
343         if (!mirrorFields.isEmpty()) {
344             throw new InternalError(&quot;Found additional fields in mirror class &quot; + mirrorFields.keySet());
345         }
346     }
347 
348     private static boolean isSupportedType(Class&lt;?&gt; type) {
349         if (Modifier.isTransient(type.getModifiers()) || Modifier.isStatic(type.getModifiers())) {
350             return false;
351         }
352         return Type.isValidJavaFieldType(type.getName());
353     }
354 
355     public static void notifyFlush() {
356         synchronized (flushObject) {
357             flushObject.notifyAll();
358         }
359     }
360 
361     public static void waitFlush(long timeOut) {
362         flushObject.takeNap(timeOut);
363     }
364 
365     public static Instant epochNanosToInstant(long epochNanos) {
366         return Instant.ofEpochSecond(0, epochNanos);
367     }
368 
369     public static long timeToNanos(Instant timestamp) {
370         return timestamp.getEpochSecond() * 1_000_000_000L + timestamp.getNano();
371     }
372 
373     public static String validTypeName(String typeName, String defaultTypeName) {
374         if (Checks.isClassName(typeName)) {
375             return typeName;
376         } else {
377             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;@Name ignored, not a valid Java type name.&quot;);
378             return defaultTypeName;
379         }
380     }
381 
382     public static String validJavaIdentifier(String identifier, String defaultIdentifier) {
383         if (Checks.isJavaIdentifier(identifier)) {
384             return identifier;
385         } else {
386             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;@Name ignored, not a valid Java identifier.&quot;);
387             return defaultIdentifier;
388         }
389     }
390 
391     public static void ensureJavaIdentifier(String name) {
392         if (!Checks.isJavaIdentifier(name)) {
393             throw new IllegalArgumentException(&quot;&#39;&quot; + name + &quot;&#39; is not a valid Java identifier&quot;);
394         }
395     }
396 
397     public static String makeSimpleName(EventType type) {
398       return makeSimpleName(type.getName());
399     }
400 
401     public static String makeSimpleName(String qualified) {
402         return qualified.substring(qualified.lastIndexOf(&quot;.&quot;) + 1);
403     }
404 
405     public static String format(String template, Map&lt;String, String&gt; parameters) {
406         StringBuilder sb = new StringBuilder(3 * template.length() / 2);
407         List&lt;String&gt; keys = new ArrayList&lt;&gt;(parameters.keySet());
408         // Sort so longest keys are checked first in case keys overlap.
409         keys.sort((a, b) -&gt; b.length() - a.length());
410         for (int i = 0; i &lt; template.length(); i++) {
411             int index = i;
412             for (int j = 0; j &lt; keys.size(); j++) {
413                 String key = keys.get(j);
414                 if (template.startsWith(key, i)) {
415                     sb.append(parameters.get(key));
416                     i += key.length() - 1;
417                     break;
418                 }
419             }
420             if (i == index) {
421                 sb.append(template.charAt(i));
422             }
423         }
424         return sb.toString();
425     }
426 
427     public static boolean isJDKClass(Class&lt;?&gt; type) {
428         return type.getClassLoader() == null;
429         // In the future we might want to also do:
430         // type.getClassLoader() == ClassLoader.getPlatformClassLoader();
431         // but only if it is safe and there is a mechanism to register event
432         // classes in other modules besides jdk.jfr and java.base.
433     }
434 
435     public static long multiplyOverflow(long a, long b, long defaultValue) {
436         try {
437             return Math.multiplyExact(a, b);
438         } catch (ArithmeticException ae) {
439             return defaultValue;
440         }
441     }
442 
443     public static ValueDescriptor findField(List&lt;ValueDescriptor&gt; fields, String name) {
444         for (ValueDescriptor v : fields) {
445             if (v.getName().equals(name)) {
446                 return v;
447             }
448         }
449         return null;
450     }
451 }
    </pre>
  </body>
</html>