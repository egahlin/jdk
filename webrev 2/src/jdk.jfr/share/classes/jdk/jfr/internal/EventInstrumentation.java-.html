<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.lang.constant.ClassDesc;
 29 import java.lang.constant.MethodTypeDesc;
 30 import java.lang.reflect.Field;
 31 import java.lang.reflect.Modifier;
 32 import java.util.ArrayList;
 33 import java.util.HashSet;
 34 import java.util.LinkedHashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Set;
 38 import java.util.function.Consumer;
 39 
 40 import java.lang.classfile.Annotation;
 41 import java.lang.classfile.AnnotationElement;
 42 import java.lang.classfile.AnnotationValue;
 43 import java.lang.classfile.ClassElement;
 44 import java.lang.classfile.ClassModel;
 45 import java.lang.classfile.ClassFile;
 46 import java.lang.classfile.CodeBuilder;
 47 import java.lang.classfile.CodeBuilder.BlockCodeBuilder;
 48 import java.lang.classfile.FieldModel;
 49 import java.lang.classfile.Label;
 50 import java.lang.classfile.MethodModel;
 51 import java.lang.classfile.Opcode;
 52 import java.lang.classfile.TypeKind;
 53 import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
 54 import jdk.jfr.internal.event.EventConfiguration;
 55 import jdk.jfr.internal.event.EventWriter;
 56 import jdk.jfr.Enabled;
 57 import jdk.jfr.Event;
 58 import jdk.jfr.Name;
 59 import jdk.jfr.Registered;
 60 import jdk.jfr.SettingControl;
 61 import jdk.jfr.SettingDefinition;
 62 import jdk.jfr.internal.util.Utils;
 63 import jdk.jfr.internal.util.Bytecode;
 64 import jdk.jfr.internal.util.ImplicitFields;
 65 import jdk.jfr.internal.util.Bytecode.FieldDesc;
 66 import jdk.jfr.internal.util.Bytecode.MethodDesc;
 67 import static jdk.jfr.internal.util.Bytecode.invokevirtual;
 68 import static jdk.jfr.internal.util.Bytecode.invokestatic;
 69 import static jdk.jfr.internal.util.Bytecode.getfield;
 70 import static jdk.jfr.internal.util.Bytecode.putfield;
 71 import static jdk.jfr.internal.util.Bytecode.classDesc;
 72 
 73 /**
 74  * Class responsible for adding instrumentation to a subclass of {@link Event}.
 75  *
 76  */
 77 final class EventInstrumentation {
 78 
 79     private record SettingDesc(ClassDesc paramType, String methodName) {
 80     }
 81 
 82     private static final FieldDesc FIELD_DURATION = FieldDesc.of(long.class, ImplicitFields.DURATION);
 83     private static final FieldDesc FIELD_EVENT_CONFIGURATION = FieldDesc.of(Object.class, &quot;eventConfiguration&quot;);;
 84     private static final FieldDesc FIELD_START_TIME = FieldDesc.of(long.class, ImplicitFields.START_TIME);
 85     private static final ClassDesc ANNOTATION_ENABLED = classDesc(Enabled.class);
 86     private static final ClassDesc ANNOTATION_NAME = classDesc(Name.class);
 87     private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);
 88     private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);
 89     private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);
 90     private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);
 91     private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);
 92     private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of(&quot;jdk.jfr.internal.event.EventWriterFactory&quot;);
 93     private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);
 94     private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);
 95     private static final MethodDesc METHOD_BEGIN = MethodDesc.of(&quot;begin&quot;, &quot;()V&quot;);
 96     private static final MethodDesc METHOD_COMMIT = MethodDesc.of(&quot;commit&quot;, &quot;()V&quot;);
 97     private static final MethodDesc METHOD_DURATION = MethodDesc.of(&quot;duration&quot;, &quot;(J)J&quot;);
 98     private static final MethodDesc METHOD_ENABLED = MethodDesc.of(&quot;enabled&quot;, &quot;()Z&quot;);
 99     private static final MethodDesc METHOD_END = MethodDesc.of(&quot;end&quot;, &quot;()V&quot;);
100     private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
101     private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of(&quot;getSetting&quot;, SettingControl.class, int.class);
102     private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of(&quot;shouldCommit&quot;, &quot;()Z&quot;);
103     private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of(&quot;getEventWriter&quot;, &quot;(J)&quot; + TYPE_EVENT_WRITER.descriptorString());
104     private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of(&quot;isEnabled&quot;, &quot;()Z&quot;);
105     private static final MethodDesc METHOD_RESET = MethodDesc.of(&quot;reset&quot;, &quot;()V&quot;);
106     private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of(&quot;shouldCommit&quot;, &quot;(J)Z&quot;);
107     private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of(&quot;timestamp&quot;, &quot;()J&quot;);
108 
109     private final ClassModel classModel;
110     private final List&lt;SettingDesc&gt; settingDescs;
111     private final List&lt;FieldDesc&gt; fieldDescs;;
112     private final String eventName;
113     private final String className;
114     private final Class&lt;?&gt; superClass;
115     private final boolean untypedEventConfiguration;
116     private final MethodDesc staticCommitMethod;
117     private final long eventTypeId;
118     private final boolean guardEventConfiguration;
119     private final boolean isJDK;
120     private final Map&lt;MethodDesc, Consumer&lt;CodeBuilder&gt;&gt; methodUpdates = new LinkedHashMap&lt;&gt;();
121     private final ImplicitFields implicitFields;
122 
123     EventInstrumentation(Class&lt;?&gt; superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {
124         this.eventTypeId = id;
125         this.superClass = superClass;
126         this.isJDK = isJDK;
127         this.classModel = createClassModel(bytes);
128         this.className = classModel.thisClass().asInternalName().replace(&quot;/&quot;, &quot;.&quot;);
129         String name = annotationValue(classModel, ANNOTATION_NAME, String.class);
130         this.eventName = name == null ? className : name;
131         this.implicitFields = determineImplicitFields();
132         this.settingDescs = buildSettingDescs(superClass, classModel);
133         this.fieldDescs = buildFieldDescs(superClass, classModel);
134         this.staticCommitMethod = isJDK ? findStaticCommitMethod(classModel, fieldDescs) : null;
135         this.untypedEventConfiguration = hasUntypedConfiguration();
136         // Corner case when we are forced to generate bytecode
137         // (bytesForEagerInstrumentation)
138         // We can&#39;t reference EventConfiguration::isEnabled() before event class has
139         // been registered,
140         // so we add a guard against a null reference.
141         this.guardEventConfiguration = guardEventConfiguration;
142     }
143 
144     private ImplicitFields determineImplicitFields() {
145         if (isJDK) {
146             Class&lt;?&gt; eventClass = MirrorEvents.find(isJDK, className);
147             if (eventClass != null) {
148                 return new ImplicitFields(eventClass);
149             }
150         }
151         ImplicitFields ifs = new ImplicitFields(superClass);
152         String[] value = annotationValue(classModel, ANNOTATION_REMOVE_FIELDS, String[].class);
153         if (value != null) {
154             ifs.removeFields(value);
155         }
156         return ifs;
157     }
158 
159     static MethodDesc findStaticCommitMethod(ClassModel classModel, List&lt;FieldDesc&gt; fields) {
160         StringBuilder sb = new StringBuilder();
161         sb.append(&quot;(&quot;);
162         for (FieldDesc field : fields) {
163             sb.append(field.type().descriptorString());
164         }
165         sb.append(&quot;)V&quot;);
166         MethodDesc m = MethodDesc.of(&quot;commit&quot;, sb.toString());
167         for (MethodModel method : classModel.methods()) {
168             String d = method.methodTypeSymbol().descriptorString();
169             if (method.methodName().equalsString(&quot;commit&quot;) &amp;&amp; m.descriptor().descriptorString().equals(d)) {
170                 return m;
171             }
172         }
173         return null;
174     }
175 
176     private boolean hasUntypedConfiguration() {
177         for (FieldModel f : classModel.fields()) {
178             if (f.fieldName().equalsString(FIELD_EVENT_CONFIGURATION.name())) {
179                 return f.fieldType().equalsString(TYPE_OBJECT.descriptorString());
180             }
181         }
182         throw new InternalError(&quot;Class missing configuration field&quot;);
183     }
184 
185     public String getClassName() {
186         return classModel.thisClass().asInternalName().replace(&quot;/&quot;, &quot;.&quot;);
187     }
188 
189     private ClassModel createClassModel(byte[] bytes) {
190         return ClassFile.of().parse(bytes);
191     }
192 
193     boolean isRegistered() {
194         Boolean result = annotationValue(classModel, ANNOTATION_REGISTERED, Boolean.class);
195         if (result != null) {
196             return result.booleanValue();
197         }
198         if (superClass != null) {
199             Registered r = superClass.getAnnotation(Registered.class);
200             if (r != null) {
201                 return r.value();
202             }
203         }
204         return true;
205     }
206 
207     boolean isEnabled() {
208         Boolean result = annotationValue(classModel, ANNOTATION_ENABLED, Boolean.class);
209         if (result != null) {
210             return result.booleanValue();
211         }
212         if (superClass != null) {
213             Enabled e = superClass.getAnnotation(Enabled.class);
214             if (e != null) {
215                 return e.value();
216             }
217         }
218         return true;
219     }
220 
221     @SuppressWarnings(&quot;unchecked&quot;)
222     // Only supports String, String[] and Boolean values
223     private static &lt;T&gt; T annotationValue(ClassModel classModel, ClassDesc classDesc, Class&lt;T&gt; type) {
224         String typeDescriptor = classDesc.descriptorString();
225         for (ClassElement ce : classModel) {
226             if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {
227                 for (Annotation a : rvaa.annotations()) {
228                     if (a.className().equalsString(typeDescriptor)) {
229                         if (a.elements().size() == 1) {
230                             AnnotationElement ae = a.elements().getFirst();
231                             if (ae.name().equalsString(&quot;value&quot;)) {
232                                 if (ae.value() instanceof AnnotationValue.OfBoolean ofb &amp;&amp; type.equals(Boolean.class)) {
233                                     Boolean b = ofb.booleanValue();
234                                     return (T)b;
235                                 }
236                                 if (ae.value() instanceof AnnotationValue.OfString ofs &amp;&amp; type.equals(String.class)) {
237                                     String s = ofs.stringValue();
238                                     return (T)s;
239                                 }
240                                 if (ae.value() instanceof AnnotationValue.OfArray ofa &amp;&amp; type.equals(String[].class)) {
241                                     List&lt;AnnotationValue&gt; list = ofa.values();
242                                     String[] array = new String[list.size()];
243                                     int index = 0;
244                                     for (AnnotationValue av : list) {
245                                         var avs = (AnnotationValue.OfString)av;
246                                         array[index++] = avs.stringValue();
247                                     }
248                                     return (T)array;
249                                 }
250                             }
251                         }
252                     }
253                 }
254             }
255         }
256         return null;
257     }
258 
259     private static List&lt;SettingDesc&gt; buildSettingDescs(Class&lt;?&gt; superClass, ClassModel classModel) {
260         Set&lt;String&gt; methodSet = new HashSet&lt;&gt;();
261         List&lt;SettingDesc&gt; settingDescs = new ArrayList&lt;&gt;();
262         for (MethodModel m : classModel.methods()) {
263             for (var me : m) {
264                 if (me instanceof RuntimeVisibleAnnotationsAttribute rvaa) {
265                     for (Annotation a : rvaa.annotations()) {
266                         // We can&#39;t really validate the method at this
267                         // stage. We would need to check that the parameter
268                         // is an instance of SettingControl.
269                         if (a.className().equalsString(TYPE_SETTING_DEFINITION.descriptorString())) {
270                             String name = m.methodName().stringValue();
271                             // Use @Name if it exists
272                             for (Annotation nameCandidate : rvaa.annotations()) {
273                                 if (nameCandidate.className().equalsString(ANNOTATION_NAME.descriptorString())) {
274                                     if (nameCandidate.elements().size() == 1) {
275                                         AnnotationElement ae = nameCandidate.elements().getFirst();
276                                         if (ae.name().equalsString(&quot;value&quot;)) {
277                                             if (ae.value() instanceof AnnotationValue.OfString s) {
278                                                 name = Utils.validJavaIdentifier(s.stringValue(), name);
279                                             }
280                                         }
281                                     }
282                                 }
283                             }
284                             // Add setting if method returns boolean and has one parameter
285                             MethodTypeDesc mtd = m.methodTypeSymbol();
286                             if (&quot;Z&quot;.equals(mtd.returnType().descriptorString())) {
287                                 if (mtd.parameterList().size() == 1) {
288                                     ClassDesc type = mtd.parameterList().getFirst();
289                                     if (type.isClassOrInterface()) {
290                                         String methodName = m.methodName().stringValue();
291                                         methodSet.add(methodName);
292                                         settingDescs.add(new SettingDesc(type, methodName));
293                                     }
294                                 }
295                             }
296                         }
297                     }
298                 }
299             }
300         }
301         for (Class&lt;?&gt; c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {
302             for (java.lang.reflect.Method method : c.getDeclaredMethods()) {
303                 if (!methodSet.contains(method.getName())) {
304                     // skip private method in base classes
305                     if (!Modifier.isPrivate(method.getModifiers())) {
306                         if (method.getReturnType().equals(Boolean.TYPE)) {
307                             if (method.getParameterCount() == 1) {
308                                 Class&lt;?&gt; type = method.getParameters()[0].getType();
309                                 if (SettingControl.class.isAssignableFrom(type)) {
310                                     ClassDesc paramType = Bytecode.classDesc(type);
311                                     methodSet.add(method.getName());
312                                     settingDescs.add(new SettingDesc(paramType, method.getName()));
313                                 }
314                             }
315                         }
316                     }
317                 }
318             }
319         }
320         return settingDescs;
321     }
322 
323     private List&lt;FieldDesc&gt; buildFieldDescs(Class&lt;?&gt; superClass, ClassModel classModel) {
324         Set&lt;String&gt; fieldSet = new HashSet&lt;&gt;();
325         List&lt;FieldDesc&gt; fieldDescs = new ArrayList&lt;&gt;(classModel.fields().size());
326         // These two fields are added by native as &#39;transient&#39; so they will be
327         // ignored by the loop below.
328         // The benefit of adding them manually is that we can
329         // control in which order they occur and we can add @Name, @Description
330         // in Java, instead of in native. It also means code for adding implicit
331         // fields for native can be reused by Java.
332         fieldDescs.add(FIELD_START_TIME);
333         if (implicitFields.hasDuration()) {
334             fieldDescs.add(FIELD_DURATION);
335         }
336         for (FieldModel field : classModel.fields()) {
337             if (!fieldSet.contains(field.fieldName().stringValue()) &amp;&amp; isValidField(field.flags().flagsMask(), field.fieldTypeSymbol())) {
338                 FieldDesc fi = FieldDesc.of(field.fieldTypeSymbol(), field.fieldName().stringValue());
339                 fieldDescs.add(fi);
340                 fieldSet.add(field.fieldName().stringValue());
341             }
342         }
343         for (Class&lt;?&gt; c = superClass; jdk.internal.event.Event.class != c; c = c.getSuperclass()) {
344             for (Field field : c.getDeclaredFields()) {
345                 // skip private field in base classes
346                 if (!Modifier.isPrivate(field.getModifiers())) {
347                     if (isValidField(field.getModifiers(), field.getType().getName())) {
348                         String fieldName = field.getName();
349                         if (!fieldSet.contains(fieldName)) {
350                             fieldDescs.add(FieldDesc.of(field.getType(), fieldName));
351                             fieldSet.add(fieldName);
352                         }
353                     }
354                 }
355             }
356         }
357         return fieldDescs;
358     }
359 
360     public static boolean isValidField(int access, ClassDesc classDesc) {
361         String className = classDesc.packageName();
362         if (!className.isEmpty()) {
363             className = className + &quot;.&quot;;
364         }
365         className += classDesc.displayName();
366         return isValidField(access, className);
367     }
368 
369     public static boolean isValidField(int access, String className) {
370         if (Modifier.isTransient(access) || Modifier.isStatic(access)) {
371             return false;
372         }
373         return Type.isValidJavaFieldType(className);
374     }
375 
376     public byte[] buildInstrumented() {
377         makeInstrumented();
378         return toByteArray();
379     }
380 
381     byte[] toByteArray() {
382         return ClassFile.of().build(classModel.thisClass().asSymbol(), classBuilder -&gt; {
383             for (ClassElement ce : classModel) {
384                 boolean updated = false;
385                 if (ce instanceof MethodModel method) {
386                     Consumer&lt;CodeBuilder&gt; methodUpdate = findMethodUpdate(method);
387                     if (methodUpdate != null) {
388                         classBuilder.withMethod(method.methodName().stringValue(), method.methodTypeSymbol(), method.flags().flagsMask(), methodBuilder -&gt; {
389                             methodBuilder.withCode(methodUpdate);
390                         });
391                         updated = true;
392                     }
393                 }
394                 if (!updated) {
395                     classBuilder.with(ce);
396                 }
397             }
398         });
399     }
400 
401     public byte[] buildUninstrumented() {
402         makeUninstrumented();
403         return toByteArray();
404     }
405 
406     private void throwMissingDuration(CodeBuilder codeBuilder, String method) {
407         String message = &quot;Cannot use method &quot; + method + &quot; when event lacks duration field&quot;;
408         Bytecode.throwException(codeBuilder, TYPE_ISE, message);
409     }
410 
411     private void makeInstrumented() {
412         // MyEvent#isEnabled()
413         updateEnabledMethod(METHOD_IS_ENABLED);
414 
415         // MyEvent#begin()
416         updateMethod(METHOD_BEGIN, codeBuilder -&gt; {
417             if (!implicitFields.hasDuration()) {
418                 throwMissingDuration(codeBuilder, &quot;begin&quot;);
419             } else {
420                 codeBuilder.aload(0);
421                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
422                 putfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);
423                 codeBuilder.return_();
424             }
425         });
426 
427         // MyEvent#end()
428         updateMethod(METHOD_END, codeBuilder -&gt; {
429             if (!implicitFields.hasDuration()) {
430                 throwMissingDuration(codeBuilder, &quot;end&quot;);
431             } else {
432                 codeBuilder.aload(0);
433                 codeBuilder.aload(0);
434                 getfield(codeBuilder, getEventClassDesc(), FIELD_START_TIME);
435                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_DURATION);
436                 putfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);
437                 codeBuilder.return_();
438             }
439         });
440 
441         // MyEvent#commit() or static MyEvent#commit(...)
442         MethodDesc m = staticCommitMethod == null ? METHOD_COMMIT : staticCommitMethod;
443         updateMethod(m, codeBuilder -&gt; {
444             Label excluded = codeBuilder.newLabel();
445             Label end = codeBuilder.newLabel();
446             codeBuilder.trying(blockCodeBuilder -&gt; {
447                 if (staticCommitMethod != null) {
448                     updateStaticCommit(blockCodeBuilder, excluded);
449                 } else {
450                     updateInstanceCommit(blockCodeBuilder, end, excluded);
451                 }
452                 // stack: [integer]
453                 // notified -&gt; restart event write attempt
454                 blockCodeBuilder.ifeq(blockCodeBuilder.startLabel());
455                 // stack: []
456                 blockCodeBuilder.goto_(end);
457             }, catchBuilder -&gt; {
458                 catchBuilder.catchingAll(catchAllHandler -&gt; {
459                     getEventWriter(catchAllHandler);
460                     // stack: [ex] [EW]
461                     catchAllHandler.dup();
462                     // stack: [ex] [EW] [EW]
463                     Label rethrow = catchAllHandler.newLabel();
464                     catchAllHandler.ifnull(rethrow);
465                     // stack: [ex] [EW]
466                     catchAllHandler.dup();
467                     // stack: [ex] [EW] [EW]
468                     invokevirtual(catchAllHandler, TYPE_EVENT_WRITER, METHOD_RESET);
469                     catchAllHandler.labelBinding(rethrow);
470                     // stack:[ex] [EW]
471                     catchAllHandler.pop();
472                     // stack:[ex]
473                     catchAllHandler.athrow();
474                 });
475             });
476             codeBuilder.labelBinding(excluded);
477             // stack: [EW]
478             codeBuilder.pop();
479             codeBuilder.labelBinding(end);
480             // stack: []
481             codeBuilder.return_();
482         });
483 
484         // MyEvent#shouldCommit()
485         updateMethod(METHOD_EVENT_SHOULD_COMMIT, codeBuilder -&gt; {
486             Label fail = codeBuilder.newLabel();
487             if (guardEventConfiguration) {
488                 getEventConfiguration(codeBuilder);
489                 codeBuilder.ifnull(fail);
490             }
491             // if (!eventConfiguration.shouldCommit(duration) goto fail;
492             getEventConfiguration(codeBuilder);
493             codeBuilder.aload(0);
494             getfield(codeBuilder, getEventClassDesc(), FIELD_DURATION);
495             invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);
496             codeBuilder.ifeq(fail);
497             for (int index = 0; index &lt; settingDescs.size(); index++) {
498                 SettingDesc sd = settingDescs.get(index);
499                 // if (!settingsMethod(eventConfiguration.settingX)) goto fail;
500                 codeBuilder.aload(0);
501                 getEventConfiguration(codeBuilder);
502                 codeBuilder.loadConstant(index);
503                 invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);
504                 MethodTypeDesc mdesc = MethodTypeDesc.ofDescriptor(&quot;(&quot; + sd.paramType().descriptorString() + &quot;)Z&quot;);
505                 codeBuilder.checkcast(sd.paramType());
506                 codeBuilder.invokevirtual(getEventClassDesc(), sd.methodName(), mdesc);
507                 codeBuilder.ifeq(fail);
508             }
509             // return true
510             codeBuilder.iconst_1();
511             codeBuilder.ireturn();
512             // return false
513             codeBuilder.labelBinding(fail);
514             codeBuilder.iconst_0();
515             codeBuilder.ireturn();
516         });
517 
518         if (isJDK) {
519             if (hasStaticMethod(METHOD_ENABLED)) {
520                 updateEnabledMethod(METHOD_ENABLED);
521             }
522 
523             updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, codeBuilder -&gt; {
524                 Label fail = codeBuilder.newLabel();
525                 if (guardEventConfiguration) {
526                     // if (eventConfiguration == null) goto fail;
527                     getEventConfiguration(codeBuilder);
528                     codeBuilder.ifnull(fail);
529                 }
530                 // return eventConfiguration.shouldCommit(duration);
531                 getEventConfiguration(codeBuilder);
532                 codeBuilder.lload(0);
533                 codeBuilder.invokevirtual(TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.name(), METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT.descriptor());
534                 codeBuilder.ireturn();
535                 // fail:
536                 codeBuilder.labelBinding(fail);
537                 // return false
538                 codeBuilder.iconst_0();
539                 codeBuilder.ireturn();
540             });
541             updateIfStaticMethodExists(METHOD_TIME_STAMP, codeBuilder -&gt; {
542                 invokestatic(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
543                 codeBuilder.lreturn();
544             });
545         }
546     }
547 
548     void updateStaticCommit(BlockCodeBuilder blockCodeBuilder, Label excluded) {
549         // indexes the argument type array, the argument type array does not include
550         // &#39;this&#39;
551         int argIndex = 0;
552         // indexes the proper slot in the local variable table, takes type size into
553         // account, therefore sometimes argIndex != slotIndex
554         int slotIndex = 0;
555         int fieldIndex = 0;
556         ClassDesc[] argumentTypes = staticCommitMethod.descriptor().parameterArray();
557         TypeKind tk = null;
558         getEventWriter(blockCodeBuilder);
559         // stack: [EW],
560         blockCodeBuilder.dup();
561         // stack: [EW], [EW]
562         // write begin event
563         getEventConfiguration(blockCodeBuilder);
564         // stack: [EW], [EW], [EventConfiguration]
565         blockCodeBuilder.loadConstant(eventTypeId);
566         // stack: [EW], [EW], [EventConfiguration] [long]
567         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());
568         // stack: [EW], [integer]
569         blockCodeBuilder.ifeq(excluded);
570         // stack: [EW]
571         // write startTime
572         blockCodeBuilder.dup();
573         // stack: [EW], [EW]
574         tk = TypeKind.from(argumentTypes[argIndex++]);
575         blockCodeBuilder.loadLocal(tk, slotIndex);
576         // stack: [EW], [EW], [long]
577         slotIndex += tk.slotSize();
578         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
579         fieldIndex++;
580         // stack: [EW]
581         if (implicitFields.hasDuration()) {
582             // write duration
583             blockCodeBuilder.dup();
584             // stack: [EW], [EW]
585             tk = TypeKind.from(argumentTypes[argIndex++]);
586             blockCodeBuilder.loadLocal(tk, slotIndex);
587             // stack: [EW], [EW], [long]
588             slotIndex += tk.slotSize();
589             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
590             fieldIndex++;
591         }
592         // stack: [EW]
593         if (implicitFields.hasEventThread()) {
594             // write eventThread
595             blockCodeBuilder.dup();
596             // stack: [EW], [EW]
597             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());
598         }
599         // stack: [EW]
600         if (implicitFields.hasStackTrace()) {
601             // write stackTrace
602             blockCodeBuilder.dup();
603             // stack: [EW], [EW]
604             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());
605         }
606         // stack: [EW]
607         // write custom fields
608         while (fieldIndex &lt; fieldDescs.size()) {
609             blockCodeBuilder.dup();
610             // stack: [EW], [EW]
611             tk = TypeKind.from(argumentTypes[argIndex++]);
612             blockCodeBuilder.loadLocal(tk, slotIndex);
613             // stack:[EW], [EW], [field]
614             slotIndex += tk.slotSize();
615             FieldDesc field = fieldDescs.get(fieldIndex);
616             EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);
617             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());
618             // stack: [EW]
619             fieldIndex++;
620         }
621         // stack: [EW]
622         // write end event (writer already on stack)
623         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());
624         // stack: [int]
625     }
626 
627     void updateInstanceCommit(BlockCodeBuilder blockCodeBuilder, Label end, Label excluded) {
628         // if (!isEnable()) {
629         // return;
630         // }
631         blockCodeBuilder.aload(0);
632         invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_IS_ENABLED);
633         Label l0 = blockCodeBuilder.newLabel();
634         blockCodeBuilder.ifne(l0);
635         blockCodeBuilder.return_();
636         blockCodeBuilder.labelBinding(l0);
637         // long startTime = this.startTime
638         blockCodeBuilder.aload(0);
639         getfield(blockCodeBuilder, getEventClassDesc(), FIELD_START_TIME);
640         blockCodeBuilder.lstore(1);
641         // if (startTime == 0) {
642         //   startTime = EventWriter.timestamp();
643         // } else {
644         blockCodeBuilder.lload(1);
645         blockCodeBuilder.lconst_0();
646         blockCodeBuilder.lcmp();
647         Label durationEvent = blockCodeBuilder.newLabel();
648         blockCodeBuilder.ifne(durationEvent);
649         invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
650         blockCodeBuilder.lstore(1);
651         Label commit = blockCodeBuilder.newLabel();
652         blockCodeBuilder.goto_(commit);
653         //   if (duration == 0) {
654         //     duration = EventWriter.timestamp() - startTime;
655         //   }
656         // }
657         blockCodeBuilder.labelBinding(durationEvent);
658         blockCodeBuilder.aload(0);
659         getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
660         blockCodeBuilder.lconst_0();
661         blockCodeBuilder.lcmp();
662         blockCodeBuilder.ifne(commit);
663         blockCodeBuilder.aload(0);
664         invokestatic(blockCodeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_TIME_STAMP);
665         blockCodeBuilder.lload(1);
666         blockCodeBuilder.lsub();
667         putfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
668         blockCodeBuilder.labelBinding(commit);
669         // if (shouldCommit()) {
670         blockCodeBuilder.aload(0);
671         invokevirtual(blockCodeBuilder, getEventClassDesc(), METHOD_EVENT_SHOULD_COMMIT);
672         blockCodeBuilder.ifeq(end);
673         getEventWriter(blockCodeBuilder);
674         // stack: [EW]
675         blockCodeBuilder.dup();
676         // stack: [EW] [EW]
677         getEventConfiguration(blockCodeBuilder);
678         // stack: [EW] [EW] [EC]
679         blockCodeBuilder.loadConstant(eventTypeId);
680         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.method());
681         // stack: [EW] [int]
682         blockCodeBuilder.ifeq(excluded);
683         // stack: [EW]
684         int fieldIndex = 0;
685         blockCodeBuilder.dup();
686         // stack: [EW] [EW]
687         blockCodeBuilder.lload(1);
688         // stack: [EW] [EW] [long]
689         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
690         fieldIndex++;
691         // stack: [EW]
692         if (implicitFields.hasDuration()) {
693             // write duration
694             blockCodeBuilder.dup();
695             // stack: [EW] [EW]
696             blockCodeBuilder.aload(0);
697             // stack: [EW] [EW] [this]
698             getfield(blockCodeBuilder, getEventClassDesc(), FIELD_DURATION);
699             // stack: [EW] [EW] [long]
700             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.method());
701             fieldIndex++;
702         }
703         // stack: [EW]
704         if (implicitFields.hasEventThread()) {
705             // write eventThread
706             blockCodeBuilder.dup();
707             // stack: [EW] [EW]
708             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.method());
709         }
710         // stack: [EW]
711         if (implicitFields.hasStackTrace()) {
712             // write stack trace
713             blockCodeBuilder.dup();
714             // stack: [EW] [EW]
715             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.method());
716         }
717         // stack: [EW]
718         while (fieldIndex &lt; fieldDescs.size()) {
719             FieldDesc field = fieldDescs.get(fieldIndex);
720             blockCodeBuilder.dup();
721             // stack: [EW] [EW]
722             blockCodeBuilder.aload(0);
723             // stack: [EW] [EW] [this]
724             getfield(blockCodeBuilder, getEventClassDesc(), field);
725             // stack: [EW] [EW] &lt;T&gt;
726             EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);
727             invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, eventMethod.method());
728             // stack: [EW]
729             fieldIndex++;
730         }
731         // stack:[EW]
732         invokevirtual(blockCodeBuilder, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.method());
733         // stack:[int]
734     }
735 
736     private void updateEnabledMethod(MethodDesc method) {
737         updateMethod(method, codeBuilder -&gt; {
738             Label nullLabel = codeBuilder.newLabel();
739             if (guardEventConfiguration) {
740                 getEventConfiguration(codeBuilder);
741                 codeBuilder.ifnull(nullLabel);
742             }
743             getEventConfiguration(codeBuilder);
744             invokevirtual(codeBuilder, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);
745             codeBuilder.ireturn();
746             if (guardEventConfiguration) {
747                 codeBuilder.labelBinding(nullLabel);
748                 codeBuilder.iconst_0();
749                 codeBuilder.ireturn();
750             }
751         });
752     }
753 
754     private void updateIfStaticMethodExists(MethodDesc method, Consumer&lt;CodeBuilder&gt; code) {
755         if (hasStaticMethod(method)) {
756             updateMethod(method, code);
757         }
758     }
759 
760     private boolean hasStaticMethod(MethodDesc method) {
761         for (MethodModel m : classModel.methods()) {
762             if (m.methodName().equalsString(method.name()) &amp;&amp; m.methodTypeSymbol().equals(method.descriptor())) {
763                 return Modifier.isStatic(m.flags().flagsMask());
764             }
765         }
766         return false;
767     }
768 
769     private void getEventWriter(CodeBuilder codeBuilder) {
770         codeBuilder.ldc(EventWriterKey.getKey());
771         invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);
772     }
773 
774     private void getEventConfiguration(CodeBuilder codeBuilder) {
775         if (untypedEventConfiguration) {
776             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);
777             codeBuilder.checkcast(TYPE_EVENT_CONFIGURATION);
778         } else {
779             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_EVENT_CONFIGURATION);
780         }
781     }
782 
783     private void makeUninstrumented() {
784         updateExistingWithReturnFalse(METHOD_EVENT_SHOULD_COMMIT);
785         updateExistingWithReturnFalse(METHOD_IS_ENABLED);
786         updateExistingWithEmptyVoidMethod(METHOD_COMMIT);
787         if (staticCommitMethod != null) {
788             updateExistingWithEmptyVoidMethod(staticCommitMethod);
789         }
790         updateExistingWithEmptyVoidMethod(METHOD_BEGIN);
791         updateExistingWithEmptyVoidMethod(METHOD_END);
792     }
793 
794     private final void updateExistingWithEmptyVoidMethod(MethodDesc voidMethod) {
795         updateMethod(voidMethod, codeBuilder -&gt; {
796             codeBuilder.return_();
797         });
798     }
799 
800     private final void updateExistingWithReturnFalse(MethodDesc voidMethod) {
801         updateMethod(voidMethod, codeBuilder -&gt; {
802             codeBuilder.iconst_0();
803             codeBuilder.ireturn();
804         });
805     }
806 
807     private Consumer&lt;CodeBuilder&gt; findMethodUpdate(MethodModel mm) {
808         MethodDesc m = MethodDesc.of(mm.methodName().stringValue(), mm.methodType().stringValue());
809         return methodUpdates.get(m);
810     }
811 
812     private void updateMethod(MethodDesc method, Consumer&lt;CodeBuilder&gt; codeBuilder) {
813         methodUpdates.put(method, codeBuilder);
814     }
815 
816     private ClassDesc getEventClassDesc() {
817         return classModel.thisClass().asSymbol();
818     }
819 
820     public String getEventName() {
821         return eventName;
822     }
823 }
    </pre>
  </body>
</html>