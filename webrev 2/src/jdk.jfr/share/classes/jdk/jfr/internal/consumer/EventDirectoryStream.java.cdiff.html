<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractEventStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventFileStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,16 ***</span>
  
  package jdk.jfr.internal.consumer;
  
  import java.io.IOException;
  import java.nio.file.Path;
<span class="line-removed">- import java.security.AccessControlContext;</span>
  import java.time.Instant;
  import java.util.Arrays;
  import java.util.Comparator;
  import java.util.List;
<span class="line-removed">- import java.util.Objects;</span>
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.function.Consumer;
  
  import jdk.jfr.Configuration;
  import jdk.jfr.RecordingState;
<span class="line-new-header">--- 25,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,11 ***</span>
  import jdk.jfr.internal.JVM;
  import jdk.jfr.internal.LogLevel;
  import jdk.jfr.internal.LogTag;
  import jdk.jfr.internal.Logger;
  import jdk.jfr.internal.PlatformRecording;
<span class="line-removed">- import jdk.jfr.internal.SecuritySupport;</span>
  import jdk.jfr.internal.util.Utils;
  import jdk.jfr.internal.management.StreamBarrier;
  
  /**
   * Implementation of an {@code EventStream}} that operates against a directory
<span class="line-new-header">--- 40,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,35 ***</span>
  public final class EventDirectoryStream extends AbstractEventStream {
  
      private static final Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
  
      private final RepositoryFiles repositoryFiles;
<span class="line-removed">-     private final FileAccess fileAccess;</span>
      private final PlatformRecording recording;
      private final StreamBarrier barrier = new StreamBarrier();
      private final AtomicLong streamId = new AtomicLong();
      private ChunkParser currentParser;
      private long currentChunkStartNanos;
      private RecordedEvent[] sortedCache;
      private int threadExclusionLevel = 0;
      private volatile Consumer&lt;Long&gt; onCompleteHandler;
  
      public EventDirectoryStream(
<span class="line-removed">-             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">-             AccessControlContext acc,</span>
              Path p,
<span class="line-removed">-             FileAccess fileAccess,</span>
              PlatformRecording recording,
              List&lt;Configuration&gt; configurations,
              boolean allowSubDirectories) throws IOException {
<span class="line-modified">!         super(acc, configurations);</span>
          this.recording = recording;
<span class="line-modified">!         if (p != null &amp;&amp; SecuritySupport.PRIVILEGED == fileAccess) {</span>
<span class="line-removed">-             throw new SecurityException(&quot;Priviliged file access not allowed with potentially malicious Path implementation&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this.fileAccess = Objects.requireNonNull(fileAccess);</span>
<span class="line-removed">-         this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);</span>
          this.streamId.incrementAndGet();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Stream &quot; + streamId + &quot; started.&quot;);
      }
  
      @Override
<span class="line-new-header">--- 53,27 ---</span>
  public final class EventDirectoryStream extends AbstractEventStream {
  
      private static final Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
  
      private final RepositoryFiles repositoryFiles;
      private final PlatformRecording recording;
      private final StreamBarrier barrier = new StreamBarrier();
      private final AtomicLong streamId = new AtomicLong();
      private ChunkParser currentParser;
      private long currentChunkStartNanos;
      private RecordedEvent[] sortedCache;
      private int threadExclusionLevel = 0;
      private volatile Consumer&lt;Long&gt; onCompleteHandler;
  
      public EventDirectoryStream(
              Path p,
              PlatformRecording recording,
              List&lt;Configuration&gt; configurations,
              boolean allowSubDirectories) throws IOException {
<span class="line-modified">!         super(configurations);</span>
          this.recording = recording;
<span class="line-modified">!         this.repositoryFiles = new RepositoryFiles(p, allowSubDirectories);</span>
          this.streamId.incrementAndGet();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Stream &quot; + streamId + &quot; started.&quot;);
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
          if (path == null) { // closed
              logStreamEnd(&quot;no first chunk file found.&quot;);
              return;
          }
          currentChunkStartNanos = repositoryFiles.getTimestamp(path);
<span class="line-modified">!         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {</span>
              input.setStreamed();
              currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
              long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
              long filterStart = validStartTime ? disp.startNanos : segmentStart;
              long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
<span class="line-new-header">--- 140,11 ---</span>
          if (path == null) { // closed
              logStreamEnd(&quot;no first chunk file found.&quot;);
              return;
          }
          currentChunkStartNanos = repositoryFiles.getTimestamp(path);
<span class="line-modified">!         try (RecordingInput input = new RecordingInput(path.toFile())) {</span>
              input.setStreamed();
              currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
              long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
              long filterStart = validStartTime ? disp.startNanos : segmentStart;
              long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
</pre>
<center><a href="AbstractEventStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventFileStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>