<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.consumer.filter;
 26 
 27 import java.io.Closeable;
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.util.ArrayDeque;
 32 import java.util.Deque;
 33 import java.util.Map;
 34 import java.util.HashMap;
 35 import java.util.function.Predicate;
 36 
 37 import jdk.jfr.consumer.RecordedEvent;
 38 import jdk.jfr.internal.LongMap;
 39 import jdk.jfr.internal.Type;
 40 import jdk.jfr.internal.consumer.ChunkHeader;
 41 import jdk.jfr.internal.Logger;
 42 import jdk.jfr.internal.LogLevel;
 43 import jdk.jfr.internal.LogTag;
 44 import jdk.jfr.internal.consumer.RecordingInput;
 45 import jdk.jfr.internal.consumer.Reference;
 46 
 47 /**
 48  * Class that can filter out events and associated constants from a recording
 49  * file.
 50  * &lt;p&gt;
 51  * All positional values are relative to file start, not the chunk.
 52  */
 53 public final class ChunkWriter implements Closeable {
 54     private LongMap&lt;Constants&gt; pools = new LongMap&lt;&gt;();
 55     private final Deque&lt;CheckpointEvent&gt; checkpoints = new ArrayDeque&lt;&gt;();
 56     private final Path destination;
 57     private final RecordingInput input;
 58     private final RecordingOutput output;
 59     private final Predicate&lt;RecordedEvent&gt; filter;
 60     private final Map&lt;String, Long&gt; waste = new HashMap&lt;&gt;();
 61 
 62     private long chunkStartPosition;
 63     private boolean chunkComplete;
 64     private long lastCheckpoint;
 65 
 66     public ChunkWriter(Path source, Path destination, Predicate&lt;RecordedEvent&gt; filter) throws IOException {
 67         this.destination = destination;
 68         this.output = new RecordingOutput(destination.toFile());
 69         this.input = new RecordingInput(source.toFile());
 70         this.filter = filter;
 71     }
 72 
 73     Constants getPool(Type type) {
 74         long typeId = type.getId();
 75         Constants pool = pools.get(typeId);
 76         if (pool == null) {
 77             pool = new Constants(type);
 78             pools.put(typeId, pool);
 79         }
 80         return pool;
 81     }
 82 
 83     public CheckpointEvent newCheckpointEvent(long startPosition) {
 84         CheckpointEvent event = new CheckpointEvent(this, startPosition);
 85         checkpoints.add(event);
 86         return event;
 87     }
 88 
 89     public boolean accept(RecordedEvent event) {
 90         return filter.test(event);
 91     }
 92 
 93     public void touch(Object object) {
 94         if (object instanceof Object[] array) {
 95             for (int i = 0; i &lt; array.length; i++) {
 96                 touch(array[i]);
 97             }
 98             return;
 99         }
100         if (object instanceof Reference ref) {
101             touchRef(ref);
102         }
103     }
104 
105     private void touchRef(Reference ref) {
106         Constants pool = pools.get(ref.type().getId());
107         if (pool == null) {
108             String msg = &quot;Can&#39;t resolve &quot; + ref.type().getName() + &quot;[&quot; + ref.key() + &quot;]&quot;;
109             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);
110             return;
111         }
112         PoolEntry entry = pool.get(ref.key());
113         if (entry != null &amp;&amp; !entry.isTouched()) {
114             entry.touch();
115             touch(entry.getReferences());
116         }
117     }
118     public void writeEvent(long startPosition, long endPosition) throws IOException {
119         writeCheckpointEvents(startPosition);
120         write(startPosition, endPosition);
121     }
122 
123     // Write check point events before a position
124     private void writeCheckpointEvents(long before) throws IOException {
125         CheckpointEvent cp = checkpoints.peek();
126         while (cp != null &amp;&amp; cp.getStartPosition() &lt; before) {
127             checkpoints.poll();
128             long delta = 0;
129             if (lastCheckpoint != 0) {
130                 delta = lastCheckpoint - output.position();
131             }
132             lastCheckpoint = output.position();
133             write(cp, delta);
134             cp = checkpoints.peek();
135         }
136     }
137 
138     public void write(long startPosition, long endPosition) throws IOException {
139         if (endPosition &lt; startPosition) {
140             throw new IOException(&quot;Start position must come before end position, start=&quot; + startPosition + &quot;, end=&quot; + endPosition);
141         }
142         long backup = input.position();
143         input.position(startPosition);
144         long n = endPosition - startPosition;
145         for (long i = 0; i &lt; n; i++) {
146             output.writeByte(input.readByte());
147         }
148         input.position(backup);
149     }
150 
151     @Override
152     public void close() throws IOException {
153         try {
154             output.close();
155         } finally {
156             if (!chunkComplete) {
157                 // Error occurred, clean up
158                 if (Files.exists(destination)) {
159                     Files.delete(destination);
160                 }
161             }
162         }
163     }
164 
165     public void beginChunk(ChunkHeader header) throws IOException {
166         this.chunkComplete = false;
167         this.chunkStartPosition = output.position();
168         input.position(header.getAbsoluteChunkStart());
169         for (int i = 0; i &lt; ChunkHeader.HEADER_SIZE; i++) {
170             output.writeByte(input.readByte());
171         }
172     }
173 
174     public void endChunk(ChunkHeader header) throws IOException {
175         // write all outstanding checkpoints
176         writeCheckpointEvents(Long.MAX_VALUE);
177         long metadata = output.position();
178         writeMetadataEvent(header);
179         updateHeader(output.position(), lastCheckpoint, metadata);
180         pools = new LongMap&lt;&gt;();
181         chunkComplete = true;
182         lastCheckpoint = 0;
183         if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {
184             // Log largest waste first
185             waste.entrySet().stream()
186                  .sorted((a, b) -&gt; b.getValue().compareTo(a.getValue()))
187                  .forEach(entry -&gt; {
188                      String msg = &quot;Total chunk waste by &quot; + entry.getKey() + &quot;: &quot; + entry.getValue() + &quot; bytes.&quot;;
189                      Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);
190                  });
191         }
192         waste.clear();
193     }
194 
195     private void writeMetadataEvent(ChunkHeader header) throws IOException {
196         long metadataposition = header.getMetadataPosition() + header.getAbsoluteChunkStart();
197         input.position(metadataposition);
198         long size = input.readLong();
199         input.position(metadataposition);
200         for (int i = 0; i &lt; size; i++) {
201             output.writeByte(input.readByte());
202         }
203     }
204 
205     private void write(CheckpointEvent event, long delta) throws IOException {
206         input.position(event.getStartPosition());
207         long startPosition = output.position();
208 
209         input.readLong(); // Read size
210         output.writePaddedUnsignedInt(0); // Size, 4 bytes reserved
211         output.writeLong(input.readLong()); // Constant pool id
212         output.writeLong(input.readLong()); // Start time
213         output.writeLong(input.readLong()); // Duration
214         input.readLong(); // Read delta
215         output.writeLong(delta); // Delta
216         output.writeByte(input.readByte()); // flush marker
217 
218         // Write even if touched pools are zero, checkpoint works as sync point
219         output.writeLong(event.touchedPools()); // Pool count
220         for (CheckpointPool pool : event.getPools()) {
221             if (pool.isTouched()) {
222                 output.writeLong(pool.getTypeId());
223                 output.writeLong(pool.getTouchedCount());
224                 for (PoolEntry pe : pool.getEntries()) {
225                     if (pe.isTouched()) {
226                         write(pe.getStartPosition(), pe.getEndPosition()); // key + value
227                     }
228                 }
229             }
230         }
231         if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG)) {
232             for (CheckpointPool pool : event.getPools()) {
233                 for (PoolEntry pe : pool.getEntries()) {
234                     if (!pe.isTouched()) {
235                         String name = pe.getType().getName();
236                         long amount = pe.getEndPosition() - pe.getStartPosition();
237                         waste.merge(pe.getType().getName(), amount, Long::sum);
238                         String msg = &quot;Unreferenced constant ID &quot; + pe.getId() +
239                                      &quot; of type &quot;+ name + &quot; using &quot; + amount + &quot; bytes.&quot;;
240                         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, msg);
241                     }
242                 }
243             }
244         }
245         long endPosition = output.position();
246         long size = endPosition - startPosition;
247         output.position(startPosition);
248         output.writePaddedUnsignedInt(size);
249         output.position(endPosition);
250     }
251 
252     private void updateHeader(long size, long constantPosition, long metadataPosition) throws IOException {
253         long backup = output.position();
254         output.position(ChunkHeader.CHUNK_SIZE_POSITION + chunkStartPosition);
255         // Write chunk relative values
256         output.writeRawLong(size - chunkStartPosition);
257         output.writeRawLong(constantPosition - chunkStartPosition);
258         output.writeRawLong(metadataPosition - chunkStartPosition);
259         output.position(backup);
260     }
261 
262     public RecordingInput getInput() {
263         return input;
264     }
265 }
    </pre>
  </body>
</html>