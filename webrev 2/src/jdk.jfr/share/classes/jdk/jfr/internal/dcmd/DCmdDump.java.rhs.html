<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdDump.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 
 27 import java.io.IOException;
 28 import java.nio.file.InvalidPathException;
 29 import java.time.Duration;
 30 import java.time.Instant;
 31 import java.time.LocalDate;
 32 import java.time.LocalDateTime;
 33 import java.time.LocalTime;
 34 import java.time.ZoneId;
 35 import java.time.ZonedDateTime;
 36 import java.time.format.DateTimeParseException;
 37 
 38 import jdk.jfr.FlightRecorder;
 39 import jdk.jfr.Recording;
 40 import jdk.jfr.internal.PlatformRecorder;
 41 import jdk.jfr.internal.PlatformRecording;
 42 import jdk.jfr.internal.PrivateAccess;
<a name="2" id="anc2"></a>
 43 import jdk.jfr.internal.util.ValueParser;
<a name="3" id="anc3"></a><span class="line-modified"> 44 import jdk.jfr.internal.WriteablePath;</span>
 45 
 46 /**
 47  * JFR.dump
 48  *
 49  */
 50 // Instantiated by native
 51 final class DCmdDump extends AbstractDCmd {
 52 
 53     @Override
 54     public void execute(ArgumentParser parser) throws DCmdException {
 55         parser.checkUnknownArguments();
 56         String name = parser.getOption(&quot;name&quot;);
 57         String filename = parser.getOption(&quot;filename&quot;);
 58         Long maxAge = parser.getOption(&quot;maxage&quot;);
 59         Long maxSize = parser.getOption(&quot;maxsize&quot;);
 60         String begin = parser.getOption(&quot;begin&quot;);
 61         String end = parser.getOption(&quot;end&quot;);
 62         Boolean pathToGcRoots = parser.getOption(&quot;path-to-gc-roots&quot;);
 63 
 64         if (FlightRecorder.getFlightRecorder().getRecordings().isEmpty()) {
 65             throw new DCmdException(&quot;No recordings to dump from. Use JFR.start to start a recording.&quot;);
 66         }
 67 
 68         if (maxAge != null) {
 69             if (end != null || begin != null) {
 70                 throw new DCmdException(&quot;Dump failed, maxage can&#39;t be combined with begin or end.&quot;);
 71             }
 72 
 73             if (maxAge &lt; 0) {
 74                 throw new DCmdException(&quot;Dump failed, maxage can&#39;t be negative.&quot;);
 75             }
 76             if (maxAge == 0) {
 77                 maxAge = Long.MAX_VALUE / 2; // a high value that won&#39;t overflow
 78             }
 79         }
 80 
 81         if (maxSize!= null) {
 82             if (maxSize &lt; 0) {
 83                 throw new DCmdException(&quot;Dump failed, maxsize can&#39;t be negative.&quot;);
 84             }
 85             if (maxSize == 0) {
 86                 maxSize = Long.MAX_VALUE / 2; // a high value that won&#39;t overflow
 87             }
 88         }
 89 
 90         Instant beginTime = parseTime(begin, &quot;begin&quot;);
 91         Instant endTime = parseTime(end, &quot;end&quot;);
 92 
 93         if (beginTime != null &amp;&amp; endTime != null) {
 94             if (endTime.isBefore(beginTime)) {
 95                 throw new DCmdException(&quot;Dump failed, begin must precede end.&quot;);
 96             }
 97         }
 98 
 99         Duration duration = null;
100         if (maxAge != null) {
101             duration = Duration.ofNanos(maxAge);
102             beginTime = Instant.now().minus(duration);
103         }
104         Recording recording = null;
105         if (name != null) {
106             recording = findRecording(name);
107         }
108         PlatformRecorder recorder = PrivateAccess.getInstance().getPlatformRecorder();
109 
110         try {
111             synchronized (recorder) {
112                 dump(recorder, recording, name, filename, maxSize, pathToGcRoots, beginTime, endTime);
113             }
114         } catch (IOException | InvalidPathException e) {
115             throw new DCmdException(&quot;Dump failed. Could not copy recording data. %s&quot;, e.getMessage());
116         }
117     }
118 
119     public void dump(PlatformRecorder recorder, Recording recording, String name, String filename, Long maxSize, Boolean pathToGcRoots, Instant beginTime, Instant endTime) throws DCmdException, IOException {
120         try (PlatformRecording r = newSnapShot(recorder, recording, pathToGcRoots)) {
121             r.filter(beginTime, endTime, maxSize);
122             if (r.getChunks().isEmpty()) {
123                 throw new DCmdException(&quot;Dump failed. No data found in the specified interval.&quot;);
124             }
125             // If a filename exist, use it
126             // if a filename doesn&#39;t exist, use destination set earlier
127             // if destination doesn&#39;t exist, generate a filename
<a name="4" id="anc4"></a><span class="line-modified">128             WriteablePath wp = null;</span>
129             if (recording != null) {
130                 PlatformRecording pRecording = PrivateAccess.getInstance().getPlatformRecording(recording);
<a name="5" id="anc5"></a><span class="line-modified">131                 wp = pRecording.getDestination();</span>
132             }
<a name="6" id="anc6"></a><span class="line-modified">133             if (filename != null || (filename == null &amp;&amp; wp == null) ) {</span>
<span class="line-modified">134                 wp = new WriteablePath(resolvePath(recording, filename));</span>

135             }
<a name="7" id="anc7"></a><span class="line-modified">136             r.dumpStopped(wp);</span>
<span class="line-modified">137             reportOperationComplete(&quot;Dumped&quot;, name, wp.getReal());</span>
138         }
139     }
140 
141     private Instant parseTime(String time, String parameter) throws DCmdException {
142         if (time == null) {
143             return null;
144         }
145         try {
146             return Instant.parse(time);
147         } catch (DateTimeParseException dtp) {
148             // fall through
149         }
150         try {
151             LocalDateTime ldt = LocalDateTime.parse(time);
152             return ZonedDateTime.of(ldt, ZoneId.systemDefault()).toInstant();
153         } catch (DateTimeParseException dtp) {
154             // fall through
155         }
156         try {
157             LocalTime lt = LocalTime.parse(time);
158             LocalDate ld = LocalDate.now();
159             Instant instant = ZonedDateTime.of(ld, lt, ZoneId.systemDefault()).toInstant();
160             Instant now = Instant.now();
161             if (instant.isAfter(now) &amp;&amp; !instant.isBefore(now.plusSeconds(3600))) {
162                 // User must have meant previous day
163                 ld = ld.minusDays(1);
164             }
165             return ZonedDateTime.of(ld, lt, ZoneId.systemDefault()).toInstant();
166         } catch (DateTimeParseException dtp) {
167             // fall through
168         }
169 
170         if (time.startsWith(&quot;-&quot;)) {
171             try {
172                 long durationNanos = ValueParser.parseTimespan(time.substring(1));
173                 Duration duration = Duration.ofNanos(durationNanos);
174                 return Instant.now().minus(duration);
175             } catch (NumberFormatException nfe) {
176                 // fall through
177             }
178         }
179         throw new DCmdException(&quot;Dump failed, not a valid %s time.&quot;, parameter);
180     }
181 
182     private PlatformRecording newSnapShot(PlatformRecorder recorder, Recording recording, Boolean pathToGcRoots) throws DCmdException, IOException {
183         if (recording == null) {
184             // Operate on all recordings
185             PlatformRecording snapshot = recorder.newTemporaryRecording();
186             recorder.fillWithRecordedData(snapshot, pathToGcRoots);
187             return snapshot;
188         }
189 
190         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
191         return pr.newSnapshotClone(&quot;Dumped by user&quot;, pathToGcRoots);
192     }
193 
194     @Override
195     public String[] getHelp() {
196             // 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890
197         return &quot;&quot;&quot;
198                Syntax : JFR.dump [options]
199 
200                Options:
201 
202                  begin            (Optional) Specify the time from which recording data will be
203                                   included in the dump file. The format is specified as local time.
204                                   (STRING, no default value)
205 
206                  end              (Optional) Specify the time to which recording data will be included
207                                   in the dump file. The format is specified as local time.
208                                   (STRING, no default value)
209 
210                                   Note: For both begin and end, the time must be in a format that can
211                                   be read by any of these methods:
212 
213                                    java.time.LocalTime::parse(String),
214                                    java.time.LocalDateTime::parse(String)
215                                    java.time.Instant::parse(String)
216 
217                                   For example, &quot;13:20:15&quot;, &quot;2020-03-17T09:00:00&quot; or
218                                   &quot;2020-03-17T09:00:00Z&quot;.
219 
220                                   Note: begin and end times correspond to the timestamps found within
221                                   the recorded information in the flight recording data.
222 
223                                   Another option is to use a time relative to the current time that is
224                                   specified by a negative integer followed by &quot;s&quot;, &quot;m&quot; or &quot;h&quot;.
225                                   For example, &quot;-12h&quot;, &quot;-15m&quot; or &quot;-30s&quot;
226 
227                  filename         (Optional) Name of the file to which the flight recording data is
228                                   dumped. If no filename is given, a filename is generated from the PID
229                                   and the current date. The filename may also be a directory in which
230                                   case, the filename is generated from the PID and the current date in
231                                   the specified directory. (FILE, no default value)
232 
233                                   Note: If a filename is given, &#39;%%p&#39; in the filename will be
234                                   replaced by the PID, and &#39;%%t&#39; will be replaced by the time in
235                                   &#39;yyyy_MM_dd_HH_mm_ss&#39; format.
236 
237                  maxage           (Optional) Length of time for dumping the flight recording data to a
238                                   file. (INT followed by &#39;s&#39; for seconds &#39;m&#39; for minutes or &#39;h&#39; for
239                                   hours, no default value)
240 
241                  maxsize          (Optional) Maximum size for the amount of data to dump from a flight
242                                   recording in bytes if one of the following suffixes is not used:
243                                   &#39;m&#39; or &#39;M&#39; for megabytes OR &#39;g&#39; or &#39;G&#39; for gigabytes.
244                                   (STRING, no default value)
245 
246                  name             (Optional) Name of the recording. If no name is given, data from all
247                                   recordings is dumped. (STRING, no default value)
248 
249                  path-to-gc-roots (Optional) Flag for saving the path to garbage collection (GC) roots
250                                   at the time the recording data is dumped. The path information is
251                                   useful for finding memory leaks but collecting it can cause the
252                                   application to pause for a short period of time. Turn on this flag
253                                   only when you have an application that you suspect has a memory
254                                   leak. (BOOLEAN, false)
255 
256                Options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax.
257 
258                Example usage:
259 
260                 $ jcmd &lt;pid&gt; JFR.dump
261                 $ jcmd &lt;pid&gt; JFR.dump filename=recording.jfr
262                 $ jcmd &lt;pid&gt; JFR.dump filename=%s
263                 $ jcmd &lt;pid&gt; JFR.dump name=1 filename=%s
264                 $ jcmd &lt;pid&gt; JFR.dump maxage=1h
265                 $ jcmd &lt;pid&gt; JFR.dump maxage=1h maxsize=50M
266                 $ jcmd &lt;pid&gt; JFR.dump filename=leaks.jfr path-to-gc-roots=true
267                 $ jcmd &lt;pid&gt; JFR.dump begin=13:15
268                 $ jcmd &lt;pid&gt; JFR.dump begin=13:15 end=21:30:00
269                 $ jcmd &lt;pid&gt; JFR.dump end=18:00 maxage=10m
270                 $ jcmd &lt;pid&gt; JFR.dump begin=2021-09-15T09:00:00 end=2021-09-15T10:00:00
271                 $ jcmd &lt;pid&gt; JFR.dump begin=-1h
272                 $ jcmd &lt;pid&gt; JFR.dump begin=-15m end=-5m
273 
274                &quot;&quot;&quot;.formatted(exampleDirectory(), exampleFilename()).lines().toArray(String[]::new);
275     }
276 
277     @Override
278     public Argument[] getArgumentInfos() {
279         return new Argument[] {
280            new Argument(&quot;name&quot;,
281                &quot;Recording name, e.g. \\\&quot;My Recording\\\&quot;&quot;,
282                &quot;STRING&quot;, false, true, null, false),
283            new Argument(&quot;filename&quot;,
284                &quot;Copy recording data to file, e.g. \\\&quot;&quot; + exampleFilename() + &quot;\\\&quot;&quot;,
285                &quot;FILE&quot;, false, true, null, false),
286            new Argument(&quot;maxage&quot;,
287                &quot;Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;,
288                &quot;NANOTIME&quot;, false, true, null, false),
289            new Argument(&quot;maxsize&quot;, &quot;Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;,
290                &quot;MEMORY SIZE&quot;, false, true, &quot;hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr&quot;, false),
291            new Argument(&quot;begin&quot;,
292                &quot;Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;,
293                &quot;STRING&quot;, false, true, null, false),
294            new Argument(&quot;end&quot;,
295                &quot;Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;,
296                &quot;STRING&quot;, false, true, null, false),
297            new Argument(&quot;path-to-gc-roots&quot;,
298                &quot;Collect path to GC roots&quot;,
299                &quot;BOOLEAN&quot;, false, true, &quot;false&quot;, false)
300         };
301     }
302 }
303 
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>