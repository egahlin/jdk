<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.DirectoryIteratorException;
 30 import java.nio.file.DirectoryStream;
<a name="2" id="anc2"></a>
 31 import java.nio.file.Path;
 32 import java.nio.file.attribute.FileTime;
 33 import java.util.ArrayList;
 34 import java.util.Collections;
 35 import java.util.HashMap;
 36 import java.util.HashSet;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.NavigableMap;
 40 import java.util.Set;
 41 import java.util.SortedMap;
 42 import java.util.TreeMap;
 43 
 44 import jdk.jfr.internal.LogLevel;
 45 import jdk.jfr.internal.LogTag;
 46 import jdk.jfr.internal.Logger;
 47 import jdk.jfr.internal.Repository;
<a name="3" id="anc3"></a><span class="line-removed"> 48 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 49 import jdk.jfr.internal.management.HiddenWait;;
 50 
 51 public final class RepositoryFiles {
 52     private static final HiddenWait WAIT_OBJECT = new HiddenWait();
 53     private static final String DIRECTORY_PATTERN = &quot;DDDD_DD_DD_DD_DD_DD_&quot;;
 54     public static void notifyNewFile() {
 55         synchronized (WAIT_OBJECT) {
 56             WAIT_OBJECT.notifyAll();
 57         }
 58     }
 59 
<a name="4" id="anc4"></a><span class="line-removed"> 60     private final FileAccess fileAccess;</span>
 61     private final NavigableMap&lt;Long, Path&gt; pathSet = new TreeMap&lt;&gt;();
 62     private final Map&lt;Path, Long&gt; pathLookup = new HashMap&lt;&gt;();
 63     private final HiddenWait waitObject;
 64     private boolean allowSubDirectory;
 65     private volatile boolean closed;
 66     private Path repository;
 67 
<a name="5" id="anc5"></a><span class="line-modified"> 68     public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {</span>
 69         this.repository = repository;
<a name="6" id="anc6"></a><span class="line-removed"> 70         this.fileAccess = fileAccess;</span>
 71         this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();
 72         this.allowSubDirectory = allowSubDirectory;
 73     }
 74 
 75     long getTimestamp(Path p) {
 76         return pathLookup.get(p);
 77     }
 78 
 79     public Path lastPath(boolean wait) {
 80         if (updatePaths(wait)) {
 81             return pathSet.lastEntry().getValue();
 82         }
 83         return null; // closed
 84     }
 85 
 86     public Path firstPath(long startTimeNanos, boolean wait) {
 87         if (updatePaths(wait)) {
 88             // Pick closest chunk before timestamp
 89             Long time = pathSet.floorKey(startTimeNanos);
 90             if (time != null) {
 91                 startTimeNanos = time;
 92             }
 93             return path(startTimeNanos, wait);
 94         }
 95         return null; // closed
 96     }
 97 
 98     private boolean updatePaths(boolean wait) {
 99         int beforeSize = pathLookup.size();
100         while (!closed) {
101             try {
102                 if (updatePaths()) {
103                     break;
104                 }
105             } catch (IOException | DirectoryIteratorException e) {
106                 Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;Exception during repository file scan &quot; + e.getMessage());
107                 // This can happen if a chunk is being removed
108                 // between the file was discovered and an instance
109                 // was accessed. Just ignore, and retry later.
110             }
111             if (wait) {
112                 waitObject.takeNap(1000);
113             } else {
114                 return pathLookup.size() &gt; beforeSize;
115             }
116         }
117         return !closed;
118     }
119 
120     public Path nextPath(long startTimeNanos, boolean wait) {
121         if (closed) {
122             return null;
123         }
124         // Try to get the &#39;exact&#39; path first
125         // to avoid skipping files if repository
126         // is updated while DirectoryStream
127         // is traversing it
128         Path path = pathSet.get(startTimeNanos);
129         if (path != null) {
130             return path;
131         }
132         // Update paths
133         try {
134             updatePaths();
135         } catch (IOException | DirectoryIteratorException e) {
136             // ignore
137         }
138         // try to get the next file
139         return path(startTimeNanos, wait);
140     }
141 
142     private Path path(long timestamp, boolean wait) {
143         if (closed) {
144             return null;
145         }
146         while (true) {
147             SortedMap&lt;Long, Path&gt; after = pathSet.tailMap(timestamp);
148             if (!after.isEmpty()) {
149                 Path path = after.get(after.firstKey());
150                 if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE)) {
151                     Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE, &quot;Return path &quot; + path + &quot; for start time nanos &quot; + timestamp);
152                 }
153                 return path;
154             }
155             if (!updatePaths(wait)) {
156                 return null; // closed
157             }
158         }
159     }
160 
161     private boolean updatePaths() throws IOException, DirectoryIteratorException {
162         boolean foundNew = false;
163         Path repoPath = repository;
164 
165         if (allowSubDirectory) {
166             Path subDirectory = findSubDirectory(repoPath);
167             if (subDirectory != null) {
168                 repoPath = subDirectory;
169             }
170         }
171 
172         if (repoPath == null) {
173             // Always get the latest repository if &#39;jcmd JFR.configure
174             // repositorypath=...&#39; has been executed
<a name="7" id="anc7"></a><span class="line-modified">175             SafePath sf = Repository.getRepository().getRepositoryPath();</span>
<span class="line-modified">176             if (sf == null) {</span>
177                 return false; // not initialized
178             }
<a name="8" id="anc8"></a><span class="line-modified">179             repoPath = sf.toPath();</span>
180         }
181 
<a name="9" id="anc9"></a><span class="line-modified">182         try (DirectoryStream&lt;Path&gt; dirStream = fileAccess.newDirectoryStream(repoPath)) {</span>
183             List&lt;Path&gt; added = new ArrayList&lt;&gt;();
184             Set&lt;Path&gt; current = new HashSet&lt;&gt;();
185             for (Path p : dirStream) {
186                 if (!pathLookup.containsKey(p)) {
187                     String s = p.toString();
188                     if (s.endsWith(&quot;.jfr&quot;)) {
189                         added.add(p);
190                         Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;New file found: &quot; + p.toAbsolutePath());
191                     }
192                     current.add(p);
193                 }
194             }
195             List&lt;Path&gt; removed = new ArrayList&lt;&gt;();
196             for (Path p : pathLookup.keySet()) {
197                 if (!current.contains(p)) {
198                     removed.add(p);
199                 }
200             }
201 
202             for (Path remove : removed) {
203                 Long time = pathLookup.get(remove);
204                 pathSet.remove(time);
205                 pathLookup.remove(remove);
206             }
207             Collections.sort(added);
208             for (Path p : added) {
209                 // Only add files that have a complete header
210                 // as the JVM may be in progress writing the file
<a name="10" id="anc10"></a><span class="line-modified">211                 long size = fileAccess.fileSize(p);</span>
212                 if (size &gt;= ChunkHeader.headerSize()) {
213                     long startNanos = readStartTime(p);
214                     if (startNanos != -1) {
215                         pathSet.put(startNanos, p);
216                         pathLookup.put(p, startNanos);
217                         foundNew = true;
218                     }
219                 }
220             }
221             if (allowSubDirectory &amp;&amp; foundNew) {
222                 // Found a valid file, possibly in a subdirectory.
223                 // Use the same (sub)directory from now on.
224                 repository = repoPath;
225                 allowSubDirectory = false;
226             }
227 
228             return foundNew;
229         }
230     }
231 
232     private Path findSubDirectory(Path repoPath) {
233         FileTime latestTimestamp = null;
234         Path latestPath = null;
<a name="11" id="anc11"></a><span class="line-modified">235         try (DirectoryStream&lt;Path&gt; dirStream = fileAccess.newDirectoryStream(repoPath)) {</span>
236             for (Path p : dirStream) {
237                 String filename = p.getFileName().toString();
<a name="12" id="anc12"></a><span class="line-modified">238                 if (isRepository(filename) &amp;&amp; fileAccess.isDirectory(p)) {</span>
239                     FileTime timestamp = getLastModified(p);
240                     if (timestamp != null) {
241                         if (latestPath == null || latestTimestamp.compareTo(timestamp) &lt;= 0) {
242                             latestPath = p;
243                             latestTimestamp = timestamp;
244                         }
245                     }
246                 }
247             }
248         } catch (IOException | DirectoryIteratorException e) {
249             // Ignore
250         }
251         return latestPath;
252     }
253 
254     private FileTime getLastModified(Path p) {
255         try {
<a name="13" id="anc13"></a><span class="line-modified">256             return fileAccess.getLastModified(p);</span>
257         } catch (IOException e) {
258             return null;
259         }
260     }
261 
262     private static boolean isRepository(String filename) {
263         if (filename.length() &lt; DIRECTORY_PATTERN.length()) {
264             return false;
265         }
266         for (int i = 0; i &lt; DIRECTORY_PATTERN.length(); i++) {
267             char expected = DIRECTORY_PATTERN.charAt(i);
268             char c = filename.charAt(i);
269             if (expected == &#39;D&#39; &amp;&amp; !Character.isDigit(c)) {
270                 return false;
271             }
272             if (expected == &#39;_&#39; &amp;&amp; c != &#39;_&#39;) {
273                 return false;
274             }
275         }
276         return true;
277     }
278 
279     private long readStartTime(Path p) {
<a name="14" id="anc14"></a><span class="line-modified">280         try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {</span>
281             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Parsing header for chunk start time&quot;);
282             ChunkHeader c = new ChunkHeader(in);
283             return c.getStartNanos();
284         } catch (IOException ioe) {
285             return -1;
286         }
287     }
288 
289     void close() {
290         synchronized (waitObject) {
291             this.closed = true;
292             waitObject.notify();
293         }
294     }
295 
296     public boolean hasFixedPath() {
297         return repository != null;
298     }
299 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>