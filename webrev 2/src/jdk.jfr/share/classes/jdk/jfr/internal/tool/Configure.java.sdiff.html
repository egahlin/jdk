<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Command.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Disassemble.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.tool;
 26 
 27 import java.io.FileNotFoundException;
 28 import java.io.IOError;
 29 import java.io.IOException;
 30 import java.io.PrintStream;
 31 import java.nio.file.InvalidPathException;
 32 import java.nio.file.Path;
 33 import java.text.ParseException;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Deque;
 37 import java.util.LinkedHashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 
<span class="line-removed"> 41 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 42 import jdk.jfr.internal.jfc.JFC;
 43 import jdk.jfr.internal.jfc.model.AbortException;
 44 import jdk.jfr.internal.jfc.model.JFCModel;
 45 import jdk.jfr.internal.jfc.model.JFCModelException;
 46 import jdk.jfr.internal.jfc.model.SettingsLog;
 47 import jdk.jfr.internal.jfc.model.UserInterface;
 48 import jdk.jfr.internal.jfc.model.XmlInput;
 49 import jdk.jfr.internal.util.UserDataException;
 50 import jdk.jfr.internal.util.UserSyntaxException;
 51 
 52 final class Configure extends Command {
 53     private final List&lt;String&gt; inputFiles = new ArrayList&lt;&gt;();
 54 
 55     @Override
 56     public List&lt;String&gt; getOptionSyntax() {
 57         List&lt;String&gt; list = new ArrayList&lt;&gt;();
 58         list.add(&quot;[--interactive] [--verbose]&quot;);
 59         list.add(&quot;[--input &lt;files&gt;] [--output &lt;file&gt;]&quot;);
 60         list.add(&quot;[option=value]* [event-setting=value]*&quot;);
 61         return list;
</pre>
<hr />
<pre>
112         stream.println(&quot;  jfr configure --interactive&quot;);
113         stream.println();
114         stream.println(&quot;Example usage:&quot;);
115         stream.println();
116         stream.println(&quot;  jfr configure gc=high method-profiling=high --output high.jfc&quot;);
117         stream.println();
118         stream.println(&quot;  jfr configure jdk.JavaMonitorEnter#threshold=1ms --output locks.jfc&quot;);
119         stream.println();
120         stream.println(&quot;  jfr configure +HelloWorld#enabled=true +HelloWorld#stackTrace=true&quot;);
121         stream.println();
122         stream.println(&quot;  jfr configure --input default.jfc,third-party.jfc --output unified.jfc&quot;);
123         stream.println();
124         stream.println(&quot;  jfr configure --input none +Hello#enabled=true --output minimal.jfc&quot;);
125     }
126 
127     private void displayParameters(PrintStream stream, String name) {
128         stream.println();
129         stream.println(&quot;Options for &quot; + name + &quot;:&quot;);
130         stream.println();
131         try {
<span class="line-modified">132             SafePath path = JFC.createSafePath(name);</span>
133             JFCModel parameters = JFCModel.create(path, l -&gt; stream.println(&quot;Warning! &quot; + l));
134             for (XmlInput input : parameters.getInputs()) {
135                 stream.println(&quot;  &quot; + input.getOptionSyntax());
136                 stream.println();
137             }
138         } catch (JFCModelException | InvalidPathException | ParseException | IOException e) {
139             stream.println(JFC.formatException(&quot;  Could not&quot;, e, name)); // indented
140         }
141     }
142 
143     @Override
144     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
145         boolean interactive = false;
146         boolean log = false;
<span class="line-modified">147         SafePath output = null;</span>
148         Map&lt;String, String&gt; keyValues = new LinkedHashMap&lt;&gt;();
149         int optionCount = options.size();
150         while (optionCount &gt; 0) {
151             if (acceptSwitch(options, &quot;--interactive&quot;)) {
152                 interactive = true;
153             }
154             if (acceptSwitch(options, &quot;--verbose&quot;)) {
155                 log = true;
156             }
157             if (acceptOption(options, &quot;--input&quot;)) {
158                 String value = options.pop();
159                 inputFiles.addAll(Arrays.asList(value.split(&quot;,&quot;)));
160             }
161             if (acceptOption(options, &quot;--output&quot;)) {
162                 if (output != null) {
163                     throw new UserDataException(&quot;only one output file can be specified&quot;);
164                 }
165                 String value = options.pop();
166                 output = makeJFCPath(value);
167             }
</pre>
<hr />
<pre>
175                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
176             }
177             optionCount = options.size();
178         }
179         if (!interactive &amp;&amp; output == null &amp;&amp; keyValues.isEmpty()) {
180             throw new UserSyntaxException(&quot;missing argument&quot;);
181         }
182         ensureInputFiles();
183         configure(interactive, log, output, keyValues);
184     }
185 
186     private boolean acceptKeyValue(Deque&lt;String&gt; options) {
187         if (!options.isEmpty()) {
188             String keyValue = options.peek();
189             int index = keyValue.indexOf(&quot;=&quot;);
190             return index &gt; 0 &amp;&amp; index &lt; keyValue.length() - 1;
191         }
192         return false;
193     }
194 
<span class="line-modified">195     private void configure(boolean interactive, boolean log, SafePath output, Map&lt;String, String&gt; options) throws UserDataException {</span>
196         UserInterface ui = new UserInterface();
197         if (log) {
198             SettingsLog.enable();
199         }
200         JFCModel model = new JFCModel(l -&gt; ui.println(&quot;Warning! &quot; + l));
201         model.setLabel(&quot;Custom&quot;);
202         for (String input : inputFiles) {
203             try {
<span class="line-modified">204                 model.parse(JFC.createSafePath(input));</span>
205             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
206                 throw new UserDataException(JFC.formatException(&quot;could not&quot;, e, input));
207             }
208         }
209         try {
210             if (output == null) {
<span class="line-modified">211                 output = new SafePath(Path.of(&quot;custom.jfc&quot;));</span>
212             }
213             for (var option : options.entrySet()) {
214                 model.configure(option.getKey(), option.getValue());
215             }
216             SettingsLog.flush();
217             try {
218                 if (interactive) {
219                     int q = model.getInputs().size() + 1;
220                     ui.println(&quot;============== .jfc Configuration Wizard ============&quot;);
221                     ui.println(&quot;This wizard will generate a JFR configuration file by&quot;);
222                     ui.println(&quot;asking &quot; + q + &quot; questions. Press ENTER to use the default&quot;);
223                     ui.println(&quot;value, or type Q to abort the wizard.&quot;);
224                     model.configure(ui);
225                     output = filename(ui, output);
226                 }
227             } catch (AbortException e) {
228                 ui.println(&quot;Abort.&quot;);
229                 return;
230             }
231             model.saveToFile(output);
232             ui.println(&quot;Configuration written successfully to:&quot;);
<span class="line-modified">233             ui.println(output.toPath().toAbsolutePath().toString());</span>
234         } catch (IllegalArgumentException iae) {
235             throw new UserDataException(iae.getMessage());
236         } catch (FileNotFoundException ffe) {
237             throw new UserDataException(&quot;could not find file: &quot; + ffe.getMessage());
238         } catch (IOException ioe) {
239             throw new UserDataException(&quot;i/o error: &quot; + ioe.getMessage());
240         }
241     }
242 
243     private void ensureInputFiles() throws InternalError {
244         if (inputFiles.isEmpty()) {
245             inputFiles.add(&quot;default.jfc&quot;);
246         }
247     }
248 
<span class="line-modified">249     private static SafePath filename(UserInterface ui, SafePath file) throws AbortException {</span>
250         ui.println();
251         ui.println(&quot;Filename: &quot; + file + &quot; (default)&quot;);
252         while (true) {
253             String line = ui.readLine();
254             try {
255                 if (line.isBlank()) {
256                     return file;
257                 }
258                 if (line.endsWith(&quot;.jfc&quot;)) {
<span class="line-modified">259                     return new SafePath(line);</span>
260                 }
261                 ui.println(&quot;Filename must end with .jfc.&quot;);
262             } catch (InvalidPathException ipe) {
263                 ui.println(&quot;Not a valid filename. &quot; + ipe.getMessage());
264             }
265         }
266     }
267 
<span class="line-modified">268     private SafePath makeJFCPath(String file) throws UserDataException, UserSyntaxException {</span>
269         if (file.startsWith(&quot;--&quot;)) {
270             throw new UserSyntaxException(&quot;missing file&quot;);
271         }
272         try {
273             Path path = Path.of(file).toAbsolutePath();
274             ensureFileExtension(path, &quot;.jfc&quot;);
<span class="line-modified">275             return new SafePath(path);</span>
276         } catch (IOError ioe) {
277             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + file + &quot;&#39;, &quot; + ioe.getMessage());
278         } catch (InvalidPathException ipe) {
279             throw new UserDataException(&quot;invalid path &#39;&quot; + file + &quot;&#39;&quot;);
280         }
281     }
282 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2021, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.tool;
 26 
 27 import java.io.FileNotFoundException;
 28 import java.io.IOError;
 29 import java.io.IOException;
 30 import java.io.PrintStream;
 31 import java.nio.file.InvalidPathException;
 32 import java.nio.file.Path;
 33 import java.text.ParseException;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Deque;
 37 import java.util.LinkedHashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 

 41 import jdk.jfr.internal.jfc.JFC;
 42 import jdk.jfr.internal.jfc.model.AbortException;
 43 import jdk.jfr.internal.jfc.model.JFCModel;
 44 import jdk.jfr.internal.jfc.model.JFCModelException;
 45 import jdk.jfr.internal.jfc.model.SettingsLog;
 46 import jdk.jfr.internal.jfc.model.UserInterface;
 47 import jdk.jfr.internal.jfc.model.XmlInput;
 48 import jdk.jfr.internal.util.UserDataException;
 49 import jdk.jfr.internal.util.UserSyntaxException;
 50 
 51 final class Configure extends Command {
 52     private final List&lt;String&gt; inputFiles = new ArrayList&lt;&gt;();
 53 
 54     @Override
 55     public List&lt;String&gt; getOptionSyntax() {
 56         List&lt;String&gt; list = new ArrayList&lt;&gt;();
 57         list.add(&quot;[--interactive] [--verbose]&quot;);
 58         list.add(&quot;[--input &lt;files&gt;] [--output &lt;file&gt;]&quot;);
 59         list.add(&quot;[option=value]* [event-setting=value]*&quot;);
 60         return list;
</pre>
<hr />
<pre>
111         stream.println(&quot;  jfr configure --interactive&quot;);
112         stream.println();
113         stream.println(&quot;Example usage:&quot;);
114         stream.println();
115         stream.println(&quot;  jfr configure gc=high method-profiling=high --output high.jfc&quot;);
116         stream.println();
117         stream.println(&quot;  jfr configure jdk.JavaMonitorEnter#threshold=1ms --output locks.jfc&quot;);
118         stream.println();
119         stream.println(&quot;  jfr configure +HelloWorld#enabled=true +HelloWorld#stackTrace=true&quot;);
120         stream.println();
121         stream.println(&quot;  jfr configure --input default.jfc,third-party.jfc --output unified.jfc&quot;);
122         stream.println();
123         stream.println(&quot;  jfr configure --input none +Hello#enabled=true --output minimal.jfc&quot;);
124     }
125 
126     private void displayParameters(PrintStream stream, String name) {
127         stream.println();
128         stream.println(&quot;Options for &quot; + name + &quot;:&quot;);
129         stream.println();
130         try {
<span class="line-modified">131             Path path = JFC.ofPath(name);</span>
132             JFCModel parameters = JFCModel.create(path, l -&gt; stream.println(&quot;Warning! &quot; + l));
133             for (XmlInput input : parameters.getInputs()) {
134                 stream.println(&quot;  &quot; + input.getOptionSyntax());
135                 stream.println();
136             }
137         } catch (JFCModelException | InvalidPathException | ParseException | IOException e) {
138             stream.println(JFC.formatException(&quot;  Could not&quot;, e, name)); // indented
139         }
140     }
141 
142     @Override
143     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
144         boolean interactive = false;
145         boolean log = false;
<span class="line-modified">146         Path output = null;</span>
147         Map&lt;String, String&gt; keyValues = new LinkedHashMap&lt;&gt;();
148         int optionCount = options.size();
149         while (optionCount &gt; 0) {
150             if (acceptSwitch(options, &quot;--interactive&quot;)) {
151                 interactive = true;
152             }
153             if (acceptSwitch(options, &quot;--verbose&quot;)) {
154                 log = true;
155             }
156             if (acceptOption(options, &quot;--input&quot;)) {
157                 String value = options.pop();
158                 inputFiles.addAll(Arrays.asList(value.split(&quot;,&quot;)));
159             }
160             if (acceptOption(options, &quot;--output&quot;)) {
161                 if (output != null) {
162                     throw new UserDataException(&quot;only one output file can be specified&quot;);
163                 }
164                 String value = options.pop();
165                 output = makeJFCPath(value);
166             }
</pre>
<hr />
<pre>
174                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
175             }
176             optionCount = options.size();
177         }
178         if (!interactive &amp;&amp; output == null &amp;&amp; keyValues.isEmpty()) {
179             throw new UserSyntaxException(&quot;missing argument&quot;);
180         }
181         ensureInputFiles();
182         configure(interactive, log, output, keyValues);
183     }
184 
185     private boolean acceptKeyValue(Deque&lt;String&gt; options) {
186         if (!options.isEmpty()) {
187             String keyValue = options.peek();
188             int index = keyValue.indexOf(&quot;=&quot;);
189             return index &gt; 0 &amp;&amp; index &lt; keyValue.length() - 1;
190         }
191         return false;
192     }
193 
<span class="line-modified">194     private void configure(boolean interactive, boolean log, Path output, Map&lt;String, String&gt; options) throws UserDataException {</span>
195         UserInterface ui = new UserInterface();
196         if (log) {
197             SettingsLog.enable();
198         }
199         JFCModel model = new JFCModel(l -&gt; ui.println(&quot;Warning! &quot; + l));
200         model.setLabel(&quot;Custom&quot;);
201         for (String input : inputFiles) {
202             try {
<span class="line-modified">203                 model.parse(JFC.ofPath(input));</span>
204             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
205                 throw new UserDataException(JFC.formatException(&quot;could not&quot;, e, input));
206             }
207         }
208         try {
209             if (output == null) {
<span class="line-modified">210                 output = Path.of(&quot;custom.jfc&quot;);</span>
211             }
212             for (var option : options.entrySet()) {
213                 model.configure(option.getKey(), option.getValue());
214             }
215             SettingsLog.flush();
216             try {
217                 if (interactive) {
218                     int q = model.getInputs().size() + 1;
219                     ui.println(&quot;============== .jfc Configuration Wizard ============&quot;);
220                     ui.println(&quot;This wizard will generate a JFR configuration file by&quot;);
221                     ui.println(&quot;asking &quot; + q + &quot; questions. Press ENTER to use the default&quot;);
222                     ui.println(&quot;value, or type Q to abort the wizard.&quot;);
223                     model.configure(ui);
224                     output = filename(ui, output);
225                 }
226             } catch (AbortException e) {
227                 ui.println(&quot;Abort.&quot;);
228                 return;
229             }
230             model.saveToFile(output);
231             ui.println(&quot;Configuration written successfully to:&quot;);
<span class="line-modified">232             ui.println(output.toAbsolutePath().toString());</span>
233         } catch (IllegalArgumentException iae) {
234             throw new UserDataException(iae.getMessage());
235         } catch (FileNotFoundException ffe) {
236             throw new UserDataException(&quot;could not find file: &quot; + ffe.getMessage());
237         } catch (IOException ioe) {
238             throw new UserDataException(&quot;i/o error: &quot; + ioe.getMessage());
239         }
240     }
241 
242     private void ensureInputFiles() throws InternalError {
243         if (inputFiles.isEmpty()) {
244             inputFiles.add(&quot;default.jfc&quot;);
245         }
246     }
247 
<span class="line-modified">248     private static Path filename(UserInterface ui, Path file) throws AbortException {</span>
249         ui.println();
250         ui.println(&quot;Filename: &quot; + file + &quot; (default)&quot;);
251         while (true) {
252             String line = ui.readLine();
253             try {
254                 if (line.isBlank()) {
255                     return file;
256                 }
257                 if (line.endsWith(&quot;.jfc&quot;)) {
<span class="line-modified">258                     return Path.of(line);</span>
259                 }
260                 ui.println(&quot;Filename must end with .jfc.&quot;);
261             } catch (InvalidPathException ipe) {
262                 ui.println(&quot;Not a valid filename. &quot; + ipe.getMessage());
263             }
264         }
265     }
266 
<span class="line-modified">267     private Path makeJFCPath(String file) throws UserDataException, UserSyntaxException {</span>
268         if (file.startsWith(&quot;--&quot;)) {
269             throw new UserSyntaxException(&quot;missing file&quot;);
270         }
271         try {
272             Path path = Path.of(file).toAbsolutePath();
273             ensureFileExtension(path, &quot;.jfc&quot;);
<span class="line-modified">274             return path;</span>
275         } catch (IOError ioe) {
276             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + file + &quot;&#39;, &quot; + ioe.getMessage());
277         } catch (InvalidPathException ipe) {
278             throw new UserDataException(&quot;invalid path &#39;&quot; + file + &quot;&#39;&quot;);
279         }
280     }
281 }
</pre>
</td>
</tr>
</table>
<center><a href="Command.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Disassemble.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>