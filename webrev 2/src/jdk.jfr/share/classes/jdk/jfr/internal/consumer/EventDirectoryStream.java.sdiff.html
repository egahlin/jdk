<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractEventStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventFileStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
<span class="line-removed"> 30 import java.security.AccessControlContext;</span>
 31 import java.time.Instant;
 32 import java.util.Arrays;
 33 import java.util.Comparator;
 34 import java.util.List;
<span class="line-removed"> 35 import java.util.Objects;</span>
 36 import java.util.concurrent.atomic.AtomicLong;
 37 import java.util.function.Consumer;
 38 
 39 import jdk.jfr.Configuration;
 40 import jdk.jfr.RecordingState;
 41 import jdk.jfr.consumer.RecordedEvent;
 42 import jdk.jfr.internal.JVM;
 43 import jdk.jfr.internal.LogLevel;
 44 import jdk.jfr.internal.LogTag;
 45 import jdk.jfr.internal.Logger;
 46 import jdk.jfr.internal.PlatformRecording;
<span class="line-removed"> 47 import jdk.jfr.internal.SecuritySupport;</span>
 48 import jdk.jfr.internal.util.Utils;
 49 import jdk.jfr.internal.management.StreamBarrier;
 50 
 51 /**
 52  * Implementation of an {@code EventStream}} that operates against a directory
 53  * with chunk files.
 54  *
 55  */
 56 public final class EventDirectoryStream extends AbstractEventStream {
 57 
 58     private static final Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 59 
 60     private final RepositoryFiles repositoryFiles;
<span class="line-removed"> 61     private final FileAccess fileAccess;</span>
 62     private final PlatformRecording recording;
 63     private final StreamBarrier barrier = new StreamBarrier();
 64     private final AtomicLong streamId = new AtomicLong();
 65     private ChunkParser currentParser;
 66     private long currentChunkStartNanos;
 67     private RecordedEvent[] sortedCache;
 68     private int threadExclusionLevel = 0;
 69     private volatile Consumer&lt;Long&gt; onCompleteHandler;
 70 
 71     public EventDirectoryStream(
<span class="line-removed"> 72             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed"> 73             AccessControlContext acc,</span>
 74             Path p,
<span class="line-removed"> 75             FileAccess fileAccess,</span>
 76             PlatformRecording recording,
 77             List&lt;Configuration&gt; configurations,
 78             boolean allowSubDirectories) throws IOException {
<span class="line-modified"> 79         super(acc, configurations);</span>
 80         this.recording = recording;
<span class="line-modified"> 81         if (p != null &amp;&amp; SecuritySupport.PRIVILEGED == fileAccess) {</span>
<span class="line-removed"> 82             throw new SecurityException(&quot;Priviliged file access not allowed with potentially malicious Path implementation&quot;);</span>
<span class="line-removed"> 83         }</span>
<span class="line-removed"> 84         this.fileAccess = Objects.requireNonNull(fileAccess);</span>
<span class="line-removed"> 85         this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);</span>
 86         this.streamId.incrementAndGet();
 87         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Stream &quot; + streamId + &quot; started.&quot;);
 88     }
 89 
 90     @Override
 91     public void close() {
 92         closeParser();
 93         dispatcher().runCloseActions();
 94         repositoryFiles.close();
 95         if (currentParser != null) {
 96             currentParser.close();
 97             onComplete(currentParser.getEndNanos());
 98         }
 99     }
100 
101     public void setChunkCompleteHandler(Consumer&lt;Long&gt; handler) {
102         onCompleteHandler = handler;
103     }
104 
105     private void onComplete(long epochNanos) {
</pre>
<hr />
<pre>
136                 JVM.include(t);
137             }
138         }
139     }
140 
141     protected void processRecursionSafe() throws IOException {
142         Dispatcher lastDisp = null;
143         Dispatcher disp = dispatcher();
144         Path path;
145         boolean validStartTime = isRecordingStream() || disp.startTime != null;
146         if (validStartTime) {
147             path = repositoryFiles.firstPath(disp.startNanos, true);
148         } else {
149             path = repositoryFiles.lastPath(true);
150         }
151         if (path == null) { // closed
152             logStreamEnd(&quot;no first chunk file found.&quot;);
153             return;
154         }
155         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
<span class="line-modified">156         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {</span>
157             input.setStreamed();
158             currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
159             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
160             long filterStart = validStartTime ? disp.startNanos : segmentStart;
161             long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
162             while (!isClosed()) {
163                 onMetadata(currentParser);
164                 while (!isClosed() &amp;&amp; !currentParser.isChunkFinished()) {
165                     disp = dispatcher();
166                     if (disp != lastDisp) {
167                         var ranged = disp.parserConfiguration.withRange(filterStart, filterEnd);
168                         currentParser.updateConfiguration(ranged, true);
169                         lastDisp = disp;
170                     }
171                     if (disp.parserConfiguration.ordered()) {
172                         processOrdered(disp);
173                     } else {
174                         processUnordered(disp);
175                     }
176                     currentParser.resetCache();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;

 30 import java.time.Instant;
 31 import java.util.Arrays;
 32 import java.util.Comparator;
 33 import java.util.List;

 34 import java.util.concurrent.atomic.AtomicLong;
 35 import java.util.function.Consumer;
 36 
 37 import jdk.jfr.Configuration;
 38 import jdk.jfr.RecordingState;
 39 import jdk.jfr.consumer.RecordedEvent;
 40 import jdk.jfr.internal.JVM;
 41 import jdk.jfr.internal.LogLevel;
 42 import jdk.jfr.internal.LogTag;
 43 import jdk.jfr.internal.Logger;
 44 import jdk.jfr.internal.PlatformRecording;

 45 import jdk.jfr.internal.util.Utils;
 46 import jdk.jfr.internal.management.StreamBarrier;
 47 
 48 /**
 49  * Implementation of an {@code EventStream}} that operates against a directory
 50  * with chunk files.
 51  *
 52  */
 53 public final class EventDirectoryStream extends AbstractEventStream {
 54 
 55     private static final Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 56 
 57     private final RepositoryFiles repositoryFiles;

 58     private final PlatformRecording recording;
 59     private final StreamBarrier barrier = new StreamBarrier();
 60     private final AtomicLong streamId = new AtomicLong();
 61     private ChunkParser currentParser;
 62     private long currentChunkStartNanos;
 63     private RecordedEvent[] sortedCache;
 64     private int threadExclusionLevel = 0;
 65     private volatile Consumer&lt;Long&gt; onCompleteHandler;
 66 
 67     public EventDirectoryStream(


 68             Path p,

 69             PlatformRecording recording,
 70             List&lt;Configuration&gt; configurations,
 71             boolean allowSubDirectories) throws IOException {
<span class="line-modified"> 72         super(configurations);</span>
 73         this.recording = recording;
<span class="line-modified"> 74         this.repositoryFiles = new RepositoryFiles(p, allowSubDirectories);</span>




 75         this.streamId.incrementAndGet();
 76         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Stream &quot; + streamId + &quot; started.&quot;);
 77     }
 78 
 79     @Override
 80     public void close() {
 81         closeParser();
 82         dispatcher().runCloseActions();
 83         repositoryFiles.close();
 84         if (currentParser != null) {
 85             currentParser.close();
 86             onComplete(currentParser.getEndNanos());
 87         }
 88     }
 89 
 90     public void setChunkCompleteHandler(Consumer&lt;Long&gt; handler) {
 91         onCompleteHandler = handler;
 92     }
 93 
 94     private void onComplete(long epochNanos) {
</pre>
<hr />
<pre>
125                 JVM.include(t);
126             }
127         }
128     }
129 
130     protected void processRecursionSafe() throws IOException {
131         Dispatcher lastDisp = null;
132         Dispatcher disp = dispatcher();
133         Path path;
134         boolean validStartTime = isRecordingStream() || disp.startTime != null;
135         if (validStartTime) {
136             path = repositoryFiles.firstPath(disp.startNanos, true);
137         } else {
138             path = repositoryFiles.lastPath(true);
139         }
140         if (path == null) { // closed
141             logStreamEnd(&quot;no first chunk file found.&quot;);
142             return;
143         }
144         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
<span class="line-modified">145         try (RecordingInput input = new RecordingInput(path.toFile())) {</span>
146             input.setStreamed();
147             currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
148             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
149             long filterStart = validStartTime ? disp.startNanos : segmentStart;
150             long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
151             while (!isClosed()) {
152                 onMetadata(currentParser);
153                 while (!isClosed() &amp;&amp; !currentParser.isChunkFinished()) {
154                     disp = dispatcher();
155                     if (disp != lastDisp) {
156                         var ranged = disp.parserConfiguration.withRange(filterStart, filterEnd);
157                         currentParser.updateConfiguration(ranged, true);
158                         lastDisp = disp;
159                     }
160                     if (disp.parserConfiguration.ordered()) {
161                         processOrdered(disp);
162                     } else {
163                         processUnordered(disp);
164                     }
165                     currentParser.resetCache();
</pre>
</td>
</tr>
</table>
<center><a href="AbstractEventStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventFileStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>