<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/support/jfrResolution.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciKlass.hpp&quot;
 27 #include &quot;ci/ciMethod.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;interpreter/linkResolver.hpp&quot;
 30 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 31 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdMacros.hpp&quot;
 32 #include &quot;jfr/recorder/stacktrace/jfrStackTrace.hpp&quot;
 33 #include &quot;jfr/support/jfrDeprecationManager.hpp&quot;
 34 #include &quot;jfr/support/jfrResolution.hpp&quot;
 35 #include &quot;memory/resourceArea.inline.hpp&quot;
 36 #include &quot;oops/method.inline.hpp&quot;
 37 #include &quot;runtime/javaThread.inline.hpp&quot;
 38 #include &quot;runtime/vframe.inline.hpp&quot;
 39 #ifdef COMPILER1
 40 #include &quot;c1/c1_GraphBuilder.hpp&quot;
 41 #endif
 42 #ifdef COMPILER2
 43 #include &quot;opto/parse.hpp&quot;
 44 #endif
 45 
 46  // for strstr
 47 #include &lt;string.h&gt;
 48 
 49 // The following packages are internal implmentation details used by reflection.
 50 // We exclude matching frames on the stack in a manner similar to StackWalker.
 51 static constexpr const int NUM_EXCLUDED_PACKAGES = 4;
 52 static constexpr const char* excluded_packages[NUM_EXCLUDED_PACKAGES] = { &quot;java/lang/invoke/&quot;,
 53                                                                           &quot;jdk/internal/reflect/&quot;,
 54                                                                           &quot;java/lang/reflect/&quot;,
 55                                                                           &quot;sun/invoke/&quot; };
 56 
 57 static inline bool match(const char* str, const char* sub_str) {
 58   assert(str != nullptr, &quot;invariant&quot;);
 59   assert(sub_str != nullptr, &quot;invariant&quot;);
 60   return strstr(str, sub_str) == str;
 61 }
 62 
 63 // Caller requires ResourceMark.
 64 static inline bool exclude_frame(const Method* method) {
 65   assert(method != nullptr, &quot;invariant&quot;);
 66   // exclude native methods.
 67   if (method-&gt;is_native()) {
 68     return true;
 69   }
 70   const Klass* const klass = method-&gt;method_holder();
 71   assert(klass != nullptr, &quot;invariant&quot;);
 72   const Symbol* const klass_sym = klass-&gt;name();
 73   assert(klass_sym != nullptr, &quot;invariant&quot;);
 74   const char* const klass_name = klass_sym-&gt;as_C_string();
 75   assert(klass_name != nullptr, &quot;invariant&quot;);
 76   for (int i = 0; i &lt; NUM_EXCLUDED_PACKAGES; ++i) {
 77     if (match(klass_name,excluded_packages[i])) {
 78       return true;
 79     }
 80   }
 81   return false;
 82 }
 83 
 84 static Method* find_real_sender(vframeStream&amp; stream, JavaThread* jt) {
 85   assert(jt != nullptr, &quot;invariant&quot;);
 86   assert(stream.method()-&gt;is_native(), &quot;invariant&quot;);
 87   ResourceMark rm(jt);
 88   while (!stream.at_end()) {
 89     stream.next();
 90     Method* method = stream.method();
 91     if (!exclude_frame(method)) {
 92       return method;
 93     }
 94   }
 95   return nullptr;
 96 }
 97 
 98 static inline bool jfr_is_started_on_command_line() {
 99   return JfrRecorder::is_started_on_commandline();
100 }
101 
102 static inline Method* frame_context(vframeStream&amp; stream, int&amp; bci, u1&amp; frame_type, JavaThread* jt) {
103   Method* method = stream.method();
104   assert(method != nullptr, &quot;invariant&quot;);
105   if (method-&gt;is_native()) {
106     method = find_real_sender(stream, jt);
107     if (method == nullptr) {
108       return nullptr;
109     }
110   }
111   assert(method != nullptr, &quot;invariant&quot;);
112   assert(!method-&gt;is_native(), &quot;invariant&quot;);
113   bci = stream.bci();
114   frame_type = stream.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;
115   if (frame_type == JfrStackFrame::FRAME_JIT &amp;&amp; !stream.at_end()) {
116     const intptr_t* const id = stream.frame_id();
117     stream.next();
118     if (id == stream.frame_id()) {
119       frame_type = JfrStackFrame::FRAME_INLINE;
120     }
121   }
122   return method;
123 }
124 
125 static inline Method* ljf_sender_method(int&amp; bci, u1&amp; frame_type, JavaThread* jt) {
126   assert(jt != nullptr, &quot;invariant&quot;);
127   if (!jt-&gt;has_last_Java_frame()) {
128     return nullptr;
129   }
130   vframeStream stream(jt, true, false);
131   return frame_context(stream, bci, frame_type, jt);
132 }
133 
134 static inline void on_runtime_deprecated(const Method* method, JavaThread* jt) {
135   assert(jt != nullptr, &quot;invariant&quot;);
136   assert(method != nullptr, &quot;invariant&quot;);
137   assert(method-&gt;deprecated(), &quot;invariant&quot;);
138   if (jfr_is_started_on_command_line()) {
139     int bci;
140     u1 frame_type;
141     Method* const sender = ljf_sender_method(bci, frame_type, jt);
142     if (sender != nullptr) {
143       JfrDeprecationManager::on_link(method, sender, bci, frame_type, jt);
144     }
145   }
146 }
147 
148 // We can circumvent the need to hook into backpatching if ciMethod is made aware
149 // of the deprecated annotation already as part of parsing bytecodes of the callee method.
150 static void on_backpatching_deprecated(const Method* deprecated_method, JavaThread* jt) {
151   assert(deprecated_method != nullptr, &quot;invariant&quot;);
152   assert(deprecated_method-&gt;deprecated(), &quot;invariant&quot;);
153   assert(jt-&gt;has_last_Java_frame(), &quot;invariant&quot;);
154   assert(jt-&gt;last_frame().is_runtime_frame(), &quot;invariant&quot;);
155   if (jfr_is_started_on_command_line()) {
156     vframeStream stream(jt, true, false);
157     assert(!stream.at_end(), &quot;invariant&quot;);
158     stream.next(); // now at caller
159     int bci;
160     u1 frame_type;
161     Method* const sender = frame_context(stream, bci, frame_type, jt);
162     if (sender != nullptr) {
163       JfrDeprecationManager::on_link(deprecated_method, sender, bci, frame_type, jt);
164     }
165   }
166 }
167 
168 void JfrResolution::on_backpatching(const Method* callee_method, JavaThread* jt) {
169   assert(callee_method != nullptr, &quot;invariant&quot;);
170   assert(jt != nullptr, &quot;invariant&quot;);
171   if (callee_method-&gt;deprecated()) {
172     on_backpatching_deprecated(callee_method, jt);
173   }
174 }
175 
176 static inline const Method* ljf_sender_method(JavaThread* jt) {
177   assert(jt != nullptr, &quot;invariant&quot;);
178   if (!jt-&gt;has_last_Java_frame()) {
179     return nullptr;
180   }
181   const vframeStream ljf(jt, true, false);
182   return ljf.method();
183 }
184 
<a name="1" id="anc1"></a><span class="line-modified">185 static const char* const link_error_msg = &quot;illegal access linking method &#39;jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)&#39;&quot;;</span>
186 
187 void JfrResolution::on_runtime_resolution(const CallInfo &amp; info, TRAPS) {
188   assert(info.selected_method() != nullptr, &quot;invariant&quot;);
189   assert(info.resolved_klass() != nullptr, &quot;invariant&quot;);
190   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
191   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
192   Method* const method = info.selected_method();
193   assert(method != nullptr, &quot;invariant&quot;);
194   if (method-&gt;deprecated()) {
195     on_runtime_deprecated(method, THREAD);
196     return;
197   }
198   // Fast path
199   if (method-&gt;name() != event_writer_method_name) {
200     return;
201   }
<a name="2" id="anc2"></a><span class="line-modified">202   static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();</span>
<span class="line-modified">203   assert(event_writer_factory_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">204   if (info.resolved_klass()-&gt;name() != event_writer_factory_klass_name) {</span>
205     return;
206   }
<a name="3" id="anc3"></a><span class="line-modified">207   // Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().</span>
208   // The sender, i.e. the method attempting to link, is in the ljf (if one exists).
209   const Method* const sender = ljf_sender_method(THREAD);
210   if (sender == nullptr) {
211     // A compiler thread is doing linktime resolution but there is no information about the sender available.
212     // For the compiler threads, the sender is instead found as part of bytecode parsing.
213     return;
214   }
215   // Is the sender method blessed for linkage?
216   if (IS_METHOD_BLESSED(sender)) {
217     return;
218   }
219 #if INCLUDE_JVMCI
220   // JVMCI compiler is doing linktime resolution
221   if (sender-&gt;method_holder()-&gt;name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {
222     if (sender-&gt;name()-&gt;equals(&quot;lookupMethodInPool&quot;)) {
223       return;
224     }
225   }
226 #endif
227   THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);
228 }
229 
230 static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {
<a name="4" id="anc4"></a><span class="line-modified">231   static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();</span>
<span class="line-modified">232   assert(event_writer_factory_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">233   if (holder != event_writer_factory_klass_name) {</span>
234     return false;
235   }
236   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
237   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
238   return name == event_writer_method_name;
239 }
240 
241 static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {
242   assert(holder != nullptr, &quot;invariant&quot;);
243   assert(target != nullptr, &quot;invariant&quot;);
244   return is_compiler_linking_event_writer(holder-&gt;name()-&gt;get_symbol(), target-&gt;name()-&gt;get_symbol());
245 }
246 
247 static inline void on_compiler_resolve_deprecated(const ciMethod* target, int bci, Method* sender) {
248   assert(target != nullptr, &quot;invariant&quot;);
249   assert(sender != nullptr, &quot;invariant&quot;);
250   if (jfr_is_started_on_command_line()) {
251     const Method* const method = target-&gt;get_Method();
252     assert(method != nullptr, &quot;Invariant&quot;);
253     assert(method-&gt;deprecated(), &quot;invariant&quot;);
254     JfrDeprecationManager::on_link(method, sender, bci, JfrStackFrame::FRAME_JIT, JavaThread::current());
255   }
256 }
257 
258 #ifdef COMPILER1
259 // C1
260 void JfrResolution::on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target) {
261   Method* const sender = builder-&gt;method()-&gt;get_Method();
262   if (is_compiler_linking_event_writer(holder, target) &amp;&amp; !IS_METHOD_BLESSED(sender)) {
263     builder-&gt;bailout(link_error_msg);
264     return;
265   }
266   if (target-&gt;deprecated()) {
267     on_compiler_resolve_deprecated(target, builder-&gt;bci(), sender);
268   }
269 }
270 #endif
271 
272 #ifdef COMPILER2
273 // C2
274 void JfrResolution::on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target) {
275   Method* const sender = parse-&gt;method()-&gt;get_Method();
276   if (is_compiler_linking_event_writer(holder, target) &amp;&amp; !IS_METHOD_BLESSED(sender)) {
277     parse-&gt;C-&gt;record_failure(link_error_msg);
278     return;
279   }
280   if (target-&gt;deprecated()) {
281     on_compiler_resolve_deprecated(target, parse-&gt;bci(), sender);
282   }
283 }
284 #endif
285 
286 #if INCLUDE_JVMCI
287 // JVMCI
288 void JfrResolution::on_jvmci_resolution(const Method* caller, const Method* target, TRAPS) {
289   if (is_compiler_linking_event_writer(target-&gt;method_holder()-&gt;name(), target-&gt;name())) {
290     if (caller == nullptr || !IS_METHOD_BLESSED(caller)) {
291       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);
292     }
293   }
294 }
295 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>