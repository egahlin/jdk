<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/support/jfrResolution.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrIntrinsics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/support/jfrResolution.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
165   }
166 }
167 
168 void JfrResolution::on_backpatching(const Method* callee_method, JavaThread* jt) {
169   assert(callee_method != nullptr, &quot;invariant&quot;);
170   assert(jt != nullptr, &quot;invariant&quot;);
171   if (callee_method-&gt;deprecated()) {
172     on_backpatching_deprecated(callee_method, jt);
173   }
174 }
175 
176 static inline const Method* ljf_sender_method(JavaThread* jt) {
177   assert(jt != nullptr, &quot;invariant&quot;);
178   if (!jt-&gt;has_last_Java_frame()) {
179     return nullptr;
180   }
181   const vframeStream ljf(jt, true, false);
182   return ljf.method();
183 }
184 
<span class="line-modified">185 static const char* const link_error_msg = &quot;illegal access linking method &#39;jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)&#39;&quot;;</span>
186 
187 void JfrResolution::on_runtime_resolution(const CallInfo &amp; info, TRAPS) {
188   assert(info.selected_method() != nullptr, &quot;invariant&quot;);
189   assert(info.resolved_klass() != nullptr, &quot;invariant&quot;);
190   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
191   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
192   Method* const method = info.selected_method();
193   assert(method != nullptr, &quot;invariant&quot;);
194   if (method-&gt;deprecated()) {
195     on_runtime_deprecated(method, THREAD);
196     return;
197   }
198   // Fast path
199   if (method-&gt;name() != event_writer_method_name) {
200     return;
201   }
<span class="line-modified">202   static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();</span>
<span class="line-modified">203   assert(event_writer_factory_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">204   if (info.resolved_klass()-&gt;name() != event_writer_factory_klass_name) {</span>
205     return;
206   }
<span class="line-modified">207   // Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().</span>
208   // The sender, i.e. the method attempting to link, is in the ljf (if one exists).
209   const Method* const sender = ljf_sender_method(THREAD);
210   if (sender == nullptr) {
211     // A compiler thread is doing linktime resolution but there is no information about the sender available.
212     // For the compiler threads, the sender is instead found as part of bytecode parsing.
213     return;
214   }
215   // Is the sender method blessed for linkage?
216   if (IS_METHOD_BLESSED(sender)) {
217     return;
218   }
219 #if INCLUDE_JVMCI
220   // JVMCI compiler is doing linktime resolution
221   if (sender-&gt;method_holder()-&gt;name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {
222     if (sender-&gt;name()-&gt;equals(&quot;lookupMethodInPool&quot;)) {
223       return;
224     }
225   }
226 #endif
227   THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);
228 }
229 
230 static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {
<span class="line-modified">231   static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();</span>
<span class="line-modified">232   assert(event_writer_factory_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">233   if (holder != event_writer_factory_klass_name) {</span>
234     return false;
235   }
236   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
237   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
238   return name == event_writer_method_name;
239 }
240 
241 static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {
242   assert(holder != nullptr, &quot;invariant&quot;);
243   assert(target != nullptr, &quot;invariant&quot;);
244   return is_compiler_linking_event_writer(holder-&gt;name()-&gt;get_symbol(), target-&gt;name()-&gt;get_symbol());
245 }
246 
247 static inline void on_compiler_resolve_deprecated(const ciMethod* target, int bci, Method* sender) {
248   assert(target != nullptr, &quot;invariant&quot;);
249   assert(sender != nullptr, &quot;invariant&quot;);
250   if (jfr_is_started_on_command_line()) {
251     const Method* const method = target-&gt;get_Method();
252     assert(method != nullptr, &quot;Invariant&quot;);
253     assert(method-&gt;deprecated(), &quot;invariant&quot;);
</pre>
</td>
<td>
<hr />
<pre>
165   }
166 }
167 
168 void JfrResolution::on_backpatching(const Method* callee_method, JavaThread* jt) {
169   assert(callee_method != nullptr, &quot;invariant&quot;);
170   assert(jt != nullptr, &quot;invariant&quot;);
171   if (callee_method-&gt;deprecated()) {
172     on_backpatching_deprecated(callee_method, jt);
173   }
174 }
175 
176 static inline const Method* ljf_sender_method(JavaThread* jt) {
177   assert(jt != nullptr, &quot;invariant&quot;);
178   if (!jt-&gt;has_last_Java_frame()) {
179     return nullptr;
180   }
181   const vframeStream ljf(jt, true, false);
182   return ljf.method();
183 }
184 
<span class="line-modified">185 static const char* const link_error_msg = &quot;illegal access linking method &#39;jdk.jfr.internal.event.EventWriter.getEventWriter()&#39;&quot;;</span>
186 
187 void JfrResolution::on_runtime_resolution(const CallInfo &amp; info, TRAPS) {
188   assert(info.selected_method() != nullptr, &quot;invariant&quot;);
189   assert(info.resolved_klass() != nullptr, &quot;invariant&quot;);
190   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
191   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
192   Method* const method = info.selected_method();
193   assert(method != nullptr, &quot;invariant&quot;);
194   if (method-&gt;deprecated()) {
195     on_runtime_deprecated(method, THREAD);
196     return;
197   }
198   // Fast path
199   if (method-&gt;name() != event_writer_method_name) {
200     return;
201   }
<span class="line-modified">202   static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();</span>
<span class="line-modified">203   assert(event_writer_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">204   if (info.resolved_klass()-&gt;name() != event_writer_klass_name) {</span>
205     return;
206   }
<span class="line-modified">207   // Attempting to link against jdk.jfr.internal.event.EventWriter.getEventWriter().</span>
208   // The sender, i.e. the method attempting to link, is in the ljf (if one exists).
209   const Method* const sender = ljf_sender_method(THREAD);
210   if (sender == nullptr) {
211     // A compiler thread is doing linktime resolution but there is no information about the sender available.
212     // For the compiler threads, the sender is instead found as part of bytecode parsing.
213     return;
214   }
215   // Is the sender method blessed for linkage?
216   if (IS_METHOD_BLESSED(sender)) {
217     return;
218   }
219 #if INCLUDE_JVMCI
220   // JVMCI compiler is doing linktime resolution
221   if (sender-&gt;method_holder()-&gt;name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {
222     if (sender-&gt;name()-&gt;equals(&quot;lookupMethodInPool&quot;)) {
223       return;
224     }
225   }
226 #endif
227   THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);
228 }
229 
230 static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {
<span class="line-modified">231   static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();</span>
<span class="line-modified">232   assert(event_writer_klass_name != nullptr, &quot;invariant&quot;);</span>
<span class="line-modified">233   if (holder != event_writer_klass_name) {</span>
234     return false;
235   }
236   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
237   assert(event_writer_method_name != nullptr, &quot;invariant&quot;);
238   return name == event_writer_method_name;
239 }
240 
241 static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {
242   assert(holder != nullptr, &quot;invariant&quot;);
243   assert(target != nullptr, &quot;invariant&quot;);
244   return is_compiler_linking_event_writer(holder-&gt;name()-&gt;get_symbol(), target-&gt;name()-&gt;get_symbol());
245 }
246 
247 static inline void on_compiler_resolve_deprecated(const ciMethod* target, int bci, Method* sender) {
248   assert(target != nullptr, &quot;invariant&quot;);
249   assert(sender != nullptr, &quot;invariant&quot;);
250   if (jfr_is_started_on_command_line()) {
251     const Method* const method = target-&gt;get_Method();
252     assert(method != nullptr, &quot;Invariant&quot;);
253     assert(method-&gt;deprecated(), &quot;invariant&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="jfrIntrinsics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>