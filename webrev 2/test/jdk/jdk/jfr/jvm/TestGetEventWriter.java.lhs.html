<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/jvm/TestGetEventWriter.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.jfr.jvm;
 25 
 26 import java.lang.invoke.MethodHandle;
 27 import java.lang.invoke.MethodHandles;
 28 import java.lang.invoke.MethodType;
 29 import java.lang.reflect.Constructor;
 30 import java.lang.reflect.Method;
 31 import java.util.List;
 32 import jdk.jfr.Event;
 33 import jdk.jfr.FlightRecorder;
 34 import jdk.jfr.Recording;
 35 import jdk.vm.ci.meta.MetaAccessProvider;
 36 import jdk.vm.ci.meta.ResolvedJavaMethod;
 37 import jdk.vm.ci.meta.ConstantPool;
 38 import jdk.vm.ci.runtime.JVMCI;
 39 
 40 /**
 41  * @test id=default
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
 46  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 47  *
 48  * @compile PlaceholderEventWriter.java
<a name="2" id="anc2"></a><span class="line-removed"> 49  * @compile PlaceholderEventWriterFactory.java</span>
 50  * @compile E.java
 51  * @compile NonEvent.java
 52  * @compile RegisteredTrueEvent.java
 53  * @compile RegisteredFalseEvent.java
 54  * @compile MyCommitRegisteredTrueEvent.java
 55  * @compile MyCommitRegisteredFalseEvent.java
 56  * @compile StaticCommitEvent.java
 57  *
 58  * @run main/othervm jdk.jfr.jvm.TestGetEventWriter
 59  *
 60  * @run main/othervm/timeout=300 -Xint -XX:+UseInterpreter -Dinterpreted=true
 61  *      jdk.jfr.jvm.TestGetEventWriter
 62  *
 63  * @run main/othervm/timeout=300 -Xcomp -XX:-UseInterpreter -Dinterpreted=false
 64  *      jdk.jfr.jvm.TestGetEventWriter
 65  *
 66  * @run main/othervm/timeout=300 -Xcomp -XX:TieredStopAtLevel=1 -XX:-UseInterpreter -Dinterpreted=false
 67  *      jdk.jfr.jvm.TestGetEventWriter
 68  *
 69  * @run main/othervm/timeout=300 -Xcomp -XX:TieredStopAtLevel=4 -XX:-TieredCompilation -XX:-UseInterpreter -Dinterpreted=false
 70  *      jdk.jfr.jvm.TestGetEventWriter
 71  */
 72 
 73 /**
 74  * @test id=jvmci
 75  * @key jfr
 76  * @requires vm.hasJFR
 77  * @requires vm.jvmci
 78  * @library /test/lib
 79  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
 80  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 81  *
 82  * @compile PlaceholderEventWriter.java
<a name="3" id="anc3"></a><span class="line-removed"> 83  * @compile PlaceholderEventWriterFactory.java</span>
 84  * @compile E.java
 85  * @compile NonEvent.java
 86  * @compile RegisteredTrueEvent.java
 87  * @compile RegisteredFalseEvent.java
 88  * @compile MyCommitRegisteredTrueEvent.java
 89  * @compile MyCommitRegisteredFalseEvent.java
 90  * @compile StaticCommitEvent.java
 91  *
 92  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -Dtest.jvmci=true --add-exports=jdk.jfr/jdk.jfr.internal.event=ALL-UNNAMED
 93  *      jdk.jfr.jvm.TestGetEventWriter
 94  */
 95 
 96 public class TestGetEventWriter {
 97 
 98     static class InitializationEvent extends Event {
 99     }
100 
101     public static void main(String... args) throws Throwable {
102         try (Recording r = new Recording()) {
103             r.start();
104             // Unlocks access to jdk.jfr.internal.event
105             InitializationEvent e  = new InitializationEvent();
106             e.commit();
107         }
<a name="4" id="anc4"></a><span class="line-modified">108         // Make sure EventWriterFactory can be accessed.</span>
<span class="line-modified">109         Class&lt;?&gt; clazz = Class.forName(&quot;jdk.jfr.internal.event.EventWriterFactory&quot;);</span>
110         if (clazz == null) {
<a name="5" id="anc5"></a><span class="line-modified">111             throw new Exception(&quot;Test error, not able to access jdk.jfr.internal.event.EventWriterFactory class&quot;);</span>
112         }
113         testRegisteredTrueEvent();
114         testRegisteredFalseEvent();
115         testMyCommitRegisteredTrue();
116         testMyCommitRegisteredFalse();
117         testStaticCommit();
118         testMethodHandleEvent();
119         testReflectionEvent();
120         testNonEvent();
121     }
122 
123     // The class does not inherit jdk.jfr.Event and, as such, does not implement the
124     // API. It has its own stand-alone &quot;commit()V&quot;, which is not an override, that
<a name="6" id="anc6"></a><span class="line-modified">125     // attempts to resolve and link against EventWriterFactory. This user implementation</span>
126     // is not blessed for linkage.
127     private static void testNonEvent() throws Throwable {
128         Runnable e = newEventObject(&quot;NonEvent&quot;);
129         try {
130             e.run(); // invokes commit()
131             throw new RuntimeException(&quot;Should not reach here&quot;);
132         } catch (IllegalAccessError iae) {
133             // OK, as expected
134             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
135             return;
136         }
137     }
138 
139     // The user has defined a class which overrides and implements the &quot;commit()V&quot;
140     // method declared final in jdk.jfr.Event.
141     // This user implementation is not blessed for linkage.
142     private static void testRegisteredTrueEvent() throws Throwable {
143         Event e = newEventObject(&quot;RegisteredTrueEvent&quot;);
144         try {
145             e.commit(); // throws
146             throw new RuntimeException(&quot;Should not reach here&quot;);
147         } catch (IllegalAccessError iae) {
148             // OK, as expected
149             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
150             return;
151         }
152     }
153 
154     // The user has defined a class which overrides and implements the &quot;commit()V&quot;
155     // method declared final in jdk.jfr.Event. This user implementation is not
156     // blessed for linkage. If a class have user-defined implementations
157     // of any methods declared final, it is not instrumented.
158     // Although it is a subclass of jdk.jfr.Event, on initial load, we will
159     // classify it as being outside of the JFR system. Attempting to register
160     // such a class throws an IllegalArgumentException. The user-defined
161     // &quot;commit()V&quot; method is still not blessed for linkage, even after registration.
162     private static void testRegisteredFalseEvent() throws Throwable {
163         Event e = newEventObject(&quot;RegisteredFalseEvent&quot;);
164         try {
165             e.commit(); // throws
166             throw new RuntimeException(&quot;Should not reach here&quot;);
167         } catch (IllegalAccessError iae) {
168             // OK, as expected
169             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
170         }
171         try {
172             FlightRecorder.register(e.getClass());
173         } catch (IllegalArgumentException iae) {
174             // OK, as expected.
175             // Can&#39;t register an event class where the user has managed to override
176             // methods in jdk.jfr.Event
177         }
178     }
179 
180     // The user has implemented another method, &quot;myCommit()V&quot;, not an override nor
<a name="7" id="anc7"></a><span class="line-modified">181     // overload. that attempts to resolve and link EventWriterFactory. This will fail,</span>
182     // because &quot;myCommit()V&quot; is not blessed for linkage.
183     private static void testMyCommitRegisteredTrue() throws Throwable {
184         Runnable e = newEventObject(&quot;MyCommitRegisteredTrueEvent&quot;);
185         try {
186             e.run(); // Invoking the user-defined method throws.
187             throw new RuntimeException(&quot;Should not reach here&quot;);
188         } catch (IllegalAccessError iae) {
189             // OK, as expected
190             maybeCheckJVMCI(e.getClass(), &quot;myCommit&quot;);
191             return;
192         }
193     }
194 
195     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
196     // nor overload. This linkage will fail because &quot;myCommit()V&quot; is not blessed.
197     // Since the user has not defined any final methods in jdk.jfr.Event,
198     // the class is not excluded wholesale from the JFR system.
199     // Invoking the real &quot;commit()V&quot;, installed by the framework, is OK.
200     private static void testMyCommitRegisteredFalse() throws Throwable {
201         Runnable e = newEventObject(&quot;MyCommitRegisteredFalseEvent&quot;);
202         try {
203             e.run(); // Invoking the user-defined method throws.
204             throw new RuntimeException(&quot;Should not reach here&quot;);
205         } catch (IllegalAccessError iae) {
206             // OK, as expected
207             maybeCheckJVMCI(e.getClass(), &quot;myCommit&quot;);
208         }
209         // Instrumentation added.
210         FlightRecorder.register(e.getClass().asSubclass(Event.class));
211         Event event = (Event) e;
212         event.commit(); // Invoking the JFR provided method is OK
213     }
214 
215     // Events located in the boot class loader can create a static
216     // commit-method to emit events. It must not be used by code
217     // outside of the boot class loader.
218     private static void testStaticCommit() throws Throwable {
219         Runnable e = newEventObject(&quot;StaticCommitEvent&quot;);
220         try {
221             e.run(); // Invokes commit(long, long, String, int)
222             throw new RuntimeException(&quot;Should not reach here&quot;);
223         } catch (IllegalAccessError iae) {
224             // OK, as expected
225             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
226         }
227     }
228 
229     static class MethodHandleEvent extends Event {
230         public void myCommit() throws Throwable {
231             try {
232                 Class&lt;?&gt; ew = Class.forName(&quot;jdk.jfr.internal.event.EventWriter&quot;);
<a name="8" id="anc8"></a><span class="line-modified">233                 MethodType t = MethodType.methodType(ew, List.of(long.class));</span>
<span class="line-modified">234                 Class&lt;?&gt; factory = Class.forName(&quot;jdk.jfr.internal.event.EventWriterFactory&quot;);</span>
<span class="line-modified">235                 MethodHandle mh = MethodHandles.lookup().findStatic(factory, &quot;getEventWriter&quot;, t);</span>
<span class="line-removed">236                 mh.invoke(Long.valueOf(4711)); // throws IllegalAccessException</span>
237             } catch (ClassNotFoundException | SecurityException e) {
238                 throw new RuntimeException(e);
239             }
240         }
241     }
242 
243     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
244     // nor overload. This linkage will fail, because &quot;myCommit()V&quot; is not blessed.
245     // Using a MethodHandle for linkage is transparent and immaterial.
246     private static void testMethodHandleEvent() throws Throwable {
247         MethodHandleEvent e = new MethodHandleEvent();
248         try {
249             e.myCommit();
250             throw new RuntimeException(&quot;Should not reach here&quot;);
251         } catch (IllegalAccessException iaex) {
252             if (iaex.getCause() instanceof IllegalAccessError iae) {
253                 if (iae.getMessage().contains(&quot;getEventWriter(long)&quot;)) {
254                     // OK, as expected
255                     return;
256                 }
257             }
258         }
259     }
260 
261     static class ReflectionEvent extends Event {
262         public void myCommit() throws Throwable {
263             Class&lt;?&gt; c;
264             try {
<a name="9" id="anc9"></a><span class="line-modified">265                 c = Class.forName(&quot;jdk.jfr.internal.event.EventWriterFactory&quot;);</span>
<span class="line-modified">266                 Method m = c.getMethod(&quot;getEventWriter&quot;, new Class[] {long.class});</span>
267                 m.invoke(null, Long.valueOf(4711)); // throws InternalError
268             } catch (ClassNotFoundException | SecurityException e) {
269                 throw new RuntimeException(e);
270             }
271         }
272     }
273 
274     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
275     // nor overload, that uses Reflection. This linkage will fail, because
276     // &quot;myCommit()V&quot; is not blessed. Reflection is using method handles,
277     // but using a MethodHandle for linkage is transparent and immaterial.
278     private static void testReflectionEvent() throws Throwable {
279         ReflectionEvent e = new ReflectionEvent();
280         try {
281             e.myCommit(); // throws
282             throw new RuntimeException(&quot;Should not reach here&quot;);
283         } catch (InternalError ie) {
284             if (ie.getCause() instanceof IllegalAccessException iaex) {
285                 if (iaex.getCause() instanceof IllegalAccessError iae) {
<a name="10" id="anc10"></a><span class="line-modified">286                     if (iae.getMessage().contains(&quot;getEventWriter(long)&quot;)) {</span>
287                         // OK, as expected
288                         return;
289                     }
290                 }
291             }
292         }
293     }
294 
295     private static class BytesClassLoader extends ClassLoader {
296         private final byte[] bytes;
297         private final String className;
298 
299         BytesClassLoader(byte[] bytes, String name) {
300             this.bytes = bytes;
301             this.className = name;
302         }
303 
304         @Override
305         public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
306             if (name.equals(className)) {
307                 return defineClass(name, bytes, 0, bytes.length);
308             } else {
309                 return super.loadClass(name);
310             }
311         }
312     }
313 
314     private static byte[] replace(byte[] bytes, String match, String replacement) {
315         if (match.length() != replacement.length()) {
316             throw new IllegalArgumentException(&quot;Match must be same size as replacement&quot;);
317         }
318         for (int i = 0; i &lt; bytes.length - match.length(); i++) {
319             if (match(bytes, i, match)) {
320                 for (int j = 0; j &lt; replacement.length(); j++) {
321                     bytes[i + j] = (byte) replacement.charAt(j);
322                 }
323             }
324         }
325         return bytes;
326     }
327 
328     private static boolean match(byte[] bytes, int offset, String text) {
329         for (int i = 0; i &lt; text.length(); i++) {
330             if (bytes[offset + i] != text.charAt(i)) {
331                 return false;
332             }
333         }
334         return true;
335     }
336 
337     @SuppressWarnings(&quot;unchecked&quot;)
338     private static &lt;T&gt; T newEventObject(String name) throws Throwable {
339         String r = name + &quot;.class&quot;;
340         String fullName = &quot;jdk.jfr.jvm.&quot; + name;
341         var is = TestGetEventWriter.class.getResourceAsStream(r);
342         if (is == null) {
343             throw new Exception(&quot;Test error, could not located class file for &quot; + name);
344         }
345         byte[] bytes = is.readAllBytes();
346         is.close();
347         bytes = replace(bytes, &quot;jdk/jfr/jvm/E&quot;, &quot;jdk/jfr/Event&quot;);
<a name="11" id="anc11"></a><span class="line-removed">348         bytes = replace(bytes, &quot;jdk/jfr/jvm/PlaceholderEventWriterFactory&quot;, &quot;jdk/jfr/internal/event/EventWriterFactory&quot;);</span>
349         bytes = replace(bytes, &quot;jdk/jfr/jvm/PlaceholderEventWriter&quot;, &quot;jdk/jfr/internal/event/EventWriter&quot;);
350         BytesClassLoader bc = new BytesClassLoader(bytes, fullName);
351         Class&lt;?&gt; clazz = bc.loadClass(fullName);
352         Constructor&lt;?&gt; constructor = clazz.getConstructor(new Class[0]);
353         System.out.println(&quot;About to invoke &quot; + fullName + &quot;.commit()&quot;);
354         return (T) constructor.newInstance();
355     }
356 
357     private static ResolvedJavaMethod findCommitMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; eventClass, String commitName) {
358         for (Method m : eventClass.getMethods()) {
359             if (m.getName().equals(commitName)) {
360                 return metaAccess.lookupJavaMethod(m);
361             }
362         }
363         throw new AssertionError(&quot;could not find &quot; + commitName + &quot; method in &quot; + eventClass);
364     }
365 
366     // Factor out test.jvmci system property check to reduce unecessary work in -Xcomp.
367     private static void maybeCheckJVMCI(Class&lt;?&gt; eventClass, String commitName) throws Throwable {
368         if (!Boolean.getBoolean(&quot;test.jvmci&quot;)) {
369             return;
370         }
371         checkJVMCI(eventClass, commitName);
372     }
373 
374     /**
<a name="12" id="anc12"></a><span class="line-modified">375      * Checks that JVMCI prevents unblessed access to {@code EventWriterFactory.getEventWriter(long)}.</span>
376      */
377     private static void checkJVMCI(Class&lt;?&gt; eventClass, String commitName) throws Throwable {
378         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
379         ResolvedJavaMethod commit = findCommitMethod(metaAccess, eventClass, commitName);
380         ConstantPool cp = commit.getConstantPool();
381 
382         // Search for first INVOKESTATIC instruction in commit method which is expected
<a name="13" id="anc13"></a><span class="line-modified">383         // to be the call to jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long).</span>
384         final int INVOKESTATIC = 184;
385         byte[] code = commit.getCode();
386         for (int bci = 0; bci &lt; code.length; bci++) {
387             int b = code[bci] &amp; 0xff;
388             if (b == INVOKESTATIC) {
389                 int cpi = ((code[bci + 1] &amp; 0xff) &lt;&lt; 8) | (code[bci + 2] &amp; 0xff);
390                 try {
391                     cp.lookupMethod(cpi, 184, commit);
392                     throw new AssertionError(&quot;Expected IllegalAccessError&quot;);
393                 } catch (IllegalAccessError e) {
394                 }
395                 try {
396                     // Test looking up with null caller
397                     cp.lookupMethod(cpi, 184, null);
398                     throw new AssertionError(&quot;Expected IllegalAccessError&quot;);
399                 } catch (IllegalAccessError e) {
400                 }
401 
402                 // Ignore all subsequent instructions
403                 return;
404             }
405         }
406         throw new AssertionError(eventClass + &quot;: did not find INVOKESTATIC in &quot; + commit.format(&quot;%H.%n(%p)&quot;));
407     }
408 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>