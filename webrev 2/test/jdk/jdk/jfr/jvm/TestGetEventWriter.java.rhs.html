<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/jdk/jfr/jvm/TestGetEventWriter.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.jfr.jvm;
 25 
 26 import java.lang.invoke.MethodHandle;
 27 import java.lang.invoke.MethodHandles;
 28 import java.lang.invoke.MethodType;
 29 import java.lang.reflect.Constructor;
 30 import java.lang.reflect.Method;
 31 import java.util.List;
 32 import jdk.jfr.Event;
 33 import jdk.jfr.FlightRecorder;
 34 import jdk.jfr.Recording;
 35 import jdk.vm.ci.meta.MetaAccessProvider;
 36 import jdk.vm.ci.meta.ResolvedJavaMethod;
 37 import jdk.vm.ci.meta.ConstantPool;
 38 import jdk.vm.ci.runtime.JVMCI;
 39 
 40 /**
 41  * @test id=default
 42  * @key jfr
 43  * @requires vm.hasJFR
 44  * @library /test/lib
 45  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
 46  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 47  *
 48  * @compile PlaceholderEventWriter.java
<a name="2" id="anc2"></a>
 49  * @compile E.java
 50  * @compile NonEvent.java
 51  * @compile RegisteredTrueEvent.java
 52  * @compile RegisteredFalseEvent.java
 53  * @compile MyCommitRegisteredTrueEvent.java
 54  * @compile MyCommitRegisteredFalseEvent.java
 55  * @compile StaticCommitEvent.java
 56  *
 57  * @run main/othervm jdk.jfr.jvm.TestGetEventWriter
 58  *
 59  * @run main/othervm/timeout=300 -Xint -XX:+UseInterpreter -Dinterpreted=true
 60  *      jdk.jfr.jvm.TestGetEventWriter
 61  *
 62  * @run main/othervm/timeout=300 -Xcomp -XX:-UseInterpreter -Dinterpreted=false
 63  *      jdk.jfr.jvm.TestGetEventWriter
 64  *
 65  * @run main/othervm/timeout=300 -Xcomp -XX:TieredStopAtLevel=1 -XX:-UseInterpreter -Dinterpreted=false
 66  *      jdk.jfr.jvm.TestGetEventWriter
 67  *
 68  * @run main/othervm/timeout=300 -Xcomp -XX:TieredStopAtLevel=4 -XX:-TieredCompilation -XX:-UseInterpreter -Dinterpreted=false
 69  *      jdk.jfr.jvm.TestGetEventWriter
 70  */
 71 
 72 /**
 73  * @test id=jvmci
 74  * @key jfr
 75  * @requires vm.hasJFR
 76  * @requires vm.jvmci
 77  * @library /test/lib
 78  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
 79  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 80  *
 81  * @compile PlaceholderEventWriter.java
<a name="3" id="anc3"></a>
 82  * @compile E.java
 83  * @compile NonEvent.java
 84  * @compile RegisteredTrueEvent.java
 85  * @compile RegisteredFalseEvent.java
 86  * @compile MyCommitRegisteredTrueEvent.java
 87  * @compile MyCommitRegisteredFalseEvent.java
 88  * @compile StaticCommitEvent.java
 89  *
 90  * @run main/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -Dtest.jvmci=true --add-exports=jdk.jfr/jdk.jfr.internal.event=ALL-UNNAMED
 91  *      jdk.jfr.jvm.TestGetEventWriter
 92  */
 93 
 94 public class TestGetEventWriter {
 95 
 96     static class InitializationEvent extends Event {
 97     }
 98 
 99     public static void main(String... args) throws Throwable {
100         try (Recording r = new Recording()) {
101             r.start();
102             // Unlocks access to jdk.jfr.internal.event
103             InitializationEvent e  = new InitializationEvent();
104             e.commit();
105         }
<a name="4" id="anc4"></a><span class="line-modified">106         // Make sure EventWriter class can be accessed.</span>
<span class="line-modified">107         Class&lt;?&gt; clazz = Class.forName(&quot;jdk.jfr.internal.event.EventWriter&quot;);</span>
108         if (clazz == null) {
<a name="5" id="anc5"></a><span class="line-modified">109             throw new Exception(&quot;Test error, not able to access jdk.jfr.internal.event.EventWriter class&quot;);</span>
110         }
111         testRegisteredTrueEvent();
112         testRegisteredFalseEvent();
113         testMyCommitRegisteredTrue();
114         testMyCommitRegisteredFalse();
115         testStaticCommit();
116         testMethodHandleEvent();
117         testReflectionEvent();
118         testNonEvent();
119     }
120 
121     // The class does not inherit jdk.jfr.Event and, as such, does not implement the
122     // API. It has its own stand-alone &quot;commit()V&quot;, which is not an override, that
<a name="6" id="anc6"></a><span class="line-modified">123     // attempts to resolve and link against EventWriter. This user implementation</span>
124     // is not blessed for linkage.
125     private static void testNonEvent() throws Throwable {
126         Runnable e = newEventObject(&quot;NonEvent&quot;);
127         try {
128             e.run(); // invokes commit()
129             throw new RuntimeException(&quot;Should not reach here&quot;);
130         } catch (IllegalAccessError iae) {
131             // OK, as expected
132             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
133             return;
134         }
135     }
136 
137     // The user has defined a class which overrides and implements the &quot;commit()V&quot;
138     // method declared final in jdk.jfr.Event.
139     // This user implementation is not blessed for linkage.
140     private static void testRegisteredTrueEvent() throws Throwable {
141         Event e = newEventObject(&quot;RegisteredTrueEvent&quot;);
142         try {
143             e.commit(); // throws
144             throw new RuntimeException(&quot;Should not reach here&quot;);
145         } catch (IllegalAccessError iae) {
146             // OK, as expected
147             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
148             return;
149         }
150     }
151 
152     // The user has defined a class which overrides and implements the &quot;commit()V&quot;
153     // method declared final in jdk.jfr.Event. This user implementation is not
154     // blessed for linkage. If a class have user-defined implementations
155     // of any methods declared final, it is not instrumented.
156     // Although it is a subclass of jdk.jfr.Event, on initial load, we will
157     // classify it as being outside of the JFR system. Attempting to register
158     // such a class throws an IllegalArgumentException. The user-defined
159     // &quot;commit()V&quot; method is still not blessed for linkage, even after registration.
160     private static void testRegisteredFalseEvent() throws Throwable {
161         Event e = newEventObject(&quot;RegisteredFalseEvent&quot;);
162         try {
163             e.commit(); // throws
164             throw new RuntimeException(&quot;Should not reach here&quot;);
165         } catch (IllegalAccessError iae) {
166             // OK, as expected
167             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
168         }
169         try {
170             FlightRecorder.register(e.getClass());
171         } catch (IllegalArgumentException iae) {
172             // OK, as expected.
173             // Can&#39;t register an event class where the user has managed to override
174             // methods in jdk.jfr.Event
175         }
176     }
177 
178     // The user has implemented another method, &quot;myCommit()V&quot;, not an override nor
<a name="7" id="anc7"></a><span class="line-modified">179     // overload. that attempts to resolve and link EventWriter. This will fail,</span>
180     // because &quot;myCommit()V&quot; is not blessed for linkage.
181     private static void testMyCommitRegisteredTrue() throws Throwable {
182         Runnable e = newEventObject(&quot;MyCommitRegisteredTrueEvent&quot;);
183         try {
184             e.run(); // Invoking the user-defined method throws.
185             throw new RuntimeException(&quot;Should not reach here&quot;);
186         } catch (IllegalAccessError iae) {
187             // OK, as expected
188             maybeCheckJVMCI(e.getClass(), &quot;myCommit&quot;);
189             return;
190         }
191     }
192 
193     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
194     // nor overload. This linkage will fail because &quot;myCommit()V&quot; is not blessed.
195     // Since the user has not defined any final methods in jdk.jfr.Event,
196     // the class is not excluded wholesale from the JFR system.
197     // Invoking the real &quot;commit()V&quot;, installed by the framework, is OK.
198     private static void testMyCommitRegisteredFalse() throws Throwable {
199         Runnable e = newEventObject(&quot;MyCommitRegisteredFalseEvent&quot;);
200         try {
201             e.run(); // Invoking the user-defined method throws.
202             throw new RuntimeException(&quot;Should not reach here&quot;);
203         } catch (IllegalAccessError iae) {
204             // OK, as expected
205             maybeCheckJVMCI(e.getClass(), &quot;myCommit&quot;);
206         }
207         // Instrumentation added.
208         FlightRecorder.register(e.getClass().asSubclass(Event.class));
209         Event event = (Event) e;
210         event.commit(); // Invoking the JFR provided method is OK
211     }
212 
213     // Events located in the boot class loader can create a static
214     // commit-method to emit events. It must not be used by code
215     // outside of the boot class loader.
216     private static void testStaticCommit() throws Throwable {
217         Runnable e = newEventObject(&quot;StaticCommitEvent&quot;);
218         try {
219             e.run(); // Invokes commit(long, long, String, int)
220             throw new RuntimeException(&quot;Should not reach here&quot;);
221         } catch (IllegalAccessError iae) {
222             // OK, as expected
223             maybeCheckJVMCI(e.getClass(), &quot;commit&quot;);
224         }
225     }
226 
227     static class MethodHandleEvent extends Event {
228         public void myCommit() throws Throwable {
229             try {
230                 Class&lt;?&gt; ew = Class.forName(&quot;jdk.jfr.internal.event.EventWriter&quot;);
<a name="8" id="anc8"></a><span class="line-modified">231                 MethodType t = MethodType.methodType(ew, List.of());</span>
<span class="line-modified">232                 MethodHandle mh = MethodHandles.lookup().findStatic(ew, &quot;getEventWriter&quot;, t);</span>
<span class="line-modified">233                 mh.invoke(); // throws IllegalAccessException</span>

234             } catch (ClassNotFoundException | SecurityException e) {
235                 throw new RuntimeException(e);
236             }
237         }
238     }
239 
240     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
241     // nor overload. This linkage will fail, because &quot;myCommit()V&quot; is not blessed.
242     // Using a MethodHandle for linkage is transparent and immaterial.
243     private static void testMethodHandleEvent() throws Throwable {
244         MethodHandleEvent e = new MethodHandleEvent();
245         try {
246             e.myCommit();
247             throw new RuntimeException(&quot;Should not reach here&quot;);
248         } catch (IllegalAccessException iaex) {
249             if (iaex.getCause() instanceof IllegalAccessError iae) {
250                 if (iae.getMessage().contains(&quot;getEventWriter(long)&quot;)) {
251                     // OK, as expected
252                     return;
253                 }
254             }
255         }
256     }
257 
258     static class ReflectionEvent extends Event {
259         public void myCommit() throws Throwable {
260             Class&lt;?&gt; c;
261             try {
<a name="9" id="anc9"></a><span class="line-modified">262                 c = Class.forName(&quot;jdk.jfr.internal.event.EventWriter&quot;);</span>
<span class="line-modified">263                 Method m = c.getMethod(&quot;getEventWriter&quot;, new Class[0]);</span>
264                 m.invoke(null, Long.valueOf(4711)); // throws InternalError
265             } catch (ClassNotFoundException | SecurityException e) {
266                 throw new RuntimeException(e);
267             }
268         }
269     }
270 
271     // The user has implemented another method, &quot;myCommit()V&quot;, not an override,
272     // nor overload, that uses Reflection. This linkage will fail, because
273     // &quot;myCommit()V&quot; is not blessed. Reflection is using method handles,
274     // but using a MethodHandle for linkage is transparent and immaterial.
275     private static void testReflectionEvent() throws Throwable {
276         ReflectionEvent e = new ReflectionEvent();
277         try {
278             e.myCommit(); // throws
279             throw new RuntimeException(&quot;Should not reach here&quot;);
280         } catch (InternalError ie) {
281             if (ie.getCause() instanceof IllegalAccessException iaex) {
282                 if (iaex.getCause() instanceof IllegalAccessError iae) {
<a name="10" id="anc10"></a><span class="line-modified">283                     if (iae.getMessage().contains(&quot;getEventWriter()&quot;)) {</span>
284                         // OK, as expected
285                         return;
286                     }
287                 }
288             }
289         }
290     }
291 
292     private static class BytesClassLoader extends ClassLoader {
293         private final byte[] bytes;
294         private final String className;
295 
296         BytesClassLoader(byte[] bytes, String name) {
297             this.bytes = bytes;
298             this.className = name;
299         }
300 
301         @Override
302         public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
303             if (name.equals(className)) {
304                 return defineClass(name, bytes, 0, bytes.length);
305             } else {
306                 return super.loadClass(name);
307             }
308         }
309     }
310 
311     private static byte[] replace(byte[] bytes, String match, String replacement) {
312         if (match.length() != replacement.length()) {
313             throw new IllegalArgumentException(&quot;Match must be same size as replacement&quot;);
314         }
315         for (int i = 0; i &lt; bytes.length - match.length(); i++) {
316             if (match(bytes, i, match)) {
317                 for (int j = 0; j &lt; replacement.length(); j++) {
318                     bytes[i + j] = (byte) replacement.charAt(j);
319                 }
320             }
321         }
322         return bytes;
323     }
324 
325     private static boolean match(byte[] bytes, int offset, String text) {
326         for (int i = 0; i &lt; text.length(); i++) {
327             if (bytes[offset + i] != text.charAt(i)) {
328                 return false;
329             }
330         }
331         return true;
332     }
333 
334     @SuppressWarnings(&quot;unchecked&quot;)
335     private static &lt;T&gt; T newEventObject(String name) throws Throwable {
336         String r = name + &quot;.class&quot;;
337         String fullName = &quot;jdk.jfr.jvm.&quot; + name;
338         var is = TestGetEventWriter.class.getResourceAsStream(r);
339         if (is == null) {
340             throw new Exception(&quot;Test error, could not located class file for &quot; + name);
341         }
342         byte[] bytes = is.readAllBytes();
343         is.close();
344         bytes = replace(bytes, &quot;jdk/jfr/jvm/E&quot;, &quot;jdk/jfr/Event&quot;);
<a name="11" id="anc11"></a>
345         bytes = replace(bytes, &quot;jdk/jfr/jvm/PlaceholderEventWriter&quot;, &quot;jdk/jfr/internal/event/EventWriter&quot;);
346         BytesClassLoader bc = new BytesClassLoader(bytes, fullName);
347         Class&lt;?&gt; clazz = bc.loadClass(fullName);
348         Constructor&lt;?&gt; constructor = clazz.getConstructor(new Class[0]);
349         System.out.println(&quot;About to invoke &quot; + fullName + &quot;.commit()&quot;);
350         return (T) constructor.newInstance();
351     }
352 
353     private static ResolvedJavaMethod findCommitMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; eventClass, String commitName) {
354         for (Method m : eventClass.getMethods()) {
355             if (m.getName().equals(commitName)) {
356                 return metaAccess.lookupJavaMethod(m);
357             }
358         }
359         throw new AssertionError(&quot;could not find &quot; + commitName + &quot; method in &quot; + eventClass);
360     }
361 
362     // Factor out test.jvmci system property check to reduce unecessary work in -Xcomp.
363     private static void maybeCheckJVMCI(Class&lt;?&gt; eventClass, String commitName) throws Throwable {
364         if (!Boolean.getBoolean(&quot;test.jvmci&quot;)) {
365             return;
366         }
367         checkJVMCI(eventClass, commitName);
368     }
369 
370     /**
<a name="12" id="anc12"></a><span class="line-modified">371      * Checks that JVMCI prevents unblessed access to {@code EventWriter.getEventWriter()}.</span>
372      */
373     private static void checkJVMCI(Class&lt;?&gt; eventClass, String commitName) throws Throwable {
374         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
375         ResolvedJavaMethod commit = findCommitMethod(metaAccess, eventClass, commitName);
376         ConstantPool cp = commit.getConstantPool();
377 
378         // Search for first INVOKESTATIC instruction in commit method which is expected
<a name="13" id="anc13"></a><span class="line-modified">379         // to be the call to jdk.jfr.internal.event.EventWriter.getEventWriter().</span>
380         final int INVOKESTATIC = 184;
381         byte[] code = commit.getCode();
382         for (int bci = 0; bci &lt; code.length; bci++) {
383             int b = code[bci] &amp; 0xff;
384             if (b == INVOKESTATIC) {
385                 int cpi = ((code[bci + 1] &amp; 0xff) &lt;&lt; 8) | (code[bci + 2] &amp; 0xff);
386                 try {
387                     cp.lookupMethod(cpi, 184, commit);
388                     throw new AssertionError(&quot;Expected IllegalAccessError&quot;);
389                 } catch (IllegalAccessError e) {
390                 }
391                 try {
392                     // Test looking up with null caller
393                     cp.lookupMethod(cpi, 184, null);
394                     throw new AssertionError(&quot;Expected IllegalAccessError&quot;);
395                 } catch (IllegalAccessError e) {
396                 }
397 
398                 // Ignore all subsequent instructions
399                 return;
400             }
401         }
402         throw new AssertionError(eventClass + &quot;: did not find INVOKESTATIC in &quot; + commit.format(&quot;%H.%n(%p)&quot;));
403     }
404 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>