diff a/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java b/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
--- a/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
+++ b/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -44,11 +44,10 @@
  * @library /test/lib
  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *
  * @compile PlaceholderEventWriter.java
- * @compile PlaceholderEventWriterFactory.java
  * @compile E.java
  * @compile NonEvent.java
  * @compile RegisteredTrueEvent.java
  * @compile RegisteredFalseEvent.java
  * @compile MyCommitRegisteredTrueEvent.java
@@ -78,11 +77,10 @@
  * @library /test/lib
  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *
  * @compile PlaceholderEventWriter.java
- * @compile PlaceholderEventWriterFactory.java
  * @compile E.java
  * @compile NonEvent.java
  * @compile RegisteredTrueEvent.java
  * @compile RegisteredFalseEvent.java
  * @compile MyCommitRegisteredTrueEvent.java
@@ -103,14 +101,14 @@
             r.start();
             // Unlocks access to jdk.jfr.internal.event
             InitializationEvent e  = new InitializationEvent();
             e.commit();
         }
-        // Make sure EventWriterFactory can be accessed.
-        Class<?> clazz = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
+        // Make sure EventWriter class can be accessed.
+        Class<?> clazz = Class.forName("jdk.jfr.internal.event.EventWriter");
         if (clazz == null) {
-            throw new Exception("Test error, not able to access jdk.jfr.internal.event.EventWriterFactory class");
+            throw new Exception("Test error, not able to access jdk.jfr.internal.event.EventWriter class");
         }
         testRegisteredTrueEvent();
         testRegisteredFalseEvent();
         testMyCommitRegisteredTrue();
         testMyCommitRegisteredFalse();
@@ -120,11 +118,11 @@
         testNonEvent();
     }
 
     // The class does not inherit jdk.jfr.Event and, as such, does not implement the
     // API. It has its own stand-alone "commit()V", which is not an override, that
-    // attempts to resolve and link against EventWriterFactory. This user implementation
+    // attempts to resolve and link against EventWriter. This user implementation
     // is not blessed for linkage.
     private static void testNonEvent() throws Throwable {
         Runnable e = newEventObject("NonEvent");
         try {
             e.run(); // invokes commit()
@@ -176,11 +174,11 @@
             // methods in jdk.jfr.Event
         }
     }
 
     // The user has implemented another method, "myCommit()V", not an override nor
-    // overload. that attempts to resolve and link EventWriterFactory. This will fail,
+    // overload. that attempts to resolve and link EventWriter. This will fail,
     // because "myCommit()V" is not blessed for linkage.
     private static void testMyCommitRegisteredTrue() throws Throwable {
         Runnable e = newEventObject("MyCommitRegisteredTrueEvent");
         try {
             e.run(); // Invoking the user-defined method throws.
@@ -228,14 +226,13 @@
 
     static class MethodHandleEvent extends Event {
         public void myCommit() throws Throwable {
             try {
                 Class<?> ew = Class.forName("jdk.jfr.internal.event.EventWriter");
-                MethodType t = MethodType.methodType(ew, List.of(long.class));
-                Class<?> factory = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
-                MethodHandle mh = MethodHandles.lookup().findStatic(factory, "getEventWriter", t);
-                mh.invoke(Long.valueOf(4711)); // throws IllegalAccessException
+                MethodType t = MethodType.methodType(ew, List.of());
+                MethodHandle mh = MethodHandles.lookup().findStatic(ew, "getEventWriter", t);
+                mh.invoke(); // throws IllegalAccessException
             } catch (ClassNotFoundException | SecurityException e) {
                 throw new RuntimeException(e);
             }
         }
     }
@@ -260,12 +257,12 @@
 
     static class ReflectionEvent extends Event {
         public void myCommit() throws Throwable {
             Class<?> c;
             try {
-                c = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
-                Method m = c.getMethod("getEventWriter", new Class[] {long.class});
+                c = Class.forName("jdk.jfr.internal.event.EventWriter");
+                Method m = c.getMethod("getEventWriter", new Class[0]);
                 m.invoke(null, Long.valueOf(4711)); // throws InternalError
             } catch (ClassNotFoundException | SecurityException e) {
                 throw new RuntimeException(e);
             }
         }
@@ -281,11 +278,11 @@
             e.myCommit(); // throws
             throw new RuntimeException("Should not reach here");
         } catch (InternalError ie) {
             if (ie.getCause() instanceof IllegalAccessException iaex) {
                 if (iaex.getCause() instanceof IllegalAccessError iae) {
-                    if (iae.getMessage().contains("getEventWriter(long)")) {
+                    if (iae.getMessage().contains("getEventWriter()")) {
                         // OK, as expected
                         return;
                     }
                 }
             }
@@ -343,11 +340,10 @@
             throw new Exception("Test error, could not located class file for " + name);
         }
         byte[] bytes = is.readAllBytes();
         is.close();
         bytes = replace(bytes, "jdk/jfr/jvm/E", "jdk/jfr/Event");
-        bytes = replace(bytes, "jdk/jfr/jvm/PlaceholderEventWriterFactory", "jdk/jfr/internal/event/EventWriterFactory");
         bytes = replace(bytes, "jdk/jfr/jvm/PlaceholderEventWriter", "jdk/jfr/internal/event/EventWriter");
         BytesClassLoader bc = new BytesClassLoader(bytes, fullName);
         Class<?> clazz = bc.loadClass(fullName);
         Constructor<?> constructor = clazz.getConstructor(new Class[0]);
         System.out.println("About to invoke " + fullName + ".commit()");
@@ -370,19 +366,19 @@
         }
         checkJVMCI(eventClass, commitName);
     }
 
     /**
-     * Checks that JVMCI prevents unblessed access to {@code EventWriterFactory.getEventWriter(long)}.
+     * Checks that JVMCI prevents unblessed access to {@code EventWriter.getEventWriter()}.
      */
     private static void checkJVMCI(Class<?> eventClass, String commitName) throws Throwable {
         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
         ResolvedJavaMethod commit = findCommitMethod(metaAccess, eventClass, commitName);
         ConstantPool cp = commit.getConstantPool();
 
         // Search for first INVOKESTATIC instruction in commit method which is expected
-        // to be the call to jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long).
+        // to be the call to jdk.jfr.internal.event.EventWriter.getEventWriter().
         final int INVOKESTATIC = 184;
         byte[] code = commit.getCode();
         for (int bci = 0; bci < code.length; bci++) {
             int b = code[bci] & 0xff;
             if (b == INVOKESTATIC) {
