diff a/src/hotspot/share/jfr/support/jfrIntrinsics.hpp b/src/hotspot/share/jfr/support/jfrIntrinsics.hpp
--- a/src/hotspot/share/jfr/support/jfrIntrinsics.hpp
+++ b/src/hotspot/share/jfr/support/jfrIntrinsics.hpp
@@ -47,11 +47,11 @@
 #define JFR_HAVE_INTRINSICS
 
 #define JFR_TEMPLATES(template)                                                                                      \
   template(jdk_jfr_internal_management_HiddenWait,                    "jdk/jfr/internal/management/HiddenWait")      \
   template(jdk_jfr_internal_JVM,                                      "jdk/jfr/internal/JVM")                        \
-  template(jdk_jfr_internal_event_EventWriterFactory,                 "jdk/jfr/internal/event/EventWriterFactory")   \
+  template(jdk_jfr_internal_event_EventWriter,                        "jdk/jfr/internal/event/EventWriter")   \
   template(jdk_jfr_internal_event_EventConfiguration_signature,       "Ljdk/jfr/internal/event/EventConfiguration;") \
   template(getEventWriter_signature,                                  "()Ljdk/jfr/internal/event/EventWriter;")      \
   template(eventConfiguration_name,                                   "eventConfiguration")                          \
   template(commit_name,                                               "commit")                                      \
 
diff a/src/hotspot/share/jfr/support/jfrResolution.cpp b/src/hotspot/share/jfr/support/jfrResolution.cpp
--- a/src/hotspot/share/jfr/support/jfrResolution.cpp
+++ b/src/hotspot/share/jfr/support/jfrResolution.cpp
@@ -180,11 +180,11 @@
   }
   const vframeStream ljf(jt, true, false);
   return ljf.method();
 }
 
-static const char* const link_error_msg = "illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'";
+static const char* const link_error_msg = "illegal access linking method 'jdk.jfr.internal.event.EventWriter.getEventWriter()'";
 
 void JfrResolution::on_runtime_resolution(const CallInfo & info, TRAPS) {
   assert(info.selected_method() != nullptr, "invariant");
   assert(info.resolved_klass() != nullptr, "invariant");
   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
@@ -197,16 +197,16 @@
   }
   // Fast path
   if (method->name() != event_writer_method_name) {
     return;
   }
-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();
-  assert(event_writer_factory_klass_name != nullptr, "invariant");
-  if (info.resolved_klass()->name() != event_writer_factory_klass_name) {
+  static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();
+  assert(event_writer_klass_name != nullptr, "invariant");
+  if (info.resolved_klass()->name() != event_writer_klass_name) {
     return;
   }
-  // Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().
+  // Attempting to link against jdk.jfr.internal.event.EventWriter.getEventWriter().
   // The sender, i.e. the method attempting to link, is in the ljf (if one exists).
   const Method* const sender = ljf_sender_method(THREAD);
   if (sender == nullptr) {
     // A compiler thread is doing linktime resolution but there is no information about the sender available.
     // For the compiler threads, the sender is instead found as part of bytecode parsing.
@@ -226,13 +226,13 @@
 #endif
   THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);
 }
 
 static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {
-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();
-  assert(event_writer_factory_klass_name != nullptr, "invariant");
-  if (holder != event_writer_factory_klass_name) {
+  static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();
+  assert(event_writer_klass_name != nullptr, "invariant");
+  if (holder != event_writer_klass_name) {
     return false;
   }
   static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();
   assert(event_writer_method_name != nullptr, "invariant");
   return name == event_writer_method_name;
diff a/src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java b/src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/AnnotationElement.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,11 +35,10 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.StringJoiner;
 
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.TypeLibrary;
 import jdk.jfr.internal.util.Utils;
 
 /**
@@ -113,11 +112,10 @@
      *         signatures in the {@code annotationType}
      */
     public AnnotationElement(Class<? extends Annotation> annotationType, Map<String, Object> values) {
         Objects.requireNonNull(annotationType, "annotationType");
         Objects.requireNonNull(values, "values");
-        SecuritySupport.checkRegisterPermission();
         // copy values to avoid modification after validation
         HashMap<String, Object> map = new HashMap<>(values);
         for (Map.Entry<String, Object> entry : map.entrySet()) {
             if (entry.getKey() == null) {
                 throw new NullPointerException("Name of annotation method can't be null");
diff a/src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java b/src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/EventFactory.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,11 +35,10 @@
 
 import jdk.internal.module.Checks;
 import jdk.jfr.internal.EventClassBuilder;
 import jdk.jfr.internal.JVMSupport;
 import jdk.jfr.internal.MetadataRepository;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.Utils;
 
 /**
  * Class for defining an event at runtime.
@@ -97,12 +96,10 @@
     public static EventFactory create(List<AnnotationElement> annotationElements, List<ValueDescriptor> fields) {
         Objects.requireNonNull(annotationElements, "annotationElements");
         Objects.requireNonNull(fields, "fields");
         JVMSupport.ensureWithInternalError();
 
-        SecuritySupport.checkRegisterPermission();
-
         List<AnnotationElement> sanitizedAnnotation = Utils.sanitizeNullFreeList(annotationElements, AnnotationElement.class);
         List<ValueDescriptor> sanitizedFields = Utils.sanitizeNullFreeList(fields, ValueDescriptor.class);
         Set<String> nameSet = HashSet.newHashSet(sanitizedFields.size());
         for (ValueDescriptor v : sanitizedFields) {
             String name = v.getName();
diff a/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java b/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,12 +27,10 @@
 
 import static jdk.jfr.internal.LogLevel.DEBUG;
 import static jdk.jfr.internal.LogLevel.INFO;
 import static jdk.jfr.internal.LogTag.JFR;
 
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
@@ -42,11 +40,10 @@
 import jdk.jfr.internal.MetadataRepository;
 import jdk.jfr.internal.Options;
 import jdk.jfr.internal.PlatformRecorder;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.periodic.PeriodicEvents;
 
 /**
  * Class for accessing, controlling, and managing Flight Recorder.
@@ -155,11 +152,10 @@
      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
      *         support, or if the file repository can't be created or accessed)
      */
     public static FlightRecorder getFlightRecorder() throws IllegalStateException {
         synchronized (PlatformRecorder.class) {
-            SecuritySupport.checkAccessFlightRecorder();
             JVMSupport.ensureWithIllegalStateException();
             if (platformRecorder == null) {
                 try {
                     platformRecorder = new FlightRecorder(new PlatformRecorder());
                 } catch (IllegalStateException ise) {
@@ -211,25 +207,21 @@
         if (JVMSupport.isNotAvailable()) {
             return;
         }
 
         Utils.ensureValidEventSubclass(eventClass);
-        SecuritySupport.checkRegisterPermission();
-        @SuppressWarnings("removal")
-        AccessControlContext acc = AccessController.getContext();
-        PeriodicEvents.addUserEvent(acc, eventClass, hook);
+        PeriodicEvents.addJavaEvent(eventClass, hook);
     }
 
     /**
      * Removes a hook for a periodic event.
      *
      * @param hook the hook to remove, not {@code null}
      * @return {@code true} if hook is removed, {@code false} otherwise
      */
     public static boolean removePeriodicEvent(Runnable hook) {
         Objects.requireNonNull(hook, "hook");
-        SecuritySupport.checkRegisterPermission();
         if (JVMSupport.isNotAvailable()) {
             return false;
         }
         return PeriodicEvents.removeEvent(hook);
     }
@@ -247,22 +239,20 @@
     public List<EventType> getEventTypes() {
         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
     }
 
     /**
-     * Adds a recorder listener and captures the {@code AccessControlContext} to
-     * use when invoking the listener.
+     * Adds a recorder listener.
      * <p>
      * If Flight Recorder is already initialized when the listener is added, then the method
      * {@link FlightRecorderListener#recorderInitialized(FlightRecorder)} method is
      * invoked before returning from this method.
      *
      * @param changeListener the listener to add, not {@code null}
      */
     public static void addListener(FlightRecorderListener changeListener) {
         Objects.requireNonNull(changeListener, "changeListener");
-        SecuritySupport.checkAccessFlightRecorder();
         if (JVMSupport.isNotAvailable()) {
             return;
         }
         PlatformRecorder.addListener(changeListener);
     }
@@ -278,11 +268,10 @@
      * @return {@code true}, if the listener could be removed, {@code false}
      *         otherwise
      */
     public static boolean removeListener(FlightRecorderListener changeListener) {
         Objects.requireNonNull(changeListener, "changeListener");
-        SecuritySupport.checkAccessFlightRecorder();
         if (JVMSupport.isNotAvailable()) {
             return false;
         }
 
         return PlatformRecorder.removeListener(changeListener);
diff a/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorderPermission.java b/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorderPermission.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorderPermission.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/FlightRecorderPermission.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,20 +23,18 @@
  * questions.
  */
 
 package jdk.jfr;
 
-import java.security.AccessControlContext;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.PlatformRecorder;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.management.EventSettingsModifier;
 
 /**
  * Permission for controlling access to Flight Recorder.
@@ -154,16 +152,10 @@
         @Override
         public PlatformRecorder getPlatformRecorder() {
             return FlightRecorder.getFlightRecorder().getInternal();
         }
 
-        @SuppressWarnings("removal")
-        @Override
-        public AccessControlContext getContext(SettingControl settingControl) {
-            return settingControl.getContext();
-        }
-
         @Override
         public EventSettings newEventSettings(EventSettingsModifier esm) {
             return new EventSettings.DelegatedEventSettings(esm);
         }
 
@@ -182,10 +174,10 @@
      *
      * @throws IllegalArgumentException if {@code name} is empty or not valid
      */
     public FlightRecorderPermission(String name) {
         super(Objects.requireNonNull(name, "name"));
-        if (!name.equals(SecuritySupport.ACCESS_FLIGHT_RECORDER) && !name.equals(SecuritySupport.REGISTER_EVENT)) {
+        if (!name.equals("accessFlightRecorder") && !name.equals("registerEvent")) {
             throw new IllegalArgumentException("name: " + name);
         }
     }
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/Recording.java b/src/jdk.jfr/share/classes/jdk/jfr/Recording.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/Recording.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/Recording.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,11 +37,11 @@
 
 import jdk.jfr.internal.PlatformRecorder;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.Utils;
-import jdk.jfr.internal.WriteableUserPath;
+import jdk.jfr.internal.WriteablePath;
 
 /**
  * Provides means to configure, start, stop and dump recording data to disk.
  * <p>
  * The following example shows how configure, start, stop and dump recording data to disk.
@@ -366,11 +366,11 @@
      * @see #getState()
      * @see #isToDisk()
      */
     public void dump(Path destination) throws IOException {
         Objects.requireNonNull(destination, "destination");
-        internal.dump(new WriteableUserPath(destination));
+        internal.dump(new WriteablePath(destination));
     }
 
     /**
      * Returns {@code true} if this recording uses the disk repository, {@code false} otherwise.
      * <p>
@@ -459,25 +459,25 @@
      *         {@code CLOSED} state.
      *
      * @throws IOException if the path is not writable
      */
     public void setDestination(Path destination) throws IOException {
-        internal.setDestination(destination != null ? new WriteableUserPath(destination) : null);
+        internal.setDestination(destination != null ? new WriteablePath(destination) : null);
     }
 
     /**
      * Returns the destination file, where recording data is written when the
      * recording stops, or {@code null} if no destination is set.
      *
      * @return the destination file, or {@code null} if not set.
      */
     public Path getDestination() {
-        WriteableUserPath usp = internal.getDestination();
-        if (usp == null) {
+        WriteablePath wp = internal.getDestination();
+        if (wp == null) {
             return null;
         } else {
-            return usp.getPotentiallyMaliciousOriginal();
+            return wp.getPath();
         }
     }
 
     /**
      * Returns a unique ID for this recording.
diff a/src/jdk.jfr/share/classes/jdk/jfr/SettingControl.java b/src/jdk.jfr/share/classes/jdk/jfr/SettingControl.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/SettingControl.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/SettingControl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,16 +23,12 @@
  * questions.
  */
 
 package jdk.jfr;
 
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.util.Set;
 
-import jdk.jfr.internal.settings.JDKSettingControl;
-
 /**
  * Base class to extend to create setting controls.
  * <p>
  * The following example shows a naive implementation of a setting control for
  * regular expressions:
@@ -75,34 +71,14 @@
  * @since 9
  */
 @MetadataDefinition
 public abstract class SettingControl {
 
-    @SuppressWarnings("removal")
-    private final AccessControlContext context;
-    private final boolean initialized;
-
     /**
      * Constructor for invocation by subclass constructors.
      */
-    @SuppressWarnings("removal")
     protected SettingControl() {
-        context = this instanceof JDKSettingControl ? null : AccessController.getContext();
-        initialized = true;
-    }
-
-    @SuppressWarnings("removal")
-    final AccessControlContext getContext() {
-        // Ensure object state is safe
-        if (!initialized) {
-            throw new InternalError("Object must be initialized before security context can be retrieved");
-        }
-        AccessControlContext c = this.context;
-        if (c == null && !(this instanceof JDKSettingControl)) {
-            throw new InternalError("Security context can only be null for trusted setting controls");
-        }
-        return c;
     }
 
     /**
      * Combines the setting values for all running recordings into one value when
      * multiple recordings are running at the same time,
diff a/src/jdk.jfr/share/classes/jdk/jfr/ValueDescriptor.java b/src/jdk.jfr/share/classes/jdk/jfr/ValueDescriptor.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/ValueDescriptor.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/ValueDescriptor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,11 +29,10 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
 import jdk.jfr.internal.AnnotationConstruct;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.Utils;
 
 /**
  * Describes the event fields and annotation elements.
@@ -141,11 +140,10 @@
 
     ValueDescriptor(Class<?> type, String name, List<AnnotationElement> annotations, boolean allowArray) {
         Objects.requireNonNull(type, "type");
         Objects.requireNonNull(name, "name");
         Objects.requireNonNull(annotations, "annotations");
-        SecuritySupport.checkRegisterPermission();
         if (!allowArray) {
             if (type.isArray()) {
                 throw new IllegalArgumentException("Array types are not allowed");
             }
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/consumer/EventStream.java b/src/jdk.jfr/share/classes/jdk/jfr/consumer/EventStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/consumer/EventStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/consumer/EventStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,22 +25,18 @@
 
 package jdk.jfr.consumer;
 
 import java.io.IOException;
 import java.nio.file.Path;
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.Collections;
 import java.util.Objects;
 import java.util.function.Consumer;
 
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.consumer.EventDirectoryStream;
 import jdk.jfr.internal.consumer.EventFileStream;
-import jdk.jfr.internal.consumer.FileAccess;
 
 /**
  * Represents a stream of events.
  * <p>
  * A stream is a sequence of events and the way to interact with a stream is to
@@ -111,17 +107,13 @@
      * @return an event stream, not {@code null}
      *
      * @throws IOException if a stream can't be opened, or an I/O error occurs
      *         when trying to access the repository
      */
-    @SuppressWarnings("removal")
     public static EventStream openRepository() throws IOException {
-        SecuritySupport.checkAccessFlightRecorder();
         return new EventDirectoryStream(
-            AccessController.getContext(),
             null,
-            SecuritySupport.PRIVILEGED,
             null,
             Collections.emptyList(),
             false
         );
     }
@@ -141,16 +133,12 @@
      * @throws IOException if a stream can't be opened, or an I/O error occurs
      *         when trying to access the repository
      */
     public static EventStream openRepository(Path directory) throws IOException {
         Objects.requireNonNull(directory, "directory");
-        @SuppressWarnings("removal")
-        AccessControlContext acc = AccessController.getContext();
         return new EventDirectoryStream(
-            acc,
             directory,
-            FileAccess.UNPRIVILEGED,
             null,
             Collections.emptyList(),
             true
         );
     }
@@ -167,14 +155,13 @@
      * @return an event stream, not {@code null}
      *
      * @throws IOException if the file can't be opened, or an I/O error occurs
      *         during reading
      */
-    @SuppressWarnings("removal")
     static EventStream openFile(Path file) throws IOException {
         Objects.requireNonNull(file, "file");
-        return new EventFileStream(AccessController.getContext(), file);
+        return new EventFileStream(file);
     }
 
     /**
      * Registers an action to perform when new metadata arrives in the stream.
      *
diff a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingFile.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,11 +41,10 @@
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;
 import jdk.jfr.internal.consumer.ParserFilter;
 import jdk.jfr.internal.consumer.ChunkHeader;
 import jdk.jfr.internal.consumer.ChunkParser;
-import jdk.jfr.internal.consumer.FileAccess;
 import jdk.jfr.internal.consumer.ParserState;
 import jdk.jfr.internal.consumer.RecordingInput;
 import jdk.jfr.internal.consumer.filter.ChunkWriter;
 
 /**
@@ -79,11 +78,11 @@
      * @throws NoSuchFileException if the {@code file} can't be located
      */
     public RecordingFile(Path file) throws IOException {
         Objects.requireNonNull(file, "file");
         this.file = file.toFile();
-        this.input = new RecordingInput(this.file, FileAccess.UNPRIVILEGED);
+        this.input = new RecordingInput(this.file);
         this.chunkWriter = null;
         findNext();
     }
 
     // Only used by RecordingFile::write(Path, Predicate<RecordedEvent>)
@@ -144,11 +143,11 @@
     public List<EventType> readEventTypes() throws IOException {
         ensureOpen();
         MetadataDescriptor previous = null;
         List<EventType> types = new ArrayList<>();
         HashSet<Long> foundIds = new HashSet<>();
-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput ri = new RecordingInput(file)) {
             ChunkHeader ch = new ChunkHeader(ri);
             aggregateEventTypeForChunk(ch, null, types, foundIds);
             while (!ch.isLastChunk()) {
                 ch = ch.nextHeader();
                 previous = aggregateEventTypeForChunk(ch, previous, types, foundIds);
@@ -160,11 +159,11 @@
     List<Type> readTypes() throws IOException  {
         ensureOpen();
         MetadataDescriptor previous = null;
         List<Type> types = new ArrayList<>(200);
         HashSet<Long> foundIds = HashSet.newHashSet(types.size());
-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput ri = new RecordingInput(file)) {
             ChunkHeader ch = new ChunkHeader(ri);
             ch.awaitFinished();
             aggregateTypeForChunk(ch, null, types, foundIds);
             while (!ch.isLastChunk()) {
                 ch = ch.nextHeader();
diff a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordingStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,12 +25,10 @@
 
 package jdk.jfr.consumer;
 
 import java.io.IOException;
 import java.nio.file.Path;
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -43,11 +41,10 @@
 import jdk.jfr.EventType;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.consumer.EventDirectoryStream;
 import jdk.jfr.internal.management.StreamBarrier;
 
 /**
@@ -96,22 +93,17 @@
     public RecordingStream() {
         this(Map.of());
     }
 
     private RecordingStream(Map<String, String> settings) {
-        SecuritySupport.checkAccessFlightRecorder();
-        @SuppressWarnings("removal")
-        AccessControlContext acc = AccessController.getContext();
         this.recording = new Recording();
         this.creationTime = Instant.now();
         this.recording.setName("Recording Stream: " + creationTime);
         try {
             PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
             this.directoryStream = new EventDirectoryStream(
-                acc,
                 null,
-                SecuritySupport.PRIVILEGED,
                 pr,
                 configurations(),
                 false
             );
         } catch (IOException ioe) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/ChunkInputStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/ChunkInputStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/ChunkInputStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/ChunkInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,10 +26,11 @@
 package jdk.jfr.internal;
 
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 
@@ -63,11 +64,11 @@
     private boolean nextStream() throws IOException {
         if (!nextChunk()) {
             return false;
         }
 
-        stream = new BufferedInputStream(SecuritySupport.newFileInputStream(currentChunk.getFile()));
+        stream = new BufferedInputStream(Files.newInputStream(currentChunk.getFile()));
         unstreamedSize -= currentChunk.getSize();
         return true;
     }
 
     private boolean nextChunk() {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/Control.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,42 +23,31 @@
  * questions.
  */
 
 package jdk.jfr.internal;
 
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
 
 import jdk.jfr.SettingControl;
-import jdk.jfr.internal.settings.JDKSettingControl;
 import jdk.jfr.internal.settings.PeriodSetting;
 import jdk.jfr.internal.settings.StackTraceSetting;
 import jdk.jfr.internal.settings.ThresholdSetting;
 
 final class Control {
-    @SuppressWarnings("removal")
-    private final AccessControlContext context;
     private static final int CACHE_SIZE = 5;
     private final Set<?>[] cachedUnions = new HashSet<?>[CACHE_SIZE];
     private final String[] cachedValues = new String[CACHE_SIZE];
     private final SettingControl delegate;
     private String defaultValue;
     private String lastValue;
 
     // called by exposed subclass in external API
     public Control(SettingControl delegate, String defaultValue) {
-        this.context = PrivateAccess.getInstance().getContext(delegate);
         this.delegate = delegate;
         this.defaultValue = defaultValue;
-        if (this.context == null && !(delegate instanceof JDKSettingControl)) {
-            throw new InternalError("Security context can only be null for trusted setting controls");
-        }
     }
 
     boolean isType(Class<? extends SettingControl> clazz) {
         return delegate.getClass() == clazz;
     }
@@ -72,85 +61,33 @@
             defaultValue = getValue();
         }
         apply(defaultValue);
     }
 
-    @SuppressWarnings("removal")
     public String getValue() {
-        if (context == null) {
-            // VM events requires no access control context
-            return delegate.getValue();
-        } else {
-            return AccessController.doPrivileged(new PrivilegedAction<String>() {
-                @Override
-                public String run() {
-                    try {
-                        return delegate.getValue();
-                    } catch (Throwable t) {
-                        // Prevent malicious user to propagate exception callback in the wrong context
-                        Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, "Exception occurred when trying to get value for " + getClass());
-                    }
-                    return defaultValue != null ? defaultValue : ""; // Need to return something
-                }
-            }, context);
-        }
+        return delegate.getValue();
     }
 
     private void apply(String value) {
         if (lastValue != null && Objects.equals(value, lastValue)) {
             return;
         }
         setValue(value);
     }
 
-    @SuppressWarnings("removal")
     public void setValue(String value) {
-        if (context == null) {
-            // VM events requires no access control context
-            try {
-                delegate.setValue(value);
-                lastValue = delegate.getValue();
-            } catch (Throwable t) {
-                Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, "Exception occurred when setting value \"" + value + "\" for " + getClass());
-                lastValue = null;
-            }
-        } else {
-            lastValue = AccessController.doPrivileged(new PrivilegedAction<String>() {
-                @Override
-                public String run() {
-                    try {
-                        delegate.setValue(value);
-                        return delegate.getValue();
-                    } catch (Throwable t) {
-                        // Prevent malicious user to propagate exception callback in the wrong context
-                        Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, "Exception occurred when setting value \"" + value + "\" for " + getClass());
-                    }
-                    return null;
-                }
-            }, context);
+        try {
+            delegate.setValue(value);
+            lastValue = delegate.getValue();
+        } catch (Throwable t) {
+            Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, "Exception occurred when setting value \"" + value + "\". " + t.getMessage());
+            lastValue = null;
         }
     }
 
-
-    @SuppressWarnings("removal")
     public String combine(Set<String> values) {
-        if (context == null) {
-            // VM events requires no access control context
-            return delegate.combine(values);
-        }
-        return AccessController.doPrivileged(new PrivilegedAction<String>() {
-            @Override
-            public String run() {
-                try {
-                    return delegate.combine(Collections.unmodifiableSet(values));
-                } catch (Throwable t) {
-                    // Prevent malicious user to propagate exception callback in the wrong context
-                    Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, "Exception occurred when combining " + values + " for " + getClass());
-                }
-                return null;
-            }
-        }, context);
+        return delegate.combine(values);
     }
 
     private final String findCombine(Set<String> values) {
         if (values.size() == 1) {
             return values.iterator().next();
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -278,11 +278,11 @@
         try {
             cc = settingControlClass.getDeclaredConstructors()[0];
         } catch (Exception e) {
             throw (Error) new InternalError("Could not get constructor for " + settingControlClass.getName()).initCause(e);
         }
-        SecuritySupport.setAccessible(cc);
+        cc.setAccessible(true);
         try {
             return (SettingControl) cc.newInstance();
         } catch (IllegalArgumentException | InvocationTargetException e) {
             throw new InternalError("Could not instantiate setting for class " + settingControlClass.getName());
         }
@@ -371,16 +371,9 @@
 
     public String getSettingsId() {
         return idName;
     }
 
-    /**
-     * A malicious user must never be able to run a callback in the wrong
-     * context. Methods on SettingControl must therefore never be invoked directly
-     * by JFR, instead use jdk.jfr.internal.Control.
-     *
-     * The returned list is only to be used inside EventConfiguration
-     */
     public List<SettingControl> getSettingControls() {
         return settingControls;
     }
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventInstrumentation.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -87,22 +87,21 @@
     private static final ClassDesc ANNOTATION_REGISTERED = classDesc(Registered.class);
     private static final ClassDesc ANNOTATION_REMOVE_FIELDS = classDesc(RemoveFields.class);
     private static final ClassDesc TYPE_EVENT_CONFIGURATION = classDesc(EventConfiguration.class);
     private static final ClassDesc TYPE_ISE = Bytecode.classDesc(IllegalStateException.class);
     private static final ClassDesc TYPE_EVENT_WRITER = classDesc(EventWriter.class);
-    private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of("jdk.jfr.internal.event.EventWriterFactory");
     private static final ClassDesc TYPE_OBJECT = Bytecode.classDesc(Object.class);
     private static final ClassDesc TYPE_SETTING_DEFINITION = Bytecode.classDesc(SettingDefinition.class);
     private static final MethodDesc METHOD_BEGIN = MethodDesc.of("begin", "()V");
     private static final MethodDesc METHOD_COMMIT = MethodDesc.of("commit", "()V");
     private static final MethodDesc METHOD_DURATION = MethodDesc.of("duration", "(J)J");
     private static final MethodDesc METHOD_ENABLED = MethodDesc.of("enabled", "()Z");
     private static final MethodDesc METHOD_END = MethodDesc.of("end", "()V");
     private static final MethodDesc METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = MethodDesc.of("shouldCommit", "(J)Z");
     private static final MethodDesc METHOD_EVENT_CONFIGURATION_GET_SETTING = MethodDesc.of("getSetting", SettingControl.class, int.class);
     private static final MethodDesc METHOD_EVENT_SHOULD_COMMIT = MethodDesc.of("shouldCommit", "()Z");
-    private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of("getEventWriter", "(J)" + TYPE_EVENT_WRITER.descriptorString());
+    private static final MethodDesc METHOD_GET_EVENT_WRITER = MethodDesc.of("getEventWriter", "()" + TYPE_EVENT_WRITER.descriptorString());
     private static final MethodDesc METHOD_IS_ENABLED = MethodDesc.of("isEnabled", "()Z");
     private static final MethodDesc METHOD_RESET = MethodDesc.of("reset", "()V");
     private static final MethodDesc METHOD_SHOULD_COMMIT_LONG = MethodDesc.of("shouldCommit", "(J)Z");
     private static final MethodDesc METHOD_TIME_STAMP = MethodDesc.of("timestamp", "()J");
 
@@ -765,12 +764,11 @@
         }
         return false;
     }
 
     private void getEventWriter(CodeBuilder codeBuilder) {
-        codeBuilder.ldc(EventWriterKey.getKey());
-        invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);
+        invokestatic(codeBuilder, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);
     }
 
     private void getEventConfiguration(CodeBuilder codeBuilder) {
         if (untypedEventConfiguration) {
             codeBuilder.getstatic(getEventClassDesc(), FIELD_EVENT_CONFIGURATION.name(), TYPE_OBJECT);
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriterFactoryRecipe.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriterFactoryRecipe.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriterFactoryRecipe.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.jfr.internal;
-
-import jdk.jfr.internal.event.EventWriter;
-
-// This class is not directly used but renamed to
-// jdk.jfr.internal.event.EventWriterFactory and loaded dynamically
-// when the first event class is bytecode instrumented.
-// See JVMUpcalls and EventWriterKey::ensureEventWriterFactory()
-public final class EventWriterFactoryRecipe {
-    private static final long KEY = EventWriterKey.getKey();
-
-    public static EventWriter getEventWriter(long key) {
-        if (key == KEY) {
-            EventWriter ew = JVM.getEventWriter();
-            return ew != null ? ew : JVM.newEventWriter();
-        }
-        EventWriterKey.block();
-        return null; // Can't reach here.
-    }
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/FilePurger.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/FilePurger.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/FilePurger.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/FilePurger.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,23 +24,23 @@
  */
 
 package jdk.jfr.internal;
 
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.SequencedSet;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
-
 // This class keeps track of files that can't be deleted
 // so they can at a later staged be removed.
 final class FilePurger {
 
-    private static final SequencedSet<SafePath> paths = new LinkedHashSet<>();
+    private static final SequencedSet<Path> paths = new LinkedHashSet<>();
 
-    public static synchronized void add(SafePath p) {
+    public static synchronized void add(Path p) {
         paths.add(p);
         if (paths.size() > 1000) {
             removeOldest();
         }
     }
@@ -48,31 +48,27 @@
     public static synchronized void purge() {
         if (paths.isEmpty()) {
             return;
         }
 
-        for (SafePath p : new ArrayList<>(paths)) {
+        for (Path p : new ArrayList<>(paths)) {
             if (delete(p)) {
                 paths.remove(p);
             }
         }
     }
 
     private static void removeOldest() {
         paths.removeFirst();
     }
 
-    private static boolean delete(SafePath p) {
-        try {
-            if (!SecuritySupport.exists(p)) {
-                return true;
-            }
-        } catch (IOException e) {
-            // ignore
+    private static boolean delete(Path p) {
+        if (!Files.exists(p)) {
+            return true;
         }
         try {
-            SecuritySupport.delete(p);
+            Files.delete(p);
             return true;
         } catch (IOException e) {
             return false;
         }
     }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/JDKEvents.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/JDKEvents.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/JDKEvents.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/JDKEvents.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -89,15 +89,15 @@
     @SuppressWarnings("unchecked")
     public static synchronized void initialize() {
         try {
             if (initializationTriggered == false) {
                 for (Class<?> eventClass : eventClasses) {
-                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);
+                    MetadataRepository.getInstance().register((Class<? extends Event>) eventClass);
                 }
-                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);
-                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);
-                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);
+                PeriodicEvents.addJavaEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);
+                PeriodicEvents.addJavaEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);
+                PeriodicEvents.addJavaEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);
 
                 initializeContainerEvents();
                 JFRTracing.enable();
                 initializationTriggered = true;
             }
@@ -114,21 +114,25 @@
                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, "Container metrics are available");
             }
         }
         // The registration of events and hooks are needed to provide metadata,
         // even when not running in a container
-        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);
-        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);
-        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);
-        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);
-        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);
+        registerEvent(ContainerConfigurationEvent.class);
+        registerEvent(ContainerCPUUsageEvent.class);
+        registerEvent(ContainerCPUThrottlingEvent.class);
+        registerEvent(ContainerMemoryUsageEvent.class);
+        registerEvent(ContainerIOUsageEvent.class);
 
-        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);
-        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);
-        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);
-        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);
-        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);
+        PeriodicEvents.addJavaEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);
+        PeriodicEvents.addJavaEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);
+        PeriodicEvents.addJavaEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);
+        PeriodicEvents.addJavaEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);
+        PeriodicEvents.addJavaEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);
+    }
+
+    private static void registerEvent(Class<? extends jdk.internal.event.Event> eventClass) {
+        MetadataRepository.getInstance().register(eventClass);
     }
 
     private static void emitExceptionStatistics() {
         ThrowableTracer.emitStatistics();
     }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMSupport.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMSupport.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMSupport.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMSupport.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -54,11 +54,11 @@
     private static volatile boolean nativeOK;
 
     private static boolean checkAvailability() {
         // set jfr.unsupported.vm to true to test API on an unsupported VM
         try {
-            if (SecuritySupport.getBooleanProperty("jfr.unsupported.vm")) {
+            if (Boolean.getBoolean("jfr.unsupported.vm")) {
                 return false;
             }
         } catch (NoClassDefFoundError cnfe) {
             // May happen on JDK 8, where jdk.internal.misc.Unsafe can't be found
             return false;
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/JVMUpcalls.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -62,11 +62,10 @@
             if (jdk.internal.event.Event.class.isAssignableFrom(clazz) && !Modifier.isAbstract(clazz.getModifiers())) {
                 if (!JVMSupport.shouldInstrument(Utils.isJDKClass(clazz), clazz.getName())) {
                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, "Skipping instrumentation for " + clazz.getName() + " since container support is missing");
                     return oldBytes;
                 }
-                EventWriterKey.ensureEventWriterFactory();
                 EventConfiguration configuration = JVMSupport.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));
                 if (configuration == null) {
                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, "No event configuration found for " + clazz.getName() + ". Ignoring instrumentation request.");
                     // Probably triggered by some other agent
                     return oldBytes;
@@ -122,11 +121,10 @@
                 if (!mr.isEnabled(ei.getEventName()) && !ei.isEnabled() || !ei.isRegistered()) {
                     Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, "Skipping instrumentation for event type " + eventName + " since event was disabled on class load");
                     return oldBytes;
                 }
             }
-            EventWriterKey.ensureEventWriterFactory();
             Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, "Adding " + (forceInstrumentation ? "forced " : "") + "instrumentation for event type " + eventName + " during initial class load");
             byte[] bytes = ei.buildInstrumented();
             Bytecode.log(ei.getClassName() + "(" + traceId + ")", bytes);
             return bytes;
         } catch (Throwable t) {
@@ -153,8 +151,10 @@
      * @param contextClassLoader the context class loader.
      *
      * @return a new thread
      */
     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
-        return SecuritySupport.createRecorderThread(systemThreadGroup, contextClassLoader);
+        Thread thread = new Thread(systemThreadGroup, "JFR Recorder Thread");
+        thread.setContextClassLoader(contextClassLoader);
+        return thread;
     }
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataLoader.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataLoader.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataLoader.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataLoader.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -189,11 +189,11 @@
         }
     }
 
     public static List<Type> createTypes() throws IOException {
         try (DataInputStream dis = new DataInputStream(
-                SecuritySupport.getResourceAsStream("/jdk/jfr/internal/types/metadata.bin"))) {
+                MetadataLoader.class.getResourceAsStream("/jdk/jfr/internal/types/metadata.bin"))) {
             MetadataLoader ml = new MetadataLoader(dis);
             return ml.buildTypes();
         } catch (Exception e) {
             throw new InternalError(e);
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -121,11 +121,10 @@
         }
         throw new IllegalStateException("Event class " + eventClass.getName() + " is not registered");
     }
 
     public synchronized void unregister(Class<? extends Event> eventClass) {
-        SecuritySupport.checkRegisterPermission();
         EventConfiguration configuration = getConfiguration(eventClass, false);
         if (configuration != null) {
             configuration.getPlatformEventType().setRegistered(false);
         }
         // never registered, ignore call
@@ -133,11 +132,10 @@
     public synchronized EventType register(Class<? extends jdk.internal.event.Event> eventClass) {
         return register(eventClass, Collections.emptyList(), Collections.emptyList());
     }
 
     public synchronized EventType register(Class<? extends jdk.internal.event.Event> eventClass, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) {
-        SecuritySupport.checkRegisterPermission();
         if (JVM.isExcluded(eventClass)) {
             // Event classes are marked as excluded during class load
             // if they override methods in the jdk.jfr.Event class, i.e. commit().
             // An excluded class lacks a configuration field and can't be used by JFR.
             // The Event::commit() is marked as final, so javac won't
@@ -184,11 +182,11 @@
     private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {
         try {
             if (cachedEventConfigurationConstructor == null) {
                 var argClasses = new Class<?>[] { EventType.class, EventControl.class};
                 Constructor<EventConfiguration> c = EventConfiguration.class.getDeclaredConstructor(argClasses);
-                SecuritySupport.setAccessible(c);
+                c.setAccessible(true);
                 cachedEventConfigurationConstructor = c;
             }
             return cachedEventConfigurationConstructor.newInstance(eventType, ec);
         } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
             throw new InternalError(e);
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/Options.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/Options.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/Options.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/Options.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,12 +24,13 @@
  */
 
 package jdk.jfr.internal;
 
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.internal.misc.Unsafe;
 
 import static java.nio.file.LinkOption.*;
 
 /**
@@ -48,11 +49,11 @@
     private static final long DEFAULT_GLOBAL_BUFFER_SIZE = 524288;
     private static final long DEFAULT_MEMORY_SIZE = DEFAULT_GLOBAL_BUFFER_COUNT * DEFAULT_GLOBAL_BUFFER_SIZE;
     private static long DEFAULT_THREAD_BUFFER_SIZE;
     private static final int DEFAULT_STACK_DEPTH = 64;
     private static final long DEFAULT_MAX_CHUNK_SIZE = 12 * 1024 * 1024;
-    private static final SafePath DEFAULT_DUMP_PATH = null;
+    private static final Path DEFAULT_DUMP_PATH = null;
     private static final boolean DEFAULT_PRESERVE_REPOSITORY = false;
 
     private static long memorySize;
     private static long globalBufferSize;
     private static long globalBufferCount;
@@ -113,23 +114,23 @@
     public static synchronized void setGlobalBufferSize(long globalBufsize) {
         JVM.setGlobalBufferSize(globalBufsize);
         globalBufferSize = globalBufsize;
     }
 
-    public static synchronized void setDumpPath(SafePath path) throws IOException {
+    public static synchronized void setDumpPath(Path path) throws IOException {
         if (path != null) {
-            if (SecuritySupport.isWritable(path)) {
-                path = SecuritySupport.toRealPath(path, NOFOLLOW_LINKS);
+            if (Files.isWritable(path)) {
+                path = path.toRealPath(NOFOLLOW_LINKS);
             } else {
                 throw new IOException("Cannot write JFR emergency dump to " + path.toString());
             }
         }
         JVM.setDumpPath(path == null ? null : path.toString());
     }
 
-    public static synchronized SafePath getDumpPath() {
-        return new SafePath(JVM.getDumpPath());
+    public static synchronized Path getDumpPath() {
+        return Path.of(JVM.getDumpPath());
     }
 
     public static synchronized void setStackDepth(Integer stackTraceDepth) {
         JVM.setStackDepth(stackTraceDepth);
         stackDepth = stackTraceDepth;
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,12 +31,11 @@
 import static jdk.jfr.internal.LogLevel.WARN;
 import static jdk.jfr.internal.LogTag.JFR;
 import static jdk.jfr.internal.LogTag.JFR_SYSTEM;
 
 import java.io.IOException;
-import java.security.AccessControlContext;
-import java.security.AccessController;
+import java.nio.file.Path;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -44,29 +43,26 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.Timer;
 import java.util.TimerTask;
-import java.util.concurrent.CopyOnWriteArrayList;
 
 import jdk.jfr.FlightRecorder;
 import jdk.jfr.FlightRecorderListener;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.events.ActiveRecordingEvent;
 import jdk.jfr.events.ActiveSettingEvent;
-import jdk.jfr.internal.SecuritySupport.SafePath;
-import jdk.jfr.internal.SecuritySupport.SecureRecorderListener;
 import jdk.jfr.internal.consumer.EventLog;
 import jdk.jfr.internal.periodic.PeriodicEvents;
 import jdk.jfr.internal.util.Utils;
 
 public final class PlatformRecorder {
 
 
     private final ArrayList<PlatformRecording> recordings = new ArrayList<>();
-    private static final List<SecureRecorderListener> changeListeners = new ArrayList<>();
+    private static final List<FlightRecorderListener> changeListeners = new ArrayList<>();
     private final Repository repository;
     private final Thread shutdownHook;
 
     private Timer timer;
     private long recordingCounter = 0;
@@ -81,29 +77,13 @@
         JVMSupport.createJFR();
         Logger.log(JFR_SYSTEM, INFO, "Created native");
         JDKEvents.initialize();
         Logger.log(JFR_SYSTEM, INFO, "Registered JDK events");
         startDiskMonitor();
-        shutdownHook = SecuritySupport.createThreadWitNoPermissions("JFR Shutdown Hook", new ShutdownHook(this));
-        SecuritySupport.setUncaughtExceptionHandler(shutdownHook, new ShutdownHook.ExceptionHandler());
-        SecuritySupport.registerShutdownHook(shutdownHook);
-    }
-
-
-    private static Timer createTimer() {
-        try {
-            List<Timer> result = new CopyOnWriteArrayList<>();
-            Thread t = SecuritySupport.createThreadWitNoPermissions("Permissionless thread", ()-> {
-                result.add(new Timer("JFR Recording Scheduler", true));
-            });
-            JVM.exclude(t);
-            t.start();
-            t.join();
-            return result.getFirst();
-        } catch (InterruptedException e) {
-            throw new IllegalStateException("Not able to create timer task. " + e.getMessage(), e);
-        }
+        shutdownHook = new ShutdownHook(this);
+        shutdownHook.setUncaughtExceptionHandler(new ShutdownHook.ExceptionHandler());
+        Runtime.getRuntime().addShutdownHook(shutdownHook);
     }
 
     public synchronized PlatformRecording newRecording(Map<String, String> settings) {
         return newRecording(settings, ++recordingCounter);
     }
@@ -136,40 +116,31 @@
     public synchronized List<PlatformRecording> getRecordings() {
         return Collections.unmodifiableList(new ArrayList<PlatformRecording>(recordings));
     }
 
     public static synchronized void addListener(FlightRecorderListener changeListener) {
-        @SuppressWarnings("removal")
-        AccessControlContext context = AccessController.getContext();
-        SecureRecorderListener sl = new SecureRecorderListener(context, changeListener);
         boolean runInitialized;
         synchronized (PlatformRecorder.class) {
             runInitialized = FlightRecorder.isInitialized();
-            changeListeners.add(sl);
+            changeListeners.add(changeListener);
         }
         if (runInitialized) {
-            sl.recorderInitialized(FlightRecorder.getFlightRecorder());
+            changeListener.recorderInitialized(FlightRecorder.getFlightRecorder());
         }
     }
 
     public static synchronized boolean removeListener(FlightRecorderListener changeListener) {
-        for (SecureRecorderListener s : new ArrayList<>(changeListeners)) {
-            if (s.getChangeListener() == changeListener) {
-                changeListeners.remove(s);
-                return true;
-            }
-        }
-        return false;
+        return changeListeners.remove(changeListener);
     }
 
     static synchronized List<FlightRecorderListener> getListeners() {
         return new ArrayList<>(changeListeners);
     }
 
     synchronized Timer getTimer() {
         if (timer == null) {
-            timer = createTimer();
+            timer = new Timer("JFR Recording Scheduler", true);
         }
         return timer;
     }
 
     public static void notifyRecorderInitialized(FlightRecorder recorder) {
@@ -364,11 +335,11 @@
             EventLog.stop();
         }
     }
 
     private Instant dumpMemoryToDestination(PlatformRecording recording)  {
-        WriteableUserPath dest = recording.getDestination();
+        WriteablePath dest = recording.getDestination();
         if (dest != null) {
             Instant t = MetadataRepository.getInstance().setOutput(dest.getRealPathText());
             recording.clearDestination();
             return t;
         }
@@ -439,12 +410,12 @@
 
         return new ArrayList<>();
     }
 
     private void startDiskMonitor() {
-        Thread t = SecuritySupport.createThreadWitNoPermissions("JFR Periodic Tasks", () -> periodicTask());
-        SecuritySupport.setDaemonThread(t, true);
+        Thread t = new Thread(() -> periodicTask(), "JFR Periodic Tasks");
+        t.setDaemon(true);
         t.start();
     }
 
     private void finishChunk(RepositoryChunk chunk, Instant time, PlatformRecording ignoreMe) {
         if (chunk.finish(time)) {
@@ -470,11 +441,11 @@
     private void writeMetaEvents() {
         long timestamp = JVM.counterTime();
         if (ActiveRecordingEvent.enabled()) {
             for (PlatformRecording r : getRecordings()) {
                 if (r.getState() == RecordingState.RUNNING && r.shouldWriteMetadataEvent()) {
-                    WriteableUserPath path = r.getDestination();
+                    WriteablePath path = r.getDestination();
                     Duration age = r.getMaxAge();
                     Duration flush = r.getFlushInterval();
                     Long size = r.getMaxSize();
                     Instant rStart = r.getStartTime();
                     Duration rDuration = r.getDuration();
@@ -517,11 +488,11 @@
                 }
                 long minDelta = PeriodicEvents.doPeriodic();
                 wait = Math.min(minDelta, Options.getWaitInterval());
             } catch (Throwable t) {
                 // Catch everything and log, but don't allow it to end the periodic task
-                Logger.log(JFR_SYSTEM, ERROR, "Error in Periodic task: " + t.getClass().getName());
+                Logger.log(JFR_SYSTEM, WARN, "Error in Periodic task: " + t.getMessage());
             } finally {
                 takeNap(wait);
             }
         }
     }
@@ -658,11 +629,11 @@
         target.setStartTime(startTime);
         target.setStopTime(endTime);
         target.setInternalDuration(startTime.until(endTime));
     }
 
-    public synchronized void migrate(SafePath repo) throws IOException {
+    public synchronized void migrate(Path repo) throws IOException {
         // Must set repository while holding recorder lock so
         // the final chunk in repository gets marked correctly
         Repository.getRepository().setBasePath(repo);
         boolean disk = false;
         for (PlatformRecording s : getRecordings()) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,15 +33,12 @@
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.channels.FileChannel;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -57,11 +54,10 @@
 
 import jdk.jfr.Configuration;
 import jdk.jfr.FlightRecorderListener;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.util.ValueFormatter;
 
 public final class PlatformRecording implements AutoCloseable {
 
@@ -71,16 +67,16 @@
     private Map<String, String> settings = new LinkedHashMap<>();
     private Duration duration;
     private Duration maxAge;
     private long maxSize;
 
-    private WriteableUserPath destination;
+    private WriteablePath destination;
 
     private boolean toDisk = true;
     private String name;
     private boolean dumpOnExit;
-    private SafePath dumpDirectory;
+    private Path dumpDirectory;
     // Timestamp information
     private Instant stopTime;
     private Instant startTime;
 
     // Misc, information
@@ -88,26 +84,17 @@
     private long size;
     private final LinkedList<RepositoryChunk> chunks = new LinkedList<>();
     private volatile Recording recording;
     private TimerTask stopTask;
     private TimerTask startTask;
-    @SuppressWarnings("removal")
-    private final AccessControlContext dumpDirectoryControlContext;
     private boolean shouldWriteActiveRecordingEvent = true;
     private Duration flushInterval = Duration.ofSeconds(1);
     private long finalStartChunkNanos = Long.MIN_VALUE;
     private long startNanos = -1;
 
     @SuppressWarnings("removal")
     PlatformRecording(PlatformRecorder recorder, long id) {
-        // Typically the access control context is taken
-        // when you call dump(Path) or setDestination(Path),
-        // but if no destination is set and the filename is auto-generated,
-        // the control context of the recording is taken when the
-        // Recording object is constructed. This works well for
-        // -XX:StartFlightRecording and JFR.dump
-        this.dumpDirectoryControlContext = AccessController.getContext();
         this.id = id;
         this.recorder = recorder;
         this.name = String.valueOf(id);
     }
 
@@ -173,11 +160,11 @@
             recorder.stop(this);
             String endText = reason == null ? "" : ". Reason \"" + reason + "\".";
             Logger.log(LogTag.JFR, LogLevel.INFO, "Stopped recording \"" + getName() + "\" (" + getId() + ")" + endText);
             newState = getState();
         }
-        WriteableUserPath dest = getDestination();
+        WriteablePath dest = getDestination();
         if (dest == null && dumpDirectory != null) {
             dest = makeDumpPath();
         }
         if (dest != null) {
             try {
@@ -193,34 +180,22 @@
             notifyIfStateChanged(newState, oldState);
         }
         return true;
     }
 
-    @SuppressWarnings("removal")
-    public WriteableUserPath makeDumpPath() {
+    public WriteablePath makeDumpPath() {
         try {
             String name = JVMSupport.makeFilename(getRecording());
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<WriteableUserPath>() {
-                @Override
-                public WriteableUserPath run() throws Exception {
-                    SafePath p = dumpDirectory;
-                    if (p == null) {
-                        p = new SafePath(".");
-                    }
-                    return new WriteableUserPath(p.toPath().resolve(name));
-                }
-            }, dumpDirectoryControlContext);
-        } catch (PrivilegedActionException e) {
-            Throwable t = e.getCause();
-            if (t instanceof SecurityException) {
-                Logger.log(LogTag.JFR, LogLevel.WARN, "Not allowed to create dump path for recording " + recording.getId() + " on exit.");
-            }
-            if (t instanceof IOException) {
-                Logger.log(LogTag.JFR, LogLevel.WARN, "Could not dump " + recording.getId() + " on exit.");
+            Path p = dumpDirectory;
+            if (p == null) {
+                p = Path.of(".");
             }
-            return null;
+            return new WriteablePath(p.resolve(name));
+        } catch (IOException e) {
+            Logger.log(LogTag.JFR, LogLevel.WARN, "Could not dump " + recording.getId() + " on exit. " + e.getMessage());
         }
+        return null;
     }
 
 
     public void scheduleStart(Duration delay) {
         synchronized (recorder) {
@@ -420,26 +395,28 @@
             this.maxSize = maxSize;
             trimToSize();
         }
     }
 
-    public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {
+    public void setDestination(WriteablePath destination) throws IOException {
         synchronized (recorder) {
-            checkSetDestination(userSuppliedPath);
-            this.destination = userSuppliedPath;
+            checkSetDestination(destination);
+            this.destination = destination;
         }
     }
 
-    public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {
+    public void checkSetDestination(WriteablePath writeablePath) throws IOException {
+        // The writeablePath argument is not checked. It's sufficient that an instance has
+        // been created.
         synchronized (recorder) {
             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
                 throw new IllegalStateException("Destination can't be set on a recording that has been stopped/closed");
             }
         }
     }
 
-    public WriteableUserPath getDestination() {
+    public WriteablePath getDestination() {
         synchronized (recorder) {
             return destination;
         }
     }
 
@@ -705,12 +682,11 @@
             @Override
             public void run() {
                 try {
                     stop("End of duration reached");
                 } catch (Throwable t) {
-                    // Prevent malicious user to propagate exception callback in the wrong context
-                    Logger.log(LogTag.JFR, LogLevel.ERROR, "Could not stop recording.");
+                    Logger.log(LogTag.JFR, LogLevel.ERROR, "Could not stop recording. " + t.getMessage());
                 }
             }
         };
     }
 
@@ -735,41 +711,38 @@
     boolean shouldWriteMetadataEvent() {
         return shouldWriteActiveRecordingEvent;
     }
 
     // Dump running and stopped recordings
-    public void dump(WriteableUserPath writeableUserPath) throws IOException {
+    public void dump(WriteablePath writeablePath) throws IOException {
         synchronized (recorder) {
             try(PlatformRecording p = newSnapshotClone("Dumped by user", null))  {
-                p.dumpStopped(writeableUserPath);
+                p.dumpStopped(writeablePath);
             }
         }
     }
 
-    public void dumpStopped(WriteableUserPath userPath) throws IOException {
+    public void dumpStopped(WriteablePath path) throws IOException {
         synchronized (recorder) {
-            transferChunksWithRetry(userPath);
+            transferChunksWithRetry(path);
         }
     }
 
-    private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {
-        userPath.doPrivilegedIO(() -> {
-            try {
-                transferChunks(userPath);
-            } catch (NoSuchFileException nsfe) {
-                Logger.log(LogTag.JFR, LogLevel.ERROR, "Missing chunkfile when writing recording \"" + name + "\" (" + id + ") to " + userPath.getRealPathText() + ".");
-                // if one chunkfile was missing, its likely more are missing
-                removeNonExistantPaths();
-                // and try the transfer again
-                transferChunks(userPath);
-            }
-            return null;
-        });
+    private void transferChunksWithRetry(WriteablePath path) throws IOException {
+        try {
+            transferChunks(path);
+        } catch (NoSuchFileException nsfe) {
+            Logger.log(LogTag.JFR, LogLevel.ERROR, "Missing chunkfile when writing recording \"" + name + "\" (" + id + ") to " + path.getRealPathText() + ".");
+            // if one chunkfile was missing, its likely more are missing
+            removeNonExistantPaths();
+            // and try the transfer again
+            transferChunks(path);
+        }
     }
 
-    private void transferChunks(WriteableUserPath userPath) throws IOException {
-        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
+    private void transferChunks(WriteablePath path) throws IOException {
+        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
             long bytes = cc.transferTo(fc);
             Logger.log(LogTag.JFR, LogLevel.INFO, "Transferred " + bytes + " bytes from the disk repository");
             // No need to force if no data was transferred, which avoids IOException when device is /dev/null
             if (bytes != 0) {
                 fc.force(true);
@@ -857,11 +830,11 @@
     /**
      * Sets the dump directory.
      * <p>
      * Only to be used by DCmdStart.
      */
-    public void setDumpDirectory(SafePath directory) {
+    public void setDumpDirectory(Path directory) {
        this.dumpDirectory = directory;
     }
 
     public void setFlushInterval(Duration interval) {
         synchronized (recorder) {
@@ -911,11 +884,11 @@
             }
         }
 
     }
 
-    public void removePath(SafePath path) {
+    public void removePath(Path path) {
         synchronized (recorder) {
             Iterator<RepositoryChunk> it = chunks.iterator();
             while (it.hasNext()) {
                 RepositoryChunk c = it.next();
                 if (c.getFile().equals(path)) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/PrivateAccess.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/PrivateAccess.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/PrivateAccess.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/PrivateAccess.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,21 +23,19 @@
  * questions.
  */
 
 package jdk.jfr.internal;
 
-import java.security.AccessControlContext;
 import java.util.List;
 import java.util.Map;
 
 import jdk.jfr.AnnotationElement;
 import jdk.jfr.Configuration;
 import jdk.jfr.EventSettings;
 import jdk.jfr.EventType;
 import jdk.jfr.FlightRecorderPermission;
 import jdk.jfr.Recording;
-import jdk.jfr.SettingControl;
 import jdk.jfr.SettingDescriptor;
 import jdk.jfr.ValueDescriptor;
 import jdk.jfr.internal.management.EventSettingsModifier;
 
 /**
@@ -58,11 +56,11 @@
         // deadlock with FlightRecorderPermission.<clinit>
         if (instance == null) {
             // Will trigger
             // FlightRecorderPermission.<clinit>
             // which will call PrivateAccess.setPrivateAccess
-            new FlightRecorderPermission(SecuritySupport.REGISTER_EVENT);
+            new FlightRecorderPermission("accessFlightRecorder");
         }
         return instance;
     }
 
     public static void setPrivateAccess(PrivateAccess pa) {
@@ -97,12 +95,9 @@
 
     public abstract boolean isUnsigned(ValueDescriptor v);
 
     public abstract PlatformRecorder getPlatformRecorder();
 
-    @SuppressWarnings("removal")
-    public abstract AccessControlContext getContext(SettingControl sc);
-
     public abstract EventSettings newEventSettings(EventSettingsModifier esm);
 
     public abstract boolean isVisible(EventType t);
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,41 +24,42 @@
  */
 
 package jdk.jfr.internal;
 
 import java.io.IOException;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.time.DateTimeException;
 import java.time.LocalDateTime;
 import java.time.ZoneOffset;
 import java.util.HashSet;
 import java.util.Set;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.management.ChunkFilename;
 import jdk.jfr.internal.util.ValueFormatter;
+import jdk.jfr.internal.util.DirectoryCleaner;
+import jdk.jfr.internal.util.Utils;
 
 public final class Repository {
 
+    private static final Path JAVA_IO_TMPDIR = Utils.getPathInProperty("java.io.tmpdir", null);
     private static final int MAX_REPO_CREATION_RETRIES = 1000;
     private static final Repository instance = new Repository();
-
     private static final String JFR_REPOSITORY_LOCATION_PROPERTY = "jdk.jfr.repository";
-
-    private final Set<SafePath> cleanupDirectories = new HashSet<>();
-    private SafePath baseLocation;
-    private SafePath repository;
+    private final Set<Path> cleanupDirectories = new HashSet<>();
+    private Path baseLocation;
+    private Path repository;
     private ChunkFilename chunkFilename;
 
     private Repository() {
     }
 
     public static Repository getRepository() {
         return instance;
     }
 
-    public synchronized void setBasePath(SafePath baseLocation) throws IOException {
+    public synchronized void setBasePath(Path baseLocation) throws IOException {
         if(baseLocation.equals(this.baseLocation)) {
             Logger.log(LogTag.JFR, LogLevel.INFO, "Same base repository path " + baseLocation.toString() + " is set");
             return;
         }
         // Probe to see if repository can be created, needed for fail fast
@@ -66,38 +67,38 @@
         this.repository = createRepository(baseLocation);
         this.chunkFilename = null;
         try {
             // Remove so we don't "leak" repositories, if JFR is never started
             // and shutdown hook not added.
-            SecuritySupport.delete(repository);
+            Files.delete(repository);
         } catch (IOException ioe) {
             Logger.log(LogTag.JFR, LogLevel.INFO, "Could not delete disk repository " + repository);
         }
         this.baseLocation = baseLocation;
     }
 
     public synchronized void ensureRepository() throws IOException {
         if (baseLocation == null) {
-            setBasePath(SecuritySupport.JAVA_IO_TMPDIR);
+            setBasePath(JAVA_IO_TMPDIR);
         }
     }
 
     synchronized RepositoryChunk newChunk() {
         LocalDateTime timestamp = timestamp();
         try {
-            if (!SecuritySupport.existDirectory(repository)) {
+            if (!Files.exists(repository)) {
                 this.repository = createRepository(baseLocation);
                 JVM.setRepositoryLocation(repository.toString());
-                SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());
+                System.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());
                 cleanupDirectories.add(repository);
                 chunkFilename = null;
             }
             if (chunkFilename == null) {
-                chunkFilename = ChunkFilename.newPriviliged(repository.toPath());
+                chunkFilename = new ChunkFilename(repository);
             }
             String filename = chunkFilename.next(timestamp);
-            return new RepositoryChunk(new SafePath(filename));
+            return new RepositoryChunk(Path.of(filename));
         } catch (Exception e) {
             String errorMsg = String.format("Could not create chunk in repository %s, %s: %s", repository, e.getClass(), e.getMessage());
             Logger.log(LogTag.JFR, LogLevel.ERROR, errorMsg);
             JVM.abort(errorMsg);
             throw new InternalError("Could not abort after JFR disk creation error");
@@ -111,85 +112,80 @@
             Logger.log(LogTag.JFR, LogLevel.INFO, "Could not create LocalDateTime with the default time zone. Using UTC time zone for chunk filename.");
             return LocalDateTime.now(ZoneOffset.UTC);
         }
     }
 
-    private static SafePath createRepository(SafePath basePath) throws IOException {
-        SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);
-        SafePath f = null;
+    private static Path createRepository(Path basePath) throws IOException {
+        Path canonicalBaseRepositoryPath = createRealBasePath(basePath);
+        Path f = null;
 
         String basename = ValueFormatter.formatDateTime(timestamp()) + "_" + JVM.getPid();
         String name = basename;
 
         int i = 0;
         for (; i < MAX_REPO_CREATION_RETRIES; i++) {
-            f = new SafePath(canonicalBaseRepositoryPath.toPath().resolve(name));
+            f = canonicalBaseRepositoryPath.resolve(name);
             if (tryToUseAsRepository(f)) {
                 break;
             }
             name = basename + "_" + i;
         }
 
         if (i == MAX_REPO_CREATION_RETRIES) {
             throw new IOException("Unable to create JFR repository directory using base location (" + basePath + ")");
         }
-        return SecuritySupport.toRealPath(f);
+        return f.toRealPath();
     }
 
-    private static SafePath createRealBasePath(SafePath safePath) throws IOException {
-        if (SecuritySupport.exists(safePath)) {
-            if (!SecuritySupport.isWritable(safePath)) {
-                throw new IOException("JFR repository directory (" + safePath.toString() + ") exists, but isn't writable");
+    private static Path createRealBasePath(Path path) throws IOException {
+        if (Files.exists(path)) {
+            if (!Files.isWritable(path)) {
+                throw new IOException("JFR repository directory (" + path.toString() + ") exists, but isn't writable");
             }
-            return SecuritySupport.toRealPath(safePath);
+            return path.toRealPath();
         }
-        SafePath p = SecuritySupport.createDirectories(safePath);
-        return SecuritySupport.toRealPath(p);
+        return Files.createDirectories(path).toRealPath();
     }
 
-    private static boolean tryToUseAsRepository(final SafePath path) {
-        Path parent = path.toPath().getParent();
+    private static boolean tryToUseAsRepository(Path path) {
+        Path parent = path.getParent();
         if (parent == null) {
             return false;
         }
         try {
-            try {
-                SecuritySupport.createDirectories(path);
-            } catch (Exception e) {
-                // file already existed or some other problem occurred
-            }
-            if (!SecuritySupport.exists(path)) {
-                return false;
-            }
-            if (!SecuritySupport.isDirectory(path)) {
-                return false;
-            }
-            return true;
-        } catch (IOException io) {
+            Files.createDirectories(path);
+        } catch (Exception e) {
+            // file already existed or some other problem occurred
+        }
+        if (!Files.exists(path)) {
+            return false;
+        }
+        if (!Files.isDirectory(path)) {
             return false;
         }
+        return true;
     }
 
     synchronized void clear() {
         if (Options.getPreserveRepository()) {
             return;
         }
 
-        for (SafePath p : cleanupDirectories) {
+        for (Path p : cleanupDirectories) {
             try {
-                SecuritySupport.clearDirectory(p);
+                DirectoryCleaner.clear(p);
                 Logger.log(LogTag.JFR, LogLevel.INFO, "Removed repository " + p);
             } catch (IOException e) {
                 Logger.log(LogTag.JFR, LogLevel.INFO, "Repository " + p + " could not be removed at shutdown: " + e.getMessage());
             }
         }
     }
 
-    public synchronized SafePath getRepositoryPath() {
+    public synchronized Path getRepositoryPath() {
         return repository;
     }
 
-    public synchronized SafePath getBaseLocation() {
+    public synchronized Path getBaseLocation() {
         return baseLocation;
     }
 
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,42 +25,44 @@
 
 package jdk.jfr.internal;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
 import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
 import java.time.Instant;
 import java.util.Comparator;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
-
 public final class RepositoryChunk {
 
     static final Comparator<RepositoryChunk> END_TIME_COMPARATOR = new Comparator<RepositoryChunk>() {
         @Override
         public int compare(RepositoryChunk c1, RepositoryChunk c2) {
             return c1.endTime.compareTo(c2.endTime);
         }
     };
 
-    private final SafePath chunkFile;
+    private final Path chunkFile;
     private final RandomAccessFile unFinishedRAF;
 
     private Instant endTime = null; // unfinished
     private Instant startTime;
     private int refCount = 1;
     private long size;
 
-    RepositoryChunk(SafePath path) throws Exception {
+    RepositoryChunk(Path path) throws Exception {
         this.chunkFile = path;
-        this.unFinishedRAF = SecuritySupport.createRandomAccessFile(chunkFile);
+        this.unFinishedRAF = new RandomAccessFile(path.toFile(), "rw");
     }
 
     boolean finish(Instant endTime) {
         try {
             unFinishedRAF.close();
-            size = SecuritySupport.getFileSize(chunkFile);
+            size = Files.size(chunkFile);
             this.endTime = endTime;
             if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {
                 Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, "Chunk finished: " + chunkFile);
             }
             return true;
@@ -87,13 +89,13 @@
 
     public Instant getEndTime() {
         return endTime;
     }
 
-    private void delete(SafePath f) {
+    private void delete(Path f) {
         try {
-            SecuritySupport.delete(f);
+            Files.delete(f);
             if (Logger.shouldLog(LogTag.JFR, LogLevel.DEBUG)) {
                 Logger.log(LogTag.JFR, LogLevel.DEBUG, "Repository chunk " + f + " deleted");
             }
         } catch (IOException e) {
             // Probably happens because file is being streamed
@@ -151,11 +153,11 @@
 
     ReadableByteChannel newChannel() throws IOException {
         if (!isFinished()) {
             throw new IOException("Chunk not finished");
         }
-        return ((SecuritySupport.newFileChannelToRead(chunkFile)));
+        return FileChannel.open(chunkFile, StandardOpenOption.READ);
     }
 
     public boolean inInterval(Instant startTime, Instant endTime) {
         if (startTime != null && getEndTime().isBefore(startTime)) {
             return false;
@@ -164,25 +166,21 @@
             return false;
         }
         return true;
     }
 
-    public SafePath getFile() {
+    public Path getFile() {
         return chunkFile;
     }
 
     public long getCurrentFileSize() {
         try {
-            return SecuritySupport.getFileSize(chunkFile);
+            return Files.size(chunkFile);
         } catch (IOException e) {
             return 0L;
         }
     }
 
     boolean isMissingFile() {
-        try {
-            return !SecuritySupport.exists(chunkFile);
-        } catch (IOException ioe) {
-            return true;
-        }
+        return !Files.exists(chunkFile);
     }
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,284 +23,25 @@
  * questions.
  */
 
 package jdk.jfr.internal;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.RandomAccessFile;
-import java.io.Reader;
 import java.lang.invoke.MethodHandles;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.ReflectPermission;
-import java.nio.channels.FileChannel;
-import java.nio.channels.ReadableByteChannel;
-import java.nio.file.DirectoryStream;
-import java.nio.file.FileVisitResult;
-import java.nio.file.Files;
-import java.nio.file.LinkOption;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.nio.file.SimpleFileVisitor;
-import java.nio.file.StandardOpenOption;
-import java.nio.file.attribute.BasicFileAttributes;
-import java.nio.file.attribute.FileTime;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.Permission;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.PropertyPermission;
-import java.util.concurrent.Callable;
-
 import jdk.internal.module.Modules;
 import jdk.jfr.Event;
-import jdk.jfr.FlightRecorder;
-import jdk.jfr.FlightRecorderListener;
-import jdk.jfr.FlightRecorderPermission;
-import jdk.jfr.Recording;
-import jdk.jfr.internal.consumer.FileAccess;
 
-/**
- * Contains JFR code that does
- * {@link AccessController#doPrivileged(PrivilegedAction)}
- */
 public final class SecuritySupport {
-    private static final String EVENTS_PACKAGE_NAME = "jdk.jfr.events";
-    private static final String EVENT_PACKAGE_NAME = "jdk.jfr.internal.event";
-
-    public static final String REGISTER_EVENT = "registerEvent";
-    public static final String ACCESS_FLIGHT_RECORDER = "accessFlightRecorder";
-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
     private static final Module JFR_MODULE = Event.class.getModule();
-    public  static final SafePath JFC_DIRECTORY = getPathInProperty("java.home", "lib/jfr");
-    public static final FileAccess PRIVILEGED = new Privileged();
-    static final SafePath JAVA_IO_TMPDIR = getPathInProperty("java.io.tmpdir", null);
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 
     static {
         // ensure module java.base can read module jdk.jfr as early as possible
         addReadEdge(Object.class);
         addInternalEventExport(Object.class);
         addEventsExport(Object.class);
     }
 
-    static final class SecureRecorderListener implements FlightRecorderListener {
-
-        @SuppressWarnings("removal")
-        private final AccessControlContext context;
-        private final FlightRecorderListener changeListener;
-
-        SecureRecorderListener(@SuppressWarnings("removal") AccessControlContext context, FlightRecorderListener changeListener) {
-            this.context = Objects.requireNonNull(context);
-            this.changeListener = Objects.requireNonNull(changeListener);
-        }
-
-        @SuppressWarnings("removal")
-        @Override
-        public void recordingStateChanged(Recording recording) {
-            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
-                try {
-                    changeListener.recordingStateChanged(recording);
-                } catch (Throwable t) {
-                    // Prevent malicious user to propagate exception callback in the wrong context
-                    Logger.log(LogTag.JFR, LogLevel.WARN, "Unexpected exception in listener " + changeListener.getClass()+ " at recording state change");
-                }
-                return null;
-            }, context);
-        }
-
-        @SuppressWarnings("removal")
-        @Override
-        public void recorderInitialized(FlightRecorder recorder) {
-            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
-                try  {
-                    changeListener.recorderInitialized(recorder);
-                } catch (Throwable t) {
-                    // Prevent malicious user to propagate exception callback in the wrong context
-                    Logger.log(LogTag.JFR, LogLevel.WARN, "Unexpected exception in listener " + changeListener.getClass()+ " when initializing FlightRecorder");
-                }
-                return null;
-            }, context);
-        }
-
-        public FlightRecorderListener getChangeListener() {
-            return changeListener;
-        }
-    }
-
-    private static final class DirectoryCleaner extends SimpleFileVisitor<Path> {
-        @Override
-        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
-            Files.delete(path);
-            return FileVisitResult.CONTINUE;
-        }
-
-        @Override
-        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
-            if (exc != null) {
-                throw exc;
-            }
-            Files.delete(dir);
-            return FileVisitResult.CONTINUE;
-        }
-    }
-
-    /**
-     * Path created by the default file provider, and not
-     * a malicious provider.
-     *
-     */
-    public static final class SafePath implements Comparable<SafePath> {
-        private final Path path;
-        private final String text;
-
-        public SafePath(Path p) {
-            // sanitize
-            text = p.toString();
-            path = Paths.get(text);
-        }
-
-        public SafePath(String path) {
-            this(Paths.get(path));
-        }
-
-        public Path toPath() {
-            return path;
-        }
-
-        public File toFile() {
-            return path.toFile();
-        }
-
-        @Override
-        public String toString() {
-            return text;
-        }
-
-        @Override
-        public int compareTo(SafePath that) {
-            return that.text.compareTo(this.text);
-        }
-
-        @Override
-        public boolean equals(Object other) {
-            if(other != null && other instanceof SafePath s){
-                return this.toPath().equals(s.toPath());
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return this.toPath().hashCode();
-        }
-    }
-
-    private interface RunnableWithCheckedException {
-        public void run() throws Exception;
-    }
-
-    private interface CallableWithoutCheckException<T> {
-        public T call();
-    }
-
-    public static void checkAccessFlightRecorder() throws SecurityException {
-        @SuppressWarnings("removal")
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));
-        }
-    }
-
-    public static void checkRegisterPermission() throws SecurityException {
-        @SuppressWarnings("removal")
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));
-        }
-    }
-
-    @SuppressWarnings("removal")
-    private static <U> U doPrivilegedIOWithReturn(Callable<U> function) throws IOException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<U>() {
-                @Override
-                public U run() throws Exception {
-                    return function.call();
-                }
-            }, null);
-        } catch (PrivilegedActionException e) {
-            Throwable t = e.getCause();
-            if (t instanceof IOException) {
-                throw (IOException) t;
-            }
-            throw new IOException("Unexpected error during I/O operation. " + t.getMessage(), t);
-        }
-    }
-
-    private static void doPriviligedIO(RunnableWithCheckedException function) throws IOException {
-        doPrivilegedIOWithReturn(() -> {
-            function.run();
-            return null;
-        });
-    }
-
-    @SuppressWarnings("removal")
-    private static void doPrivileged(Runnable function, Permission... perms) {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run() {
-                function.run();
-                return null;
-            }
-        }, null, perms);
-    }
-
-    @SuppressWarnings("removal")
-    private static void doPrivileged(Runnable function) {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run() {
-                function.run();
-                return null;
-            }
-        });
-    }
-
-    @SuppressWarnings("removal")
-    private static <T> T doPrivilegedWithReturn(CallableWithoutCheckException<T> function, Permission... perms) {
-        return AccessController.doPrivileged(new PrivilegedAction<T>() {
-            @Override
-            public T run() {
-                return function.call();
-            }
-        }, null, perms);
-    }
-
-    public static List<SafePath> getPredefinedJFCFiles() {
-        List<SafePath> list = new ArrayList<>();
-        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath()))) {
-            for (Path path : ds) {
-                SafePath s = new SafePath(path);
-                String text = s.toString();
-                if (text.endsWith(".jfc") && !SecuritySupport.isDirectory(s)) {
-                    list.add(s);
-                }
-            }
-        } catch (IOException ioe) {
-            Logger.log(LogTag.JFR, LogLevel.WARN, "Could not access .jfc-files in " + JFC_DIRECTORY + ", " + ioe.getMessage());
-        }
-        return list;
-    }
-
     static void makeVisibleToJFR(Class<?> clazz) {
         Module classModule = clazz.getModule();
         Modules.addReads(JFR_MODULE, classModule);
         if (clazz.getPackage() != null) {
             String packageName = clazz.getPackage().getName();
@@ -312,215 +53,33 @@
     /**
      * Adds a qualified export of the internal.jdk.jfr.internal.event package
      * (for EventConfiguration and EventWriter)
      */
     static void addInternalEventExport(Class<?> clazz) {
-        Modules.addExports(JFR_MODULE, EVENT_PACKAGE_NAME, clazz.getModule());
+        Modules.addExports(JFR_MODULE, "jdk.jfr.internal.event", clazz.getModule());
     }
 
     static void addEventsExport(Class<?> clazz) {
-        Modules.addExports(JFR_MODULE, EVENTS_PACKAGE_NAME, clazz.getModule());
+        Modules.addExports(JFR_MODULE, "jdk.jfr.events", clazz.getModule());
     }
 
     static void addReadEdge(Class<?> clazz) {
         Modules.addReads(clazz.getModule(), JFR_MODULE);
     }
 
-    public static void registerEvent(Class<? extends jdk.internal.event.Event> eventClass) {
-        doPrivileged(() ->  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(REGISTER_EVENT));
-    }
-
-    public static void setProperty(String propertyName, String value) {
-        doPrivileged(() -> System.setProperty(propertyName, value), new PropertyPermission(propertyName, "write"));
-    }
-
-    static boolean getBooleanProperty(String propertyName) {
-        return doPrivilegedWithReturn(() -> Boolean.getBoolean(propertyName), new PropertyPermission(propertyName, "read"));
-    }
-
-    private static SafePath getPathInProperty(String prop, String subPath) {
-        return doPrivilegedWithReturn(() -> {
-            String path = System.getProperty(prop);
-            if (path == null) {
-                return null;
-            }
-            File file = subPath == null ? new File(path) : new File(path, subPath);
-            return new SafePath(file.getAbsolutePath());
-        }, new PropertyPermission("*", "read"));
-    }
-
-    // Called by JVM during initialization of JFR
-    static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
-        // The thread should have permission = new Permission[0], and not "modifyThreadGroup" and "modifyThread" on the stack,
-        // but it's hard circumvent if we are going to pass in system thread group in the constructor
-        Thread thread = doPrivilegedWithReturn(() -> new Thread(systemThreadGroup, "JFR Recorder Thread"), new RuntimePermission("modifyThreadGroup"), new RuntimePermission("modifyThread"));
-        doPrivileged(() -> thread.setContextClassLoader(contextClassLoader), new RuntimePermission("setContextClassLoader"), new RuntimePermission("modifyThread"));
-        return thread;
-    }
-
-    static void registerShutdownHook(Thread shutdownHook) {
-        doPrivileged(() -> Runtime.getRuntime().addShutdownHook(shutdownHook), new RuntimePermission("shutdownHooks"));
-    }
-
-    static void setUncaughtExceptionHandler(Thread thread, Thread.UncaughtExceptionHandler eh) {
-        doPrivileged(() -> thread.setUncaughtExceptionHandler(eh), new RuntimePermission("modifyThread"));
-    }
-
-    static void clearDirectory(SafePath safePath) throws IOException {
-        doPriviligedIO(() -> Files.walkFileTree(safePath.toPath(), new DirectoryCleaner()));
-    }
-
-    static SafePath toRealPath(SafePath safePath, LinkOption... options) throws IOException {
-        return new SafePath(doPrivilegedIOWithReturn(() -> safePath.toPath().toRealPath(options)));
-    }
-
-    static boolean existDirectory(SafePath directory) throws IOException {
-        return doPrivilegedIOWithReturn(() -> Files.exists(directory.toPath()));
-    }
-
-    static RandomAccessFile createRandomAccessFile(SafePath path) throws Exception {
-        return doPrivilegedIOWithReturn(() -> new RandomAccessFile(path.toPath().toFile(), "rw"));
-    }
-
-    public static InputStream newFileInputStream(SafePath safePath) throws IOException {
-        return doPrivilegedIOWithReturn(() -> Files.newInputStream(safePath.toPath()));
-    }
-
-    public static long getFileSize(SafePath safePath) throws IOException {
-        return doPrivilegedIOWithReturn(() -> Files.size(safePath.toPath()));
-    }
-
-    static SafePath createDirectories(SafePath safePath) throws IOException {
-        Path p = doPrivilegedIOWithReturn(() -> Files.createDirectories(safePath.toPath()));
-        return new SafePath(p);
-    }
-
-    public static boolean exists(SafePath safePath) throws IOException {
-        // Files.exist(path) is allocation intensive
-        return doPrivilegedIOWithReturn(() -> safePath.toPath().toFile().exists());
-    }
-
-    public static boolean isDirectory(SafePath safePath) throws IOException {
-        return doPrivilegedIOWithReturn(() -> Files.isDirectory(safePath.toPath()));
-    }
-
-    static void delete(SafePath localPath) throws IOException {
-        doPriviligedIO(() -> Files.delete(localPath.toPath()));
-    }
-
-    static boolean isWritable(SafePath safePath) throws IOException {
-        return doPrivilegedIOWithReturn(() -> Files.isWritable(safePath.toPath()));
-    }
-
-    static ReadableByteChannel newFileChannelToRead(SafePath safePath) throws IOException {
-        return doPrivilegedIOWithReturn(() -> FileChannel.open(safePath.toPath(), StandardOpenOption.READ));
-    }
-
-    public static InputStream getResourceAsStream(String name) throws IOException {
-        return doPrivilegedIOWithReturn(() -> SecuritySupport.class.getResourceAsStream(name));
-    }
-
-    public static Reader newFileReader(SafePath safePath) throws FileNotFoundException, IOException {
-        return doPrivilegedIOWithReturn(() -> Files.newBufferedReader(safePath.toPath()));
-    }
-
-    static void setAccessible(Method method) {
-        doPrivileged(() -> method.setAccessible(true), new ReflectPermission("suppressAccessChecks"));
-    }
-
-    static void setAccessible(Constructor<?> constructor) {
-        doPrivileged(() -> constructor.setAccessible(true), new ReflectPermission("suppressAccessChecks"));
-    }
-
-    @SuppressWarnings("removal")
     public static void ensureClassIsInitialized(Class<?> clazz) {
         try {
-            MethodHandles.Lookup lookup;
-            if (System.getSecurityManager() == null) {
-                lookup = MethodHandles.privateLookupIn(clazz, LOOKUP);
-            } else {
-                lookup = AccessController.doPrivileged(new PrivilegedExceptionAction<>() {
-                    @Override
-                    public MethodHandles.Lookup run() throws IllegalAccessException {
-                        return MethodHandles.privateLookupIn(clazz, LOOKUP);
-                    }
-                }, null, new ReflectPermission("suppressAccessChecks"));
-            }
+            MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(clazz, LOOKUP);
             lookup.ensureInitialized(clazz);
         } catch (IllegalAccessException e) {
             throw new InternalError(e);
-        } catch (PrivilegedActionException e) {
-            throw new InternalError(e.getCause());
         }
     }
 
-    @SuppressWarnings("removal")
     static Class<?> defineClass(Class<?> lookupClass, byte[] bytes) {
-        return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {
-            @Override
-            public Class<?> run() {
-                try {
-                    return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
-                } catch (IllegalAccessException e) {
-                    throw new InternalError(e);
-                }
-            }
-        });
-    }
-
-    public static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {
-        return doPrivilegedWithReturn(() -> new Thread(runnable, threadName), new Permission[0]);
-    }
-
-    public static void setDaemonThread(Thread t, boolean daemon) {
-      doPrivileged(()-> t.setDaemon(daemon), new RuntimePermission("modifyThread"));
-    }
-
-    public static SafePath getAbsolutePath(SafePath path) throws IOException {
-        return new SafePath(doPrivilegedIOWithReturn((()-> path.toPath().toAbsolutePath())));
-    }
-
-    private static final class Privileged extends FileAccess {
-        @Override
-        public RandomAccessFile openRAF(File f, String mode) throws IOException {
-            return doPrivilegedIOWithReturn( () -> new RandomAccessFile(f, mode));
-        }
-
-        @Override
-        public  DirectoryStream<Path> newDirectoryStream(Path directory)  throws IOException  {
-            return doPrivilegedIOWithReturn( () -> Files.newDirectoryStream(directory));
-        }
-
-        @Override
-        public  String getAbsolutePath(File f) throws IOException {
-            return doPrivilegedIOWithReturn( () -> f.getAbsolutePath());
-        }
-        @Override
-        public long length(File f) throws IOException {
-            return doPrivilegedIOWithReturn( () -> f.length());
-        }
-
-        @Override
-        public  long fileSize(Path p) throws IOException {
-            return doPrivilegedIOWithReturn( () -> Files.size(p));
-        }
-
-        @Override
-        public boolean exists(Path p) throws IOException {
-            return doPrivilegedIOWithReturn( () -> Files.exists(p));
-        }
-
-        @Override
-        public boolean isDirectory(Path p) {
-            return doPrivilegedWithReturn( () -> Files.isDirectory(p));
-        }
-
-        @Override
-        public FileTime getLastModified(Path p) throws IOException {
-            // Timestamp only needed when examining repository for other JVMs,
-            // in which case an unprivileged mode should be used.
-            throw new InternalError("Should not reach here");
+        try {
+            return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
+        } catch (IllegalAccessException e) {
+            throw new InternalError(e);
         }
     }
-
-
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/ShutdownHook.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/ShutdownHook.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/ShutdownHook.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/ShutdownHook.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,26 +23,22 @@
  * questions.
  */
 
 package jdk.jfr.internal;
 
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-
 import jdk.jfr.RecordingState;
 
 /**
  * Class responsible for dumping recordings on exit
  *
  */
-final class ShutdownHook implements Runnable {
+final class ShutdownHook extends Thread {
     private final PlatformRecorder recorder;
     Object tlabDummyObject;
 
     ShutdownHook(PlatformRecorder recorder) {
+        super("JFR Shutdown Hook");
         this.recorder = recorder;
     }
 
     @Override
     public void run() {
@@ -59,11 +55,11 @@
         recorder.destroy();
     }
 
     private void dump(PlatformRecording recording) {
         try {
-            WriteableUserPath dest = recording.getDestination();
+            WriteablePath dest = recording.getDestination();
             if (dest == null) {
                 dest = recording.makeDumpPath();
                 recording.setDestination(dest);
             }
             if (dest != null) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/TypeLibrary.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -187,11 +187,11 @@
                 String proxyPackage = annotation.getClass().getPackageName();
                 Module jfrModule = TypeLibrary.class.getModule();
                 Modules.addExports(proxyModule, proxyPackage, jfrModule);
             }
         }
-        SecuritySupport.setAccessible(m);
+        m.setAccessible(true);
         try {
             return m.invoke(annotation, new Object[0]);
         } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
             throw (Error) new InternalError("Could not get value for method " + methodName + " in annotation " + annotation.getClass().getName());
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteablePath.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteablePath.java
--- /dev/null
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteablePath.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.jfr.internal;
+
+import java.io.BufferedWriter;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public final class WriteablePath {
+    private final Path path;
+    private final Path real;
+
+    public WriteablePath(Path path) throws IOException {
+        // verify that the path is writeable
+        if (Files.exists(path) && !Files.isWritable(path)) {
+            // throw same type of exception as FileOutputStream
+            // constructor, if file can't be opened.
+            throw new FileNotFoundException("Could not write to file: " + path.toAbsolutePath());
+        }
+        // will throw if non-writeable
+        BufferedWriter fw = Files.newBufferedWriter(path);
+        fw.close();
+        this.path = path;
+        this.real = path.toRealPath();
+    }
+
+    public Path getPath() {
+        return path;
+    }
+
+    public Path getReal() {
+        return real;
+    }
+
+    public String getRealPathText() {
+        return real.toString();
+    }
+}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteableUserPath.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteableUserPath.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/WriteableUserPath.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.jfr.internal;
-
-import java.io.BufferedWriter;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedExceptionAction;
-import java.util.concurrent.Callable;
-
-/**
- * Purpose of this class is to simplify analysis of security risks.
- * <p>
- * Paths in the public API should be wrapped in this class so we
- * at all time know what kind of paths we are dealing with.
- * <p>
- * A user supplied path must never be used in an unsafe context, such as a
- * shutdown hook or any other thread created by JFR.
- * <p>
- * All operation using this path must happen in {@link #doPrivilegedIO(Callable)}
- */
-public final class WriteableUserPath {
-    @SuppressWarnings("removal")
-    private final AccessControlContext controlContext;
-    private final Path original;
-    private final Path real;
-    private final String realPathText;
-    private final String originalText;
-
-    // Not to ensure security, but to help
-    // against programming errors
-    private volatile boolean inPrivileged;
-
-    @SuppressWarnings("removal")
-    public WriteableUserPath(Path path) throws IOException {
-        controlContext = AccessController.getContext();
-        // verify that the path is writeable
-        if (Files.exists(path) && !Files.isWritable(path)) {
-            // throw same type of exception as FileOutputStream
-            // constructor, if file can't be opened.
-            throw new FileNotFoundException("Could not write to file: " + path.toAbsolutePath());
-        }
-        // will throw if non-writeable
-        BufferedWriter fw = Files.newBufferedWriter(path);
-        fw.close();
-        this.original = path;
-        this.originalText = path.toString();
-        this.real = path.toRealPath();
-        this.realPathText = real.toString();
-    }
-
-    /**
-     * Returns a potentially malicious path where the user may have implemented
-     * their own version of Path. This method should never be called in an
-     * unsafe context and the Path value should never be passed along to other
-     * methods.
-     *
-     * @return path from a potentially malicious user
-     */
-    public Path getPotentiallyMaliciousOriginal() {
-        return original;
-    }
-
-    /**
-     * Returns a string representation of the real path.
-     *
-     * @return path as text
-     */
-    public String getRealPathText() {
-        return realPathText;
-    }
-
-    /**
-     * Returns a string representation of the original path.
-     *
-     * @return path as text
-     */
-    public String getOriginalText() {
-        return originalText;
-    }
-
-
-    /**
-     * Returns a potentially malicious path where the user may have implemented
-     * their own version of Path. This method should never be called in an
-     * unsafe context and the Path value should never be passed along to other
-     * methods.
-     *
-     * @return path from a potentially malicious user
-     */
-    public Path getReal() {
-        if (!inPrivileged) {
-            throw new InternalError("A user path was accessed outside the context it was supplied in");
-        }
-        return real;
-    }
-
-    @SuppressWarnings("removal")
-    public void doPrivilegedIO(Callable<?> function) throws IOException {
-        try {
-            inPrivileged = true;
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
-                @Override
-                public Void run() throws Exception {
-                    function.call();
-                    return null;
-                }
-            }, controlContext);
-        } catch (Throwable t) {
-            // prevent malicious user to propagate exception callback
-            // in the wrong context
-            Throwable cause = null;
-            if (System.getSecurityManager() == null) {
-                cause = t;
-            }
-            throw new IOException("Unexpected error during I/O operation", cause);
-        } finally {
-            inPrivileged = false;
-        }
-    }
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/AbstractEventStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,13 +24,10 @@
  */
 
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
@@ -44,33 +41,29 @@
 import jdk.jfr.consumer.MetadataEvent;
 import jdk.jfr.consumer.RecordedEvent;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
-import jdk.jfr.internal.SecuritySupport;
 
 /*
  * Purpose of this class is to simplify the implementation of
  * an event stream.
  */
 public abstract class AbstractEventStream implements EventStream {
     private static final AtomicLong counter = new AtomicLong();
 
     private final CountDownLatch terminated = new CountDownLatch(1);
     private final Runnable flushOperation = () -> dispatcher().runFlushActions();
-    @SuppressWarnings("removal")
-    private final AccessControlContext accessControllerContext;
     private final StreamConfiguration streamConfiguration = new StreamConfiguration();
     private final List<Configuration> configurations;
     private final ParserState parserState = new ParserState();
     private volatile boolean closeOnComplete = true;
     private Dispatcher dispatcher;
     private boolean daemon = false;
 
 
-    AbstractEventStream(@SuppressWarnings("removal") AccessControlContext acc, List<Configuration> configurations) throws IOException {
-        this.accessControllerContext = Objects.requireNonNull(acc);
+    AbstractEventStream(List<Configuration> configurations) throws IOException {
         this.configurations = configurations;
     }
 
     @Override
     public abstract void start();
@@ -219,26 +212,25 @@
         return parserState;
     }
 
     public final void startAsync(long startNanos) {
         startInternal(startNanos);
-        Runnable r = () -> run(accessControllerContext);
-        Thread thread = SecuritySupport.createThreadWitNoPermissions(nextThreadName(), r);
-        SecuritySupport.setDaemonThread(thread, daemon);
+        Runnable r = () -> execute();
+        Thread thread = new Thread(r, nextThreadName());
+        thread.setDaemon(daemon);
         thread.start();
     }
 
     public final void start(long startNanos) {
         startInternal(startNanos);
-        run(accessControllerContext);
+        execute();
     }
 
     protected final Runnable getFlushOperation() {
         return flushOperation;
     }
 
-
     protected final void onFlush() {
        Runnable r = getFlushOperation();
        if (r != null) {
            r.run();
        }
@@ -274,21 +266,10 @@
                 terminated.countDown();
             }
         }
     }
 
-    @SuppressWarnings("removal")
-    private void run(AccessControlContext accessControlContext) {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run() {
-                execute();
-                return null;
-            }
-        }, accessControlContext);
-    }
-
     private String nextThreadName() {
         return "JFR Event Stream " + counter.incrementAndGet();
     }
 
     @Override
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,16 +25,14 @@
 
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.file.Path;
-import java.security.AccessControlContext;
 import java.time.Instant;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Consumer;
 
 import jdk.jfr.Configuration;
 import jdk.jfr.RecordingState;
@@ -42,11 +40,10 @@
 import jdk.jfr.internal.JVM;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.PlatformRecording;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.management.StreamBarrier;
 
 /**
  * Implementation of an {@code EventStream}} that operates against a directory
@@ -56,35 +53,27 @@
 public final class EventDirectoryStream extends AbstractEventStream {
 
     private static final Comparator<? super RecordedEvent> EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 
     private final RepositoryFiles repositoryFiles;
-    private final FileAccess fileAccess;
     private final PlatformRecording recording;
     private final StreamBarrier barrier = new StreamBarrier();
     private final AtomicLong streamId = new AtomicLong();
     private ChunkParser currentParser;
     private long currentChunkStartNanos;
     private RecordedEvent[] sortedCache;
     private int threadExclusionLevel = 0;
     private volatile Consumer<Long> onCompleteHandler;
 
     public EventDirectoryStream(
-            @SuppressWarnings("removal")
-            AccessControlContext acc,
             Path p,
-            FileAccess fileAccess,
             PlatformRecording recording,
             List<Configuration> configurations,
             boolean allowSubDirectories) throws IOException {
-        super(acc, configurations);
+        super(configurations);
         this.recording = recording;
-        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {
-            throw new SecurityException("Priviliged file access not allowed with potentially malicious Path implementation");
-        }
-        this.fileAccess = Objects.requireNonNull(fileAccess);
-        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);
+        this.repositoryFiles = new RepositoryFiles(p, allowSubDirectories);
         this.streamId.incrementAndGet();
         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, "Stream " + streamId + " started.");
     }
 
     @Override
@@ -151,11 +140,11 @@
         if (path == null) { // closed
             logStreamEnd("no first chunk file found.");
             return;
         }
         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
-        try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {
+        try (RecordingInput input = new RecordingInput(path.toFile())) {
             input.setStreamed();
             currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());
             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
             long filterStart = validStartTime ? disp.startNanos : segmentStart;
             long filterEnd = disp.endTime != null ? disp.endNanos : Long.MAX_VALUE;
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventFileStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventFileStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventFileStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventFileStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,11 +25,10 @@
 
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.file.Path;
-import java.security.AccessControlContext;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import jdk.jfr.consumer.RecordedEvent;
 
@@ -43,13 +42,13 @@
     private final RecordingInput input;
 
     private ChunkParser currentParser;
     private RecordedEvent[] cacheSorted;
 
-    public EventFileStream(@SuppressWarnings("removal") AccessControlContext acc, Path file) throws IOException {
-        super(acc, Collections.emptyList());
-        this.input = new RecordingInput(file.toFile(), FileAccess.UNPRIVILEGED);
+    public EventFileStream(Path file) throws IOException {
+        super(Collections.emptyList());
+        this.input = new RecordingInput(file.toFile());
         this.input.setStreamed();
     }
 
     @Override
     public void start() {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/FileAccess.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/FileAccess.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/FileAccess.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2019, 2021, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.jfr.internal.consumer;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.nio.file.DirectoryStream;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.attribute.FileTime;
-
-// Protected by modular boundaries.
-public abstract class FileAccess {
-    public static final FileAccess UNPRIVILEGED = new UnPrivileged();
-
-    public abstract RandomAccessFile openRAF(File f, String mode) throws IOException;
-
-    public abstract DirectoryStream<Path> newDirectoryStream(Path repository) throws IOException;
-
-    public abstract String getAbsolutePath(File f) throws IOException;
-
-    public abstract long length(File f) throws IOException;
-
-    public abstract long fileSize(Path p) throws IOException;
-
-    public abstract boolean exists(Path s) throws IOException;
-
-    public abstract boolean isDirectory(Path p);
-
-    public abstract FileTime getLastModified(Path p) throws IOException;
-
-    private static class UnPrivileged extends FileAccess {
-        @Override
-        public RandomAccessFile openRAF(File f, String mode) throws IOException {
-            return new RandomAccessFile(f, mode);
-        }
-
-        @Override
-        public DirectoryStream<Path> newDirectoryStream(Path dir) throws IOException {
-            return Files.newDirectoryStream(dir);
-        }
-
-        @Override
-        public String getAbsolutePath(File f) throws IOException {
-            return f.getAbsolutePath();
-        }
-
-        @Override
-        public long length(File f) throws IOException {
-            return f.length();
-        }
-
-        @Override
-        public long fileSize(Path p) throws IOException {
-            return Files.size(p);
-        }
-
-        @Override
-        public boolean exists(Path p) {
-            return Files.exists(p);
-        }
-
-        @Override
-        public boolean isDirectory(Path p) {
-            return Files.isDirectory(p);
-        }
-
-        @Override
-        public FileTime getLastModified(Path p) throws IOException {
-            return Files.getLastModifiedTime(p);
-        }
-    }
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/OngoingStream.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/OngoingStream.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/OngoingStream.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/OngoingStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2020, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,16 +24,16 @@
  */
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.file.Files;
 import java.nio.file.Path;
 
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.internal.SecuritySupport;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.management.EventByteStream;
 import jdk.jfr.internal.management.HiddenWait;
 import jdk.jfr.internal.management.ManagementSupport;
 
 public final class OngoingStream extends EventByteStream {
@@ -61,11 +61,11 @@
         super();
         this.recording = recording;
         this.blockSize = blockSize;
         this.startTimeNanos = startTimeNanos;
         this.endTimeNanos = endTimeNanos;
-        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);
+        this.repositoryFiles = new RepositoryFiles(null, false);
     }
 
     @Override
     public synchronized byte[] read() throws IOException {
         try {
@@ -204,14 +204,14 @@
         return EMPTY_ARRAY;
     }
 
     private boolean ensureInput() throws IOException {
         if (input == null) {
-            if (SecuritySupport.getFileSize(new SafePath(path)) < HEADER_SIZE) {
+            if (Files.size(path) < HEADER_SIZE) {
                 return false;
             }
-            input = new RecordingInput(path.toFile(), SecuritySupport.PRIVILEGED);
+            input = new RecordingInput(path.toFile());
             input.setStreamed();
             header = new ChunkHeader(input);
         }
         return true;
     }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,11 +31,10 @@
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.file.Path;
 
 import jdk.jfr.internal.management.HiddenWait;
-import jdk.jfr.internal.util.Utils;
 
 public final class RecordingInput implements DataInput, AutoCloseable {
 
     private static final int DEFAULT_BLOCK_SIZE = 64_000;
 
@@ -66,41 +65,39 @@
             blockPosition = 0;
             blockPositionEnd = 0;
         }
     }
     private final int blockSize;
-    private final FileAccess fileAccess;
     private final HiddenWait threadSleeper = new HiddenWait();
     private long pollCount = 1000;
     private RandomAccessFile file;
     private String filename;
     private Block currentBlock = new Block();
     private Block previousBlock = new Block();
     private long position;
     private long size = -1; // Fail fast if setSize(...) has not been called
                             // before parsing
 
-    RecordingInput(File f, FileAccess fileAccess, int blockSize) throws IOException {
+    RecordingInput(File f, int blockSize) throws IOException {
         this.blockSize = blockSize;
-        this.fileAccess = fileAccess;
         initialize(f);
     }
 
     private void initialize(File f) throws IOException {
-        this.filename = fileAccess.getAbsolutePath(f);
-        this.file = fileAccess.openRAF(f, "r");
+        this.filename = f.getAbsolutePath();
+        this.file = new RandomAccessFile(f, "r");
         this.position = 0;
         this.size = -1;
         this.currentBlock.reset();
         previousBlock.reset();
-        if (fileAccess.length(f) < 8) {
-            throw new IOException("Not a valid Flight Recorder file. File length is only " + fileAccess.length(f) + " bytes.");
+        if (f.length() < 8) {
+            throw new IOException("Not a valid Flight Recorder file. File length is only " + f.length() + " bytes.");
         }
     }
 
-    public RecordingInput(File f, FileAccess fileAccess) throws IOException {
-        this(f, fileAccess, DEFAULT_BLOCK_SIZE);
+    public RecordingInput(File f) throws IOException {
+        this(f, DEFAULT_BLOCK_SIZE);
     }
 
     void positionPhysical(long position) throws IOException {
         file.seek(position);
     }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,10 +26,11 @@
 package jdk.jfr.internal.consumer;
 
 import java.io.IOException;
 import java.nio.file.DirectoryIteratorException;
 import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.attribute.FileTime;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -43,11 +44,10 @@
 
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.management.HiddenWait;;
 
 public final class RepositoryFiles {
     private static final HiddenWait WAIT_OBJECT = new HiddenWait();
     private static final String DIRECTORY_PATTERN = "DDDD_DD_DD_DD_DD_DD_";
@@ -55,21 +55,19 @@
         synchronized (WAIT_OBJECT) {
             WAIT_OBJECT.notifyAll();
         }
     }
 
-    private final FileAccess fileAccess;
     private final NavigableMap<Long, Path> pathSet = new TreeMap<>();
     private final Map<Path, Long> pathLookup = new HashMap<>();
     private final HiddenWait waitObject;
     private boolean allowSubDirectory;
     private volatile boolean closed;
     private Path repository;
 
-    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {
+    public RepositoryFiles(Path repository, boolean allowSubDirectory) {
         this.repository = repository;
-        this.fileAccess = fileAccess;
         this.waitObject = repository == null ? WAIT_OBJECT : new HiddenWait();
         this.allowSubDirectory = allowSubDirectory;
     }
 
     long getTimestamp(Path p) {
@@ -170,18 +168,18 @@
         }
 
         if (repoPath == null) {
             // Always get the latest repository if 'jcmd JFR.configure
             // repositorypath=...' has been executed
-            SafePath sf = Repository.getRepository().getRepositoryPath();
-            if (sf == null) {
+            Path path = Repository.getRepository().getRepositoryPath();
+            if (path == null) {
                 return false; // not initialized
             }
-            repoPath = sf.toPath();
+            repoPath = path;
         }
 
-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {
+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {
             List<Path> added = new ArrayList<>();
             Set<Path> current = new HashSet<>();
             for (Path p : dirStream) {
                 if (!pathLookup.containsKey(p)) {
                     String s = p.toString();
@@ -206,11 +204,11 @@
             }
             Collections.sort(added);
             for (Path p : added) {
                 // Only add files that have a complete header
                 // as the JVM may be in progress writing the file
-                long size = fileAccess.fileSize(p);
+                long size = Files.size(p);
                 if (size >= ChunkHeader.headerSize()) {
                     long startNanos = readStartTime(p);
                     if (startNanos != -1) {
                         pathSet.put(startNanos, p);
                         pathLookup.put(p, startNanos);
@@ -230,14 +228,14 @@
     }
 
     private Path findSubDirectory(Path repoPath) {
         FileTime latestTimestamp = null;
         Path latestPath = null;
-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {
+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {
             for (Path p : dirStream) {
                 String filename = p.getFileName().toString();
-                if (isRepository(filename) && fileAccess.isDirectory(p)) {
+                if (isRepository(filename) && Files.isDirectory(p)) {
                     FileTime timestamp = getLastModified(p);
                     if (timestamp != null) {
                         if (latestPath == null || latestTimestamp.compareTo(timestamp) <= 0) {
                             latestPath = p;
                             latestTimestamp = timestamp;
@@ -251,11 +249,11 @@
         return latestPath;
     }
 
     private FileTime getLastModified(Path p) {
         try {
-            return fileAccess.getLastModified(p);
+            return Files.getLastModifiedTime(p);
         } catch (IOException e) {
             return null;
         }
     }
 
@@ -275,11 +273,11 @@
         }
         return true;
     }
 
     private long readStartTime(Path p) {
-        try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {
+        try (RecordingInput in = new RecordingInput(p.toFile(), 100)) {
             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, "Parsing header for chunk start time");
             ChunkHeader c = new ChunkHeader(in);
             return c.getStartNanos();
         } catch (IOException ioe) {
             return -1;
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/filter/ChunkWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,11 +36,10 @@
 
 import jdk.jfr.consumer.RecordedEvent;
 import jdk.jfr.internal.LongMap;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.consumer.ChunkHeader;
-import jdk.jfr.internal.consumer.FileAccess;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.consumer.RecordingInput;
 import jdk.jfr.internal.consumer.Reference;
@@ -65,11 +64,11 @@
     private long lastCheckpoint;
 
     public ChunkWriter(Path source, Path destination, Predicate<RecordedEvent> filter) throws IOException {
         this.destination = destination;
         this.output = new RecordingOutput(destination.toFile());
-        this.input = new RecordingInput(source.toFile(), FileAccess.UNPRIVILEGED);
+        this.input = new RecordingInput(source.toFile());
         this.filter = filter;
     }
 
     Constants getPool(Type type) {
         long typeId = type.getId();
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/AbstractDCmd.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,12 +41,10 @@
 import jdk.jfr.internal.util.Output;
 import jdk.jfr.internal.JVMSupport;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
-import jdk.jfr.internal.SecuritySupport;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.ValueFormatter;
 
 /**
  * Base class for JFR diagnostic commands
  *
@@ -132,23 +130,23 @@
         // The pid will not be exposed to running Java application, only when starting
         // JFR from command line (-XX:StartFlightRecording) or jcmd (JFR.start and JFR.check)
         return JVM.getPid();
     }
 
-    protected final SafePath resolvePath(Recording recording, String filename) throws InvalidPathException {
+    protected Path resolvePath(Recording recording, String filename) throws InvalidPathException {
         if (filename == null) {
             return makeGenerated(recording, Paths.get("."));
         }
         Path path = Paths.get(filename);
         if (Files.isDirectory(path)) {
             return makeGenerated(recording, path);
         }
-        return new SafePath(path.toAbsolutePath().normalize());
+        return path.toAbsolutePath().normalize();
     }
 
-    private SafePath makeGenerated(Recording recording, Path directory) {
-        return new SafePath(directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize());
+    private Path makeGenerated(Recording recording, Path directory) {
+        return directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize();
     }
 
     protected final Recording findRecording(String name) throws DCmdException {
         try {
             return findRecordingById(Integer.parseInt(name));
@@ -156,21 +154,21 @@
             // User specified a name, not an id.
             return findRecordingByName(name);
         }
     }
 
-    protected final void reportOperationComplete(String actionPrefix, String name, SafePath file) {
+    protected final void reportOperationComplete(String actionPrefix, String name, Path file) {
         print(actionPrefix);
         print(" recording");
         if (name != null) {
             print(" \"" + name + "\"");
         }
         if (file != null) {
             print(",");
             try {
                 print(" ");
-                long bytes = SecuritySupport.getFileSize(file);
+                long bytes = Files.size(file);
                 printBytes(bytes);
             } catch (IOException e) {
                 // Ignore, not essential
             }
             println(" written to:");
@@ -217,37 +215,24 @@
 
     protected final void printTimespan(Duration timespan, String separator) {
         print(ValueFormatter.formatTimespan(timespan, separator));
     }
 
-    protected final void printPath(SafePath path) {
+    protected final void printPath(Path path) {
         if (path == null) {
             print("N/A");
             return;
         }
-        try {
-            printPath(SecuritySupport.getAbsolutePath(path).toPath());
-        } catch (IOException ioe) {
-            printPath(path.toPath());
-        }
+        println(path.toAbsolutePath().toString());
     }
 
     protected final void printHelpText() {
         for (String line : getHelp()) {
             println(line);
         }
     }
 
-    protected final void printPath(Path path) {
-        try {
-            println(path.toAbsolutePath().toString());
-        } catch (SecurityException e) {
-            // fall back on filename
-            println(path.toString());
-        }
-    }
-
     private Recording findRecordingById(int id) throws DCmdException {
         for (Recording r : getFlightRecorder().getRecordings()) {
             if (r.getId() == id) {
                 return r;
             }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdConfigure.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdConfigure.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdConfigure.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdConfigure.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,19 +24,19 @@
  */
 
 package jdk.jfr.internal.dcmd;
 
 import java.io.IOException;
+import java.nio.file.Path;
 
 import jdk.jfr.FlightRecorder;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.Options;
 import jdk.jfr.internal.PrivateAccess;
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 
 /**
  * JFR.configure - invoked from native
  *
  */
@@ -87,11 +87,11 @@
 
 
         boolean updated = false;
         if (repositoryPath != null) {
             try {
-                SafePath s = new SafePath(repositoryPath);
+                Path s = Path.of(repositoryPath);
                 if (FlightRecorder.isInitialized()) {
                     PrivateAccess.getInstance().getPlatformRecorder().migrate(s);
                 } else {
                     Repository.getRepository().setBasePath(s);
                 }
@@ -113,11 +113,11 @@
             updated = true;
         }
 
         if (dumpPath != null)  {
             try {
-                Options.setDumpPath(new SafePath(dumpPath));
+                Options.setDumpPath(Path.of(dumpPath));
             } catch (IOException e) {
                 throw new DCmdException("Could not set " + dumpPath + " to emergency dump path. " + e.getMessage(), e);
             }
             Logger.log(LogTag.JFR, LogLevel.INFO, "Emergency dump path set to " + dumpPath);
            if (verbose) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdDump.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdDump.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdDump.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdDump.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -38,13 +38,12 @@
 import jdk.jfr.FlightRecorder;
 import jdk.jfr.Recording;
 import jdk.jfr.internal.PlatformRecorder;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.ValueParser;
-import jdk.jfr.internal.WriteableUserPath;
+import jdk.jfr.internal.WriteablePath;
 
 /**
  * JFR.dump
  *
  */
@@ -124,21 +123,20 @@
                 throw new DCmdException("Dump failed. No data found in the specified interval.");
             }
             // If a filename exist, use it
             // if a filename doesn't exist, use destination set earlier
             // if destination doesn't exist, generate a filename
-            WriteableUserPath wup = null;
+            WriteablePath wp = null;
             if (recording != null) {
                 PlatformRecording pRecording = PrivateAccess.getInstance().getPlatformRecording(recording);
-                wup = pRecording.getDestination();
+                wp = pRecording.getDestination();
             }
-            if (filename != null || (filename == null && wup == null) ) {
-                SafePath safe = resolvePath(recording, filename);
-                wup = new WriteableUserPath(safe.toPath());
+            if (filename != null || (filename == null && wp == null) ) {
+                wp = new WriteablePath(resolvePath(recording, filename));
             }
-            r.dumpStopped(wup);
-            reportOperationComplete("Dumped", name, new SafePath(wup.getRealPathText()));
+            r.dumpStopped(wp);
+            reportOperationComplete("Dumped", name, wp.getReal());
         }
     }
 
     private Instant parseTime(String time, String parameter) throws DCmdException {
         if (time == null) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,12 +27,10 @@
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.text.ParseException;
 import java.time.Duration;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -46,12 +44,10 @@
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.OldObjectSample;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport.SafePath;
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.jfc.JFC;
 import jdk.jfr.internal.jfc.model.JFCModel;
 import jdk.jfr.internal.jfc.model.JFCModelException;
 import jdk.jfr.internal.jfc.model.XmlInput;
@@ -152,11 +148,11 @@
             }
             recording.setToDisk(disk.booleanValue());
         }
 
         recording.setSettings(s);
-        SafePath safePath = null;
+        Path dumpPath = null;
 
         // Generate dump filename if user has specified a time-bound recording
         if (duration != null && path == null) {
             path = resolvePath(recording, null).toString();
         }
@@ -171,14 +167,14 @@
                 if (Files.isDirectory(p)) {
                     // Decide destination filename at dump time
                     // Purposely avoid generating filename in Recording#setDestination due to
                     // security concerns
                     PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-                    pr.setDumpDirectory(new SafePath(p));
+                    pr.setDumpDirectory(p);
                 } else {
-                    safePath = resolvePath(recording, path);
-                    recording.setDestination(safePath.toPath());
+                    dumpPath = resolvePath(recording, path);
+                    recording.setDestination(dumpPath);
                 }
             } catch (IOException | InvalidPathException e) {
                 recording.close();
                 throw new DCmdException("Could not start recording, not able to write to file %s. %s ", path, e.getMessage());
             }
@@ -219,14 +215,14 @@
         if (recording.isToDisk() && duration == null && maxAge == null && maxSize == null) {
             print(" No limit specified, using maxsize=250MB as default.");
             recording.setMaxSize(250*1024L*1024L);
         }
 
-        if (safePath != null && duration != null) {
+        if (dumpPath != null && duration != null) {
             println(" The result will be written to:");
             println();
-            printPath(safePath);
+            printPath(dumpPath);
         } else {
             println();
             println();
             String cmd = duration == null ? "dump" : "stop";
             String fileOption = path == null ? "filename=FILEPATH " : "";
@@ -254,11 +250,11 @@
 
     private LinkedHashMap<String, String> configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {
         JFCModel model = new JFCModel(l -> logWarning(l));
         for (String setting : settings) {
             try {
-                model.parse(JFC.createSafePath(setting));
+                model.parse(JFC.ofPath(setting));
             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
                 throw new DCmdException(JFC.formatException("Could not", e, setting), e);
             }
         }
         try {
@@ -461,12 +457,12 @@
     }
 
     private static String jfcOptions() {
         try {
             StringBuilder sb = new StringBuilder();
-            for (SafePath s : SecuritySupport.getPredefinedJFCFiles()) {
-                String name = JFC.nameFromPath(s.toPath());
+            for (Path s : JFC.getPredefined()) {
+                String name = JFC.nameFromPath(s);
                 JFCModel model = JFCModel.create(s, l -> {});
                 sb.append('\n');
                 sb.append("Options for ").append(name).append(":\n");
                 sb.append('\n');
                 for (XmlInput input : model.getInputs()) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStop.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStop.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStop.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStop.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,16 +24,16 @@
  */
 package jdk.jfr.internal.dcmd;
 
 import java.io.IOException;
 import java.nio.file.InvalidPathException;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 
 import jdk.jfr.Recording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport.SafePath;
-import jdk.jfr.internal.WriteableUserPath;
+import jdk.jfr.internal.WriteablePath;
 
 /**
  * JFR.stop
  *
  */
@@ -45,24 +45,24 @@
         parser.checkUnknownArguments();
         String name = parser.getOption("name");
         String filename = parser.getOption("filename");
         try {
             Recording recording = findRecording(name);
-            WriteableUserPath path = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();
-            SafePath safePath = path == null ? null : new SafePath(path.getRealPathText());
+            WriteablePath wp = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();
+            Path path = wp == null ? null : wp.getReal();
             if (filename != null) {
                 try {
-                    // Ensure path is valid. Don't generate safePath if filename == null, as a user may
+                    // Ensure path is valid. Don't generate path if filename == null, as a user may
                     // want to stop recording without a dump
-                    safePath = resolvePath(null, filename);
+                    path = resolvePath(null, filename);
                     recording.setDestination(Paths.get(filename));
                 } catch (IOException | InvalidPathException  e) {
                     throw new DCmdException("Failed to stop %s. Could not set destination for \"%s\" to file %s", recording.getName(), filename, e.getMessage());
                 }
             }
             recording.stop();
-            reportOperationComplete("Stopped", recording.getName(), safePath);
+            reportOperationComplete("Stopped", recording.getName(), path);
             recording.close();
         } catch (InvalidPathException | DCmdException e) {
             if (filename != null) {
                 throw new DCmdException("Could not write recording \"%s\" to file. %s", name, e.getMessage());
             }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/event/EventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,35 +25,21 @@
 
 package jdk.jfr.internal.event;
 
 import jdk.internal.misc.Unsafe;
 import jdk.jfr.internal.Bits;
-import jdk.jfr.internal.EventWriterKey;
 import jdk.jfr.internal.StringPool;
 import jdk.jfr.internal.JVM;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.consumer.StringParser;
 
 // User code should not be able to get access to an EventWriter instance as it
 // would allow it to write arbitrary data into buffers, potentially from
 // different threads.
 //
-// This is prevented in three ways:
-//
-// 1. For code to access the jdk.jfr.internal.event package
-//    at least one event class (for a particular module) must be
-//    registered having FlightRecorderPermission("registerEvent").
-//
-// 2. The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from
-//    the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.
-//    (The EventWriterFactory class is dynamically generated before the first event
-//    is instrumented. See EventWriterFactoryRecipe)
-//
-// 3. Steps 1 and 2 are sufficient to make it fully secure, with or without a Security
-//    Manager, but as an additional measure, the method EventWriterFactory::getEventWriter(long)
-//    requires the caller to provide a key that is hard to guess. The key is generated
-//    into the bytecode of the method invoking getEventWriter(long).
+// The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from
+// the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.
 //
 public final class EventWriter {
 
     // Event may not exceed size for a padded integer
     private static final long MAX_EVENT_SIZE = (1 << 28) -1;
@@ -69,10 +55,18 @@
     boolean excluded;
 
     private PlatformEventType eventType;
     private boolean largeSize = false;
 
+    public static EventWriter getEventWriter() {
+        EventWriter ew = JVM.getEventWriter();
+        if (ew != null) {
+            return ew;
+        }
+        return JVM.newEventWriter();
+    }
+
     // User code must not be able to instantiate
     private EventWriter() {
         threadID = 0;
     }
 
@@ -237,15 +231,13 @@
     private void flush(int usedSize, int requestedSize) {
         JVM.flush(this, usedSize, requestedSize);
     }
 
     public boolean beginEvent(EventConfiguration configuration, long typeId) {
-        // Malicious code could take the EventConfiguration object from one
-        // event class field and assign it to another. This check makes sure
-        // the event type matches what was added by instrumentation.
+        // This check makes sure the event type matches what was added by instrumentation.
         if (configuration.getId() != typeId) {
-            EventWriterKey.block();
+            throw new InternalError("Unexpected type id " + typeId);
         }
         if (excluded) {
             // thread is excluded from writing events
             return false;
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/JFC.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,38 +44,53 @@
 import jdk.jfr.Configuration;
 import jdk.jfr.internal.jfc.model.JFCModelException;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
-import jdk.jfr.internal.SecuritySupport;
-import jdk.jfr.internal.SecuritySupport.SafePath;
+import jdk.jfr.internal.util.Utils;
 
 /**
  * {@link Configuration} factory for JFC files. *
  */
 public final class JFC {
+    private static final Path JFC_DIRECTORY = Utils.getPathInProperty("java.home", "lib/jfr");
     private static final int BUFFER_SIZE = 8192;
     private static final int MAXIMUM_FILE_SIZE = 1024 * 1024;
     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
     private static volatile List<KnownConfiguration> knownConfigurations;
 
+    public static List<Path> getPredefined() {
+        List<Path> list = new ArrayList<>();
+        try (var ds = Files.newDirectoryStream(JFC_DIRECTORY)) {
+            for (Path path : ds) {
+                String text = path.toString();
+                if (text.endsWith(".jfc") && !Files.isDirectory(path)) {
+                    list.add(path);
+                }
+            }
+        } catch (IOException ioe) {
+            Logger.log(LogTag.JFR, LogLevel.WARN, "Could not access .jfc-files in " + JFC_DIRECTORY + ", " + ioe.getMessage());
+        }
+        return list;
+    }
+
     /**
      * Reads a known configuration file (located into a string, but doesn't
      * parse it until it's being used.
      */
     private static final class KnownConfiguration {
         private final String content;
         private final String filename;
         private final String name;
-        private final SafePath path;
+        private final Path path;
         private Configuration configuration;
 
-        public KnownConfiguration(SafePath knownPath) throws IOException {
+        public KnownConfiguration(Path knownPath) throws IOException {
             this.path = knownPath;
             this.content = readContent(knownPath);
-            this.name = nameFromPath(knownPath.toPath());
-            this.filename = nullSafeFileName(knownPath.toPath());
+            this.name = nameFromPath(knownPath);
+            this.filename = nullSafeFileName(knownPath);
         }
 
         public boolean isNamed(String name) {
             return filename.equals(name) || this.name.equals(name);
         }
@@ -89,16 +104,16 @@
 
         public String getName() {
             return name;
         }
 
-        private static String readContent(SafePath knownPath) throws IOException {
-            if (SecuritySupport.getFileSize(knownPath) > MAXIMUM_FILE_SIZE) {
+        private static String readContent(Path knownPath) throws IOException {
+            if (Files.size(knownPath) > MAXIMUM_FILE_SIZE) {
                 throw new IOException("Configuration with more than "
                         + MAXIMUM_FILE_SIZE + " characters can't be read.");
             }
-            try (InputStream r = SecuritySupport.newFileInputStream(knownPath)) {
+            try (InputStream r = Files.newInputStream(knownPath);) {
                 return JFC.readContent(r);
             }
         }
     }
 
@@ -112,14 +127,11 @@
      * @param path the file containing the configuration, not {@code null}
      * @return {@link Configuration}, not {@code null}
      * @throws ParseException if the file can't be parsed
      * @throws IOException if the file can't be read
      *
-     * @throws SecurityException if a security manager exists and its
-     *         {@code checkRead} method denies read access to the file
      * @see java.io.File#getPath()
-     * @see java.lang.SecurityManager#checkRead(java.lang.String)
      */
     public static Configuration create(String name, Reader reader) throws IOException, ParseException {
         try {
             return JFCParser.createConfiguration(name, reader);
         } catch (ParseException pe) {
@@ -134,24 +146,24 @@
      * i.e. "default" or "profile.jfc", it will return the path for
      * the predefined path in the JDK.
      *
      * @param path textual representation of the path
      *
-     * @return a safe path, not null
+     * @return a path, not null
      */
-    public static SafePath createSafePath(String path) {
-        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {
+    public static Path ofPath(String path) {
+        for (Path predefined : JFC.getPredefined()) {
             try {
-                String name = JFC.nameFromPath(predefined.toPath());
+                String name = JFC.nameFromPath(predefined);
                 if (name.equals(path) || (name + ".jfc").equals(path)) {
                     return predefined;
                 }
             } catch (IOException e) {
                 throw new InternalError("Error in predefined .jfc file", e);
             }
         }
-        return new SafePath(path);
+        return Path.of(path);
     }
 
 
     private static String nullSafeFileName(Path file) throws IOException {
         Path filename = file.getFileName();
@@ -170,24 +182,23 @@
         }
     }
 
     // Invoked by DCmdStart
     public static Configuration createKnown(String name) throws IOException, ParseException {
-        // Known name, no need for permission
         for (KnownConfiguration known : getKnownConfigurations()) {
             if (known.isNamed(name)) {
                 return known.getConfigurationFile();
             }
         }
         // Check JFC directory
-        SafePath path = SecuritySupport.JFC_DIRECTORY;
-        if (path != null && SecuritySupport.exists(path)) {
+        Path path = JFC_DIRECTORY;
+        if (path != null && Files.exists(path)) {
             for (String extension : Arrays.asList("", JFCParser.FILE_EXTENSION)) {
-                SafePath file = new SafePath(path.toPath().resolveSibling(name + extension));
-                if (SecuritySupport.exists(file) && !SecuritySupport.isDirectory(file)) {
-                    try (Reader r = SecuritySupport.newFileReader(file)) {
-                        String jfcName = nameFromPath(file.toPath());
+                Path file = path.resolveSibling(name + extension);
+                if (Files.exists(file) && !Files.isDirectory(file)) {
+                    try (Reader r = Files.newBufferedReader(file);) {
+                        String jfcName = nameFromPath(file);
                         return JFCParser.createConfiguration(jfcName, r);
                     }
                 }
             }
         }
@@ -258,11 +269,11 @@
     }
 
     private static List<KnownConfiguration> getKnownConfigurations() {
         if (knownConfigurations == null) {
             List<KnownConfiguration> configProxies = new ArrayList<>();
-            for (SafePath p : SecuritySupport.getPredefinedJFCFiles()) {
+            for (Path p : JFC.getPredefined()) {
                 try {
                     configProxies.add(new KnownConfiguration(p));
                 } catch (IOException ioe) {
                     // ignore
                 }
@@ -279,11 +290,11 @@
             }
         }
         throw new NoSuchFileException("Could not locate configuration with name " + name);
     }
 
-    public static Reader newReader(SafePath sf) throws IOException {
+    public static Reader newReader(Path sf) throws IOException {
         for (KnownConfiguration c : getKnownConfigurations()) {
             if (c.path.equals(sf)) {
                 return new StringReader(c.content);
             }
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/model/JFCModel.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/model/JFCModel.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/model/JFCModel.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/jfc/model/JFCModel.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,19 +25,19 @@
 package jdk.jfr.internal.jfc.model;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.Reader;
+import java.nio.file.Path;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Consumer;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.jfc.JFC;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
 // Holds the structure of a .jfc file similar to an XML DOM.
@@ -63,11 +63,11 @@
         this.configuration = new XmlConfiguration();
         this.configuration.setAttribute("version", "2.0");
         this.logger = logger;
     }
 
-    public void parse(SafePath file) throws IOException, JFCModelException, ParseException {
+    public void parse(Path file) throws IOException, JFCModelException, ParseException {
         JFCModel model = JFCModel.create(file, logger);
         for (var entry : model.controls.entrySet()) {
             String name = entry.getKey();
             // Fail-fast checks that prevents an ambiguous file to be written later
             if (controls.containsKey(name)) {
@@ -78,11 +78,11 @@
         for (XmlElement child : model.configuration.getChildren()) {
             this.configuration.addChild(child);
         }
     }
 
-    public static JFCModel create(SafePath file, Consumer<String> logger) throws IOException, JFCModelException, ParseException{
+    public static JFCModel create(Path file, Consumer<String> logger) throws IOException, JFCModelException, ParseException{
         if (file.toString().equals("none")) {
             XmlConfiguration configuration = new XmlConfiguration();
             configuration.setAttribute("version", "2.0");
             configuration.setAttribute("label", "None");
             return new JFCModel(configuration);
@@ -152,11 +152,11 @@
             }
         }
         return result;
     }
 
-    public void saveToFile(SafePath path) throws IOException {
+    public void saveToFile(Path path) throws IOException {
         try (PrintWriter p = new PrintWriter(path.toFile(), UTF_8)) {
             PrettyPrinter pp = new PrettyPrinter(p);
             pp.print(configuration);
             if (p.checkError()) {
                 throw new IOException("Error writing " + path);
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ChunkFilename.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ChunkFilename.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ChunkFilename.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ChunkFilename.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,51 +23,39 @@
  * questions.
  */
 package jdk.jfr.internal.management;
 
 import java.nio.file.Paths;
+import java.nio.file.Files;
 import java.nio.file.Path;
 import java.time.LocalDateTime;
 import java.io.IOException;
 
-import jdk.jfr.internal.SecuritySupport;
 import jdk.jfr.internal.util.ValueFormatter;
-import jdk.jfr.internal.consumer.FileAccess;
 
 // Allows a remote streaming client to create chunk files
 // with same naming scheme as the JVM.
 public final class ChunkFilename {
    private static final int MAX_CHUNK_NAMES = 100_000;
    private static final String FILE_EXTENSION = ".jfr";
 
    private final Path directory;
-   private final FileAccess fileAcess;
 
    private Path lastPath;
    private int counter;
 
-   public static ChunkFilename newUnpriviliged(Path directory) {
-       return new ChunkFilename(directory, FileAccess.UNPRIVILEGED);
-   }
-
-   public static ChunkFilename newPriviliged(Path directory) {
-       return new ChunkFilename(directory, SecuritySupport.PRIVILEGED);
-   }
-
-   private ChunkFilename(Path directory, FileAccess fileAccess) {
-       // Avoid malicious implementations of Path interface
-       this.directory = Paths.get(directory.toString());
-       this.fileAcess = fileAccess;
+   public ChunkFilename(Path directory) {
+       this.directory = directory;
    }
 
    public String next(LocalDateTime time) throws IOException {
        String filename = ValueFormatter.formatDateTime(time);
        Path p = directory.resolve(filename + FILE_EXTENSION);
 
        // If less than one file per second (typically case)
        if (lastPath == null || !p.equals(lastPath)) {
-           if (!fileAcess.exists(p)) {
+           if (!Files.exists(p)) {
                counter = 1; // reset counter
                lastPath = p;
                return p.toString();
            }
        }
@@ -75,11 +63,11 @@
        // If more than one file per second
        while (counter < MAX_CHUNK_NAMES) {
            String extendedName = makeExtendedName(filename, counter);
            p = directory.resolve(extendedName);
            counter++;
-           if (!fileAcess.exists(p)) {
+           if (!Files.exists(p)) {
                return p.toString();
            }
        }
        throw new IOException("Unable to find unused filename after " + counter + " attempts");
    }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/management/ManagementSupport.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,12 +32,10 @@
 import java.time.Instant;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Consumer;
-import java.security.AccessControlContext;
-
 import jdk.jfr.Configuration;
 import jdk.jfr.EventSettings;
 import jdk.jfr.EventType;
 import jdk.jfr.Recording;
 import jdk.jfr.consumer.EventStream;
@@ -47,19 +45,16 @@
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.MetadataRepository;
 import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
-import jdk.jfr.internal.SecuritySupport;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.util.Utils;
 import jdk.jfr.internal.util.ValueFormatter;
 import jdk.jfr.internal.util.ValueParser;
-import jdk.jfr.internal.WriteableUserPath;
+import jdk.jfr.internal.WriteablePath;
 import jdk.jfr.internal.consumer.AbstractEventStream;
 import jdk.jfr.internal.consumer.EventDirectoryStream;
-import jdk.jfr.internal.consumer.FileAccess;
 
 /**
  * The management API in module jdk.management.jfr should be built on top of the
  * public API in jdk.jfr. Before putting more functionality here, consider if it
  * should not be part of the public API, and if not, please provide motivation
@@ -82,11 +77,10 @@
     // An alternative design would be to make FlightRecorder#getEventTypes
     // static, but it would the make the API look strange
     //
     public static List<EventType> getEventTypes() {
         // would normally be checked when a Flight Recorder instance is created
-        SecuritySupport.checkAccessFlightRecorder();
         if (JVMSupport.isNotAvailable()) {
             return List.of();
         }
         JDKEvents.initialize(); // make sure JDK events are available
         return Collections.unmodifiableList(MetadataRepository.getInstance().getRegisteredEventTypes());
@@ -119,21 +113,20 @@
 
     // Get the textual representation when the destination was set, which
     // requires access to jdk.jfr.internal.PlatformRecording
     public static String getDestinationOriginalText(Recording recording) {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-        WriteableUserPath wup = pr.getDestination();
-        return wup == null ? null : wup.getOriginalText();
+        WriteablePath wp = pr.getDestination();
+        return wp == null ? null : wp.getPath().toString();
     }
 
     // Needed to check if destination can be set, so FlightRecorderMXBean::setRecordingOption
     // can abort if not all data is valid
-    public static void checkSetDestination(Recording recording, String destination) throws IOException{
+    public static void checkSetDestination(Recording recording, String destination) throws IOException {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
         if(destination != null){
-            WriteableUserPath wup = new WriteableUserPath(Paths.get(destination));
-            pr.checkSetDestination(wup);
+            pr.checkSetDestination(new WriteablePath(Paths.get(destination)));
         }
     }
 
     // Needed to modify setting using fluent API.
     public static EventSettings newEventSettings(EventSettingsModifier esm) {
@@ -141,11 +134,11 @@
     }
 
     // Needed callback to detect when a chunk has been parsed.
     public static void removePath(Recording recording, Path path) {
         PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);
-        pr.removePath(new SafePath(path));
+        pr.removePath(path);
     }
 
     // Needed callback to detect when a chunk has been parsed.
     public static void setOnChunkCompleteHandler(EventStream stream, Consumer<Long> consumer) {
         EventDirectoryStream eds = (EventDirectoryStream) stream;
@@ -167,18 +160,14 @@
 
     // Can't use EventStream.openRepository(...) because
     // EventStream::onMetadataData need to supply MetadataEvent
     // with configuration objects
     public static EventStream newEventDirectoryStream(
-            @SuppressWarnings("removal")
-            AccessControlContext acc,
             Path directory,
             List<Configuration> confs) throws IOException {
         return new EventDirectoryStream(
-            acc,
             directory,
-            FileAccess.UNPRIVILEGED,
             null,
             confs,
             false
         );
     }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JDKEventTask.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JDKEventTask.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JDKEventTask.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 2023, 2024, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.jfr.internal.periodic;
-
-import jdk.internal.event.Event;
-import jdk.jfr.internal.util.Utils;
-
-/**
- * Periodic task that runs trusted code that doesn't require an access control
- * context.
- * <p>
- * This class can be removed once the Security Manager is no longer supported.
- */
-final class JDKEventTask extends JavaEventTask {
-
-    public JDKEventTask(Class<? extends Event> eventClass, Runnable runnable) {
-        super(eventClass, runnable);
-        if (!getEventType().isJDK()) {
-            throw new InternalError("Must be a JDK event");
-        }
-        if (!Utils.isJDKClass(eventClass)) {
-            throw new SecurityException("Periodic task can only be registered for event classes that belongs to the JDK");
-        }
-        if (!Utils.isJDKClass(runnable.getClass())) {
-            throw new SecurityException("Runnable class must belong to the JDK");
-        }
-    }
-
-    @Override
-    public void execute(long timestamp, PeriodicType periodicType) {
-        getRunnable().run();
-    }
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JavaEventTask.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JavaEventTask.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JavaEventTask.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/JavaEventTask.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2023, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,13 +28,13 @@
 import jdk.jfr.EventType;
 import jdk.jfr.internal.MetadataRepository;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.PrivateAccess;
 /**
- * Base class for periodic Java events.
+ * Class for periodic Java events.
  */
-abstract class JavaEventTask extends EventTask {
+final class JavaEventTask extends EventTask {
     private final Runnable runnable;
 
     public JavaEventTask(Class<? extends Event> eventClass, Runnable runnable) {
         super(toPlatformEventType(eventClass), new LookupKey(runnable));
         this.runnable = runnable;
@@ -46,9 +46,10 @@
     private static PlatformEventType toPlatformEventType(Class<? extends Event> eventClass) {
         EventType eventType = MetadataRepository.getInstance().getEventType(eventClass);
         return PrivateAccess.getInstance().getPlatformEventType(eventType);
     }
 
-    protected final Runnable getRunnable() {
-        return runnable;
+    @Override
+    public void execute(long timestamp, PeriodicType periodicType) {
+        runnable.run();
     }
 }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/LookupKey.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/LookupKey.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/LookupKey.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/LookupKey.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2023, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,15 +23,12 @@
  * questions.
  */
 package jdk.jfr.internal.periodic;
 
 /**
- * Lookup key that can safely be used in a {@code Map}.
- * <p>
- * {@code Runnable} objects can't be used with {@code LinkedHashMap} as it
- * invokes {@code hashCode} and {@code equals}, for example when resizing the
- * {@code Map}, possibly in a non-secure context.
+ * Lookup key that can be used in a {@code Map} in
+ * case hashCode and equals are incorrectly overridden.
  * <p>
  * {@code IdentityHashMap} can't be used as it will not preserve order.
  */
 final class LookupKey {
     private final Object object;
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicEvents.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicEvents.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicEvents.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicEvents.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -22,11 +22,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.jfr.internal.periodic;
 
-import java.security.AccessControlContext;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
 
 import jdk.internal.event.Event;
@@ -56,22 +55,18 @@
     private static final AtomicLong settingsIteration = new AtomicLong();
 
     // State only to be read and modified by periodic task thread
     private static long lastTimeMillis;
 
-    public static void addJDKEvent(Class<? extends Event> eventClass, Runnable runnable) {
-        taskRepository.add(new JDKEventTask(eventClass, runnable));
+    public static void addJavaEvent(Class<? extends Event> eventClass, Runnable runnable) {
+        taskRepository.add(new JavaEventTask(eventClass, runnable));
     }
 
     public static void addJVMEvent(PlatformEventType eventType) {
         taskRepository.add(new JVMEventTask(eventType));
     }
 
-    public static void addUserEvent(@SuppressWarnings("removal") AccessControlContext acc, Class<? extends Event> eventClass, Runnable runnable) {
-        taskRepository.add(new UserEventTask(acc, eventClass, runnable));
-    }
-
     public static boolean removeEvent(Runnable runnable) {
         return taskRepository.removeTask(runnable);
     }
 
     public static void doChunkBegin() {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicTask.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicTask.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicTask.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/PeriodicTask.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2023, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -38,13 +38,10 @@
  *               /          \
  *          EventTask    FlushTask
  *           /     \
  *          /       \
  * JVMEventTask   JavaEventTask
- *                /         \
- *               /           \
- *      UserEventTask     JDKEventTask
  * </pre>
  * <p>
  * State modifications should only be done from the periodic task thread.
  */
 abstract class PeriodicTask {
@@ -125,12 +122,12 @@
             logChunk(periodicType);
         }
         try {
             execute(timestamp, periodicType);
         } catch (Throwable e) {
-            // Prevent malicious user to propagate exception callback in the wrong context
-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, "Exception occurred during execution of " + name);
+            String msg = "Exception occurred during execution of " + name + ". " + e.getMessage();
+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, msg);
         }
     }
 
     private void logChunk(PeriodicType periodicType) {
         if (Logger.shouldLog(LogTag.JFR_PERIODIC, LogLevel.DEBUG)) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/UserEventTask.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/UserEventTask.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/periodic/UserEventTask.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.jfr.internal.periodic;
-
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Objects;
-
-import jdk.internal.event.Event;
-import jdk.jfr.internal.LogLevel;
-import jdk.jfr.internal.LogTag;
-import jdk.jfr.internal.Logger;
-
-/**
- * Class to be used with user-defined events that runs untrusted code.
- * <p>
- * This class can be removed once the Security Manager is no longer supported.
- */
-final class UserEventTask extends JavaEventTask {
-    @SuppressWarnings("removal")
-    private final AccessControlContext controlContext;
-
-    public UserEventTask(@SuppressWarnings("removal") AccessControlContext controlContext, Class<? extends Event> eventClass, Runnable runnable) {
-        super(eventClass, runnable);
-        this.controlContext = Objects.requireNonNull(controlContext);
-    }
-
-    @SuppressWarnings("removal")
-    @Override
-    public void execute(long timestamp, PeriodicType periodicType) {
-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
-            execute();
-            return null;
-        }, controlContext);
-    }
-
-    private void execute() {
-        try {
-            getRunnable().run();
-            if (Logger.shouldLog(LogTag.JFR_EVENT, LogLevel.DEBUG)) {
-                Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, "Executed periodic task for " + getEventType().getLogName());
-            }
-        } catch (Throwable t) {
-            // Prevent malicious user to propagate exception callback in the wrong context
-            Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, "Exception occurred during execution of period task for " + getEventType().getLogName());
-        }
-    }
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/BooleanSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/BooleanSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/BooleanSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/BooleanSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2024, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,13 +26,14 @@
 package jdk.jfr.internal.settings;
 
 import java.util.Objects;
 import java.util.Set;
 
+import jdk.jfr.SettingControl;
 import jdk.jfr.internal.PlatformEventType;
 
-abstract class BooleanSetting extends JDKSettingControl {
+abstract class BooleanSetting extends SettingControl {
     private final PlatformEventType eventType;
     private final String defaultValue;
     private String value;
 
     public BooleanSetting(PlatformEventType eventType, String defaultValue) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/CutoffSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/CutoffSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/CutoffSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/CutoffSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,10 +29,11 @@
 
 import java.util.Objects;
 import java.util.Set;
 
 import jdk.jfr.Description;
+import jdk.jfr.SettingControl;
 import jdk.jfr.Label;
 import jdk.jfr.MetadataDefinition;
 import jdk.jfr.Name;
 import jdk.jfr.Timespan;
 import jdk.jfr.internal.PlatformEventType;
@@ -42,11 +43,11 @@
 @MetadataDefinition
 @Label("Cutoff")
 @Description("Limit running time of event")
 @Name(Type.SETTINGS_PREFIX + "Cutoff")
 @Timespan
-public final class CutoffSetting extends JDKSettingControl {
+public final class CutoffSetting extends SettingControl {
     public static final String DEFAULT_VALUE = ValueParser.INFINITY;
     private String value = DEFAULT_VALUE;
     private final PlatformEventType eventType;
 
     public CutoffSetting(PlatformEventType eventType) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/JDKSettingControl.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/JDKSettingControl.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/JDKSettingControl.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package jdk.jfr.internal.settings;
-
-import jdk.jfr.SettingControl;
-
-/**
- * SettingControls that derive from this class avoids executing settings
- * modifications in a AccessController.doPrivilege(...) block.
- */
-public abstract class JDKSettingControl extends SettingControl {
-}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/LevelSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/LevelSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/LevelSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/LevelSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2023, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2023, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,17 +31,18 @@
 import java.util.Set;
 
 import jdk.jfr.Label;
 import jdk.jfr.MetadataDefinition;
 import jdk.jfr.Name;
+import jdk.jfr.SettingControl;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.Type;
 
 @MetadataDefinition
 @Label("Level")
 @Name(Type.SETTINGS_PREFIX + "Level")
-public final class LevelSetting extends JDKSettingControl {
+public final class LevelSetting extends SettingControl {
     private final PlatformEventType eventType;
     private final List<String> levels;
     private String value;
 
     public LevelSetting(PlatformEventType eventType, String[] levels) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/PeriodSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/PeriodSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/PeriodSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/PeriodSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,20 +30,21 @@
 
 import jdk.jfr.Description;
 import jdk.jfr.Label;
 import jdk.jfr.MetadataDefinition;
 import jdk.jfr.Name;
+import jdk.jfr.SettingControl;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.ValueParser;
 import static jdk.jfr.internal.util.ValueParser.MISSING;
 
 @MetadataDefinition
 @Label("Period")
 @Description("Record event at interval")
 @Name(Type.SETTINGS_PREFIX + "Period")
-public final class PeriodSetting extends JDKSettingControl {
+public final class PeriodSetting extends SettingControl {
     private static final long typeId = Type.getTypeId(PeriodSetting.class);
 
     public static final String EVERY_CHUNK = "everyChunk";
     public static final String BEGIN_CHUNK = "beginChunk";
     public static final String END_CHUNK = "endChunk";
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThresholdSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThresholdSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThresholdSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThresholdSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,21 +32,22 @@
 
 import jdk.jfr.Description;
 import jdk.jfr.Label;
 import jdk.jfr.MetadataDefinition;
 import jdk.jfr.Name;
+import jdk.jfr.SettingControl;
 import jdk.jfr.Timespan;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.ValueParser;
 
 @MetadataDefinition
 @Label("Threshold")
 @Name(Type.SETTINGS_PREFIX + "Threshold")
 @Description("Record event with duration above or equal to threshold")
 @Timespan
-public final class ThresholdSetting extends JDKSettingControl {
+public final class ThresholdSetting extends SettingControl {
     public static final String DEFAULT_VALUE = "0 ns";
     private static final long typeId = Type.getTypeId(ThresholdSetting.class);
     private String value = DEFAULT_VALUE;
     private final PlatformEventType eventType;
 
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThrottleSetting.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThrottleSetting.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThrottleSetting.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/settings/ThrottleSetting.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2020, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2020, Datadog, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -34,10 +34,11 @@
 
 import jdk.jfr.Description;
 import jdk.jfr.Label;
 import jdk.jfr.MetadataDefinition;
 import jdk.jfr.Name;
+import jdk.jfr.SettingControl;
 import jdk.jfr.internal.PlatformEventType;
 import jdk.jfr.internal.Throttle;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.util.Rate;
 import jdk.jfr.internal.util.TimespanUnit;
@@ -45,11 +46,11 @@
 
 @MetadataDefinition
 @Label("Throttle")
 @Description("Throttles the emission rate for an event")
 @Name(Type.SETTINGS_PREFIX + "Throttle")
-public final class ThrottleSetting extends JDKSettingControl {
+public final class ThrottleSetting extends SettingControl {
     public static final String DEFAULT_VALUE = Throttle.DEFAULT;
     private final PlatformEventType eventType;
     private String value = DEFAULT_VALUE;
 
     public ThrottleSetting(PlatformEventType eventType) {
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -50,11 +50,11 @@
 
     private static List<Command> createCommands() {
         List<Command> commands = new ArrayList<>();
         commands.add(new Print());
         // Uncomment when developing new queries for the view command
-        // commands.add(new Query());
+        commands.add(new Query());
         commands.add(new View());
         commands.add(new Configure());
         commands.add(new Metadata());
         commands.add(new Scrub());
         commands.add(new Summary());
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Configure.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,11 +36,10 @@
 import java.util.Deque;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.jfc.JFC;
 import jdk.jfr.internal.jfc.model.AbortException;
 import jdk.jfr.internal.jfc.model.JFCModel;
 import jdk.jfr.internal.jfc.model.JFCModelException;
 import jdk.jfr.internal.jfc.model.SettingsLog;
@@ -127,11 +126,11 @@
     private void displayParameters(PrintStream stream, String name) {
         stream.println();
         stream.println("Options for " + name + ":");
         stream.println();
         try {
-            SafePath path = JFC.createSafePath(name);
+            Path path = JFC.ofPath(name);
             JFCModel parameters = JFCModel.create(path, l -> stream.println("Warning! " + l));
             for (XmlInput input : parameters.getInputs()) {
                 stream.println("  " + input.getOptionSyntax());
                 stream.println();
             }
@@ -142,11 +141,11 @@
 
     @Override
     public void execute(Deque<String> options) throws UserSyntaxException, UserDataException {
         boolean interactive = false;
         boolean log = false;
-        SafePath output = null;
+        Path output = null;
         Map<String, String> keyValues = new LinkedHashMap<>();
         int optionCount = options.size();
         while (optionCount > 0) {
             if (acceptSwitch(options, "--interactive")) {
                 interactive = true;
@@ -190,27 +189,27 @@
             return index > 0 && index < keyValue.length() - 1;
         }
         return false;
     }
 
-    private void configure(boolean interactive, boolean log, SafePath output, Map<String, String> options) throws UserDataException {
+    private void configure(boolean interactive, boolean log, Path output, Map<String, String> options) throws UserDataException {
         UserInterface ui = new UserInterface();
         if (log) {
             SettingsLog.enable();
         }
         JFCModel model = new JFCModel(l -> ui.println("Warning! " + l));
         model.setLabel("Custom");
         for (String input : inputFiles) {
             try {
-                model.parse(JFC.createSafePath(input));
+                model.parse(JFC.ofPath(input));
             } catch (InvalidPathException | IOException | JFCModelException | ParseException e) {
                 throw new UserDataException(JFC.formatException("could not", e, input));
             }
         }
         try {
             if (output == null) {
-                output = new SafePath(Path.of("custom.jfc"));
+                output = Path.of("custom.jfc");
             }
             for (var option : options.entrySet()) {
                 model.configure(option.getKey(), option.getValue());
             }
             SettingsLog.flush();
@@ -228,11 +227,11 @@
                 ui.println("Abort.");
                 return;
             }
             model.saveToFile(output);
             ui.println("Configuration written successfully to:");
-            ui.println(output.toPath().toAbsolutePath().toString());
+            ui.println(output.toAbsolutePath().toString());
         } catch (IllegalArgumentException iae) {
             throw new UserDataException(iae.getMessage());
         } catch (FileNotFoundException ffe) {
             throw new UserDataException("could not find file: " + ffe.getMessage());
         } catch (IOException ioe) {
@@ -244,37 +243,37 @@
         if (inputFiles.isEmpty()) {
             inputFiles.add("default.jfc");
         }
     }
 
-    private static SafePath filename(UserInterface ui, SafePath file) throws AbortException {
+    private static Path filename(UserInterface ui, Path file) throws AbortException {
         ui.println();
         ui.println("Filename: " + file + " (default)");
         while (true) {
             String line = ui.readLine();
             try {
                 if (line.isBlank()) {
                     return file;
                 }
                 if (line.endsWith(".jfc")) {
-                    return new SafePath(line);
+                    return Path.of(line);
                 }
                 ui.println("Filename must end with .jfc.");
             } catch (InvalidPathException ipe) {
                 ui.println("Not a valid filename. " + ipe.getMessage());
             }
         }
     }
 
-    private SafePath makeJFCPath(String file) throws UserDataException, UserSyntaxException {
+    private Path makeJFCPath(String file) throws UserDataException, UserSyntaxException {
         if (file.startsWith("--")) {
             throw new UserSyntaxException("missing file");
         }
         try {
             Path path = Path.of(file).toAbsolutePath();
             ensureFileExtension(path, ".jfc");
-            return new SafePath(path);
+            return path;
         } catch (IOError ioe) {
             throw new UserDataException("i/o error reading file '" + file + "', " + ioe.getMessage());
         } catch (InvalidPathException ipe) {
             throw new UserDataException("invalid path '" + file + "'");
         }
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Disassemble.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Disassemble.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Disassemble.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Disassemble.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,11 +39,10 @@
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.List;
 
 import jdk.jfr.internal.consumer.ChunkHeader;
-import jdk.jfr.internal.consumer.FileAccess;
 import jdk.jfr.internal.consumer.RecordingInput;
 import jdk.jfr.internal.util.UserDataException;
 import jdk.jfr.internal.util.UserSyntaxException;
 
 final class Disassemble extends Command {
@@ -164,11 +163,11 @@
             throw new UserDataException("no JFR chunks found in file.");
         }
     }
 
     private List<Long> findChunkSizes(Path p) throws IOException {
-        try (RecordingInput input = new RecordingInput(p.toFile(), FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput input = new RecordingInput(p.toFile())) {
             List<Long> sizes = new ArrayList<>();
             ChunkHeader ch = new ChunkHeader(input);
             sizes.add(ch.getSize());
             while (!ch.isLastChunk()) {
                 ch = ch.nextHeader();
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Summary.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Summary.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Summary.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Summary.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,11 +39,10 @@
 
 import jdk.jfr.EventType;
 import jdk.jfr.internal.MetadataDescriptor;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.consumer.ChunkHeader;
-import jdk.jfr.internal.consumer.FileAccess;
 import jdk.jfr.internal.consumer.RecordingInput;
 import jdk.jfr.internal.util.UserDataException;
 import jdk.jfr.internal.util.UserSyntaxException;
 
 final class Summary extends Command {
@@ -91,11 +90,11 @@
 
     private void printInformation(Path p) throws IOException {
         long totalDuration = 0;
         long chunks = 0;
 
-        try (RecordingInput input = new RecordingInput(p.toFile(), FileAccess.UNPRIVILEGED)) {
+        try (RecordingInput input = new RecordingInput(p.toFile())) {
             ChunkHeader first = new ChunkHeader(input);
             ChunkHeader ch = first;
             String eventPrefix = Type.EVENT_NAME_PREFIX;
             if (first.getMajor() == 1) {
                 eventPrefix = "com.oracle.jdk.";
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/util/DirectoryCleaner.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/util/DirectoryCleaner.java
--- /dev/null
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/util/DirectoryCleaner.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.jfr.internal.util;
+
+import java.io.IOException;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+
+public final class DirectoryCleaner extends SimpleFileVisitor<Path> {
+
+    public static void clear(Path path) throws IOException {
+        Files.walkFileTree(path, new DirectoryCleaner());
+    }
+
+    @Override
+    public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
+        Files.delete(path);
+        return FileVisitResult.CONTINUE;
+    }
+
+    @Override
+    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
+        if (exc != null) {
+            throw exc;
+        }
+        Files.delete(dir);
+        return FileVisitResult.CONTINUE;
+    }
+}
diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/util/Utils.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/util/Utils.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/util/Utils.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/util/Utils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,11 +23,13 @@
  * questions.
  */
 
 package jdk.jfr.internal.util;
 
+import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Repeatable;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
@@ -446,6 +448,15 @@
                 return v;
             }
         }
         return null;
     }
+
+    public static Path getPathInProperty(String prop, String subPath) {
+        String path = System.getProperty(prop);
+        if (path == null) {
+            return null;
+        }
+        File file = subPath == null ? new File(path) : new File(path, subPath);
+        return file.toPath().toAbsolutePath();
+    }
 }
diff a/src/jdk.management.jfr/share/classes/jdk/management/jfr/DiskRepository.java b/src/jdk.management.jfr/share/classes/jdk/management/jfr/DiskRepository.java
--- a/src/jdk.management.jfr/share/classes/jdk/management/jfr/DiskRepository.java
+++ b/src/jdk.management.jfr/share/classes/jdk/management/jfr/DiskRepository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2020, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -149,11 +149,11 @@
     private long size;
 
     public DiskRepository(Path path, boolean deleteDirectory) throws IOException {
         this.directory = path;
         this.deleteDirectory = deleteDirectory;
-        this.chunkFilename = ChunkFilename.newUnpriviliged(path);
+        this.chunkFilename = new ChunkFilename(path);
     }
 
     public synchronized void write(byte[] bytes) throws IOException {
         barrier.check();
         index = 0;
diff a/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java b/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
--- a/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
+++ b/src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,13 +28,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.security.AccessControlContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.text.ParseException;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -65,11 +62,10 @@
 
 import jdk.jfr.Configuration;
 import jdk.jfr.EventType;
 import jdk.jfr.FlightRecorder;
 import jdk.jfr.FlightRecorderListener;
-import jdk.jfr.FlightRecorderPermission;
 import jdk.jfr.Recording;
 import jdk.jfr.RecordingState;
 import jdk.jfr.internal.management.ManagementSupport;
 import jdk.jfr.internal.management.StreamManager;
 
@@ -78,30 +74,21 @@
 
     final class MXBeanListener implements FlightRecorderListener {
         private final NotificationListener listener;
         private final NotificationFilter filter;
         private final Object handback;
-        @SuppressWarnings("removal")
-        private final AccessControlContext context;
 
         @SuppressWarnings("removal")
         public MXBeanListener(NotificationListener listener, NotificationFilter filter, Object handback) {
-            this.context = AccessController.getContext();
             this.listener = listener;
             this.filter = filter;
             this.handback = handback;
         }
 
         @SuppressWarnings("removal")
         public void recordingStateChanged(Recording recording) {
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                @Override
-                public Void run() {
-                    sendNotification(createNotification(recording));
-                    return null;
-                }
-            }, context);
+            sendNotification(createNotification(recording));
         }
     }
 
     private static final String ATTRIBUTE_RECORDINGS = "Recordings";
     private static final String OPTION_MAX_SIZE = "maxSize";
@@ -122,29 +109,25 @@
         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
     }
 
     @Override
     public void startRecording(long id) {
-        MBeanUtils.checkControl();
         getExistingRecording(id).start();
     }
 
     @Override
     public boolean stopRecording(long id) {
-        MBeanUtils.checkControl();
         return getExistingRecording(id).stop();
     }
 
     @Override
     public void closeRecording(long id) {
-        MBeanUtils.checkControl();
         getExistingRecording(id).close();
     }
 
     @Override
     public long openStream(long id, Map<String, String> options) throws IOException {
-        MBeanUtils.checkControl();
         if (!FlightRecorder.isInitialized()) {
             throw new IllegalArgumentException("No recording available with id " + id);
         }
         // Make local copy to prevent concurrent modification
         Map<String, String> s = options == null ? new HashMap<>() : new HashMap<>(options);
@@ -167,85 +150,61 @@
         return streamHandler.create(is, blockSize).getId();
     }
 
     @Override
     public void closeStream(long streamIdentifier) throws IOException {
-        MBeanUtils.checkControl();
         streamHandler.getStream(streamIdentifier).close();
     }
 
     @Override
     public byte[] readStream(long streamIdentifier) throws IOException {
-        MBeanUtils.checkMonitor();
         return streamHandler.getStream(streamIdentifier).read();
     }
 
     @Override
     public List<RecordingInfo> getRecordings() {
-        MBeanUtils.checkMonitor();
         if (!FlightRecorder.isInitialized()) {
             return Collections.emptyList();
         }
         return MBeanUtils.transformList(getRecorder().getRecordings(), RecordingInfo::new);
     }
 
     @Override
     public List<ConfigurationInfo> getConfigurations() {
-        MBeanUtils.checkMonitor();
         return MBeanUtils.transformList(Configuration.getConfigurations(), ConfigurationInfo::new);
     }
 
     @Override
     public List<EventTypeInfo> getEventTypes() {
-        MBeanUtils.checkMonitor();
-        @SuppressWarnings("removal")
-        List<EventType> eventTypes = AccessController.doPrivileged(new PrivilegedAction<List<EventType>>() {
-            @Override
-            public List<EventType> run() {
-                return ManagementSupport.getEventTypes();
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder"));
-
-        return MBeanUtils.transformList(eventTypes, EventTypeInfo::new);
+        return MBeanUtils.transformList(ManagementSupport.getEventTypes(), EventTypeInfo::new);
     }
 
     @Override
     public Map<String, String> getRecordingSettings(long recording) throws IllegalArgumentException {
-        MBeanUtils.checkMonitor();
         return getExistingRecording(recording).getSettings();
     }
 
     @Override
     public void setRecordingSettings(long recording, Map<String, String> settings) throws IllegalArgumentException {
         Objects.requireNonNull(settings, "settings");
-        MBeanUtils.checkControl();
         getExistingRecording(recording).setSettings(settings);
     }
 
-    @SuppressWarnings("removal")
     @Override
     public long newRecording() {
-        MBeanUtils.checkControl();
         getRecorder(); // ensure notification listener is setup
-        return AccessController.doPrivileged(new PrivilegedAction<Recording>() {
-            @Override
-            public Recording run() {
-                return new Recording();
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder")).getId();
+        return new Recording().getId();
     }
 
     @Override
     public long takeSnapshot() {
-        MBeanUtils.checkControl();
         return getRecorder().takeSnapshot().getId();
     }
 
     @Override
     public void setConfiguration(long recording, String contents) throws IllegalArgumentException {
         Objects.requireNonNull(contents, "contents");
-        MBeanUtils.checkControl();
         try {
             Configuration c = Configuration.create(new StringReader(contents));
             getExistingRecording(recording).setSettings(c.getSettings());
         } catch (IOException | ParseException e) {
             throw new IllegalArgumentException("Could not parse configuration", e);
@@ -253,11 +212,10 @@
     }
 
     @Override
     public void setPredefinedConfiguration(long recording, String configurationName) throws IllegalArgumentException {
         Objects.requireNonNull(configurationName, "configurationName");
-        MBeanUtils.checkControl();
         Recording r = getExistingRecording(recording);
         for (Configuration c : Configuration.getConfigurations()) {
             if (c.getName().equals(configurationName)) {
                 r.setSettings(c.getSettings());
                 return;
@@ -267,18 +225,16 @@
     }
 
     @Override
     public void copyTo(long recording, String outputFile) throws IOException {
         Objects.requireNonNull(outputFile, "outputFile");
-        MBeanUtils.checkControl();
         getExistingRecording(recording).dump(Paths.get(outputFile));
     }
 
     @Override
     public void setRecordingOptions(long recording, Map<String, String> options) throws IllegalArgumentException {
         Objects.requireNonNull(options, "options");
-        MBeanUtils.checkControl();
         // Make local copy to prevent concurrent modification
         Map<String, String> ops = new HashMap<String, String>(options);
         for (Map.Entry<String, String> entry : ops.entrySet()) {
             Object key = entry.getKey();
             Object value = entry.getValue();
@@ -313,11 +269,10 @@
         setOption(ops, OPTION_DESTINATION, null, x -> MBeanUtils.destination(r, x), x -> setOptionDestination(r, x));
     }
 
     @Override
     public Map<String, String> getRecordingOptions(long recording) throws IllegalArgumentException {
-        MBeanUtils.checkMonitor();
         Recording r = getExistingRecording(recording);
         Map<String, String> options = HashMap.newHashMap(10);
         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
         options.put(OPTION_NAME, String.valueOf(r.getName()));
@@ -328,12 +283,11 @@
         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));
         return options;
     }
 
     @Override
-    public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {
-        MBeanUtils.checkControl();
+    public long cloneRecording(long id, boolean stop) throws IllegalStateException {
         return getRecording(id).copy(stop).getId();
     }
 
     @Override
     public ObjectName getObjectName() {
@@ -395,20 +349,15 @@
             throw new IllegalArgumentException("Not a valid value for option '" + name + "'. " + iae.getMessage());
         }
     }
 
     @SuppressWarnings("removal")
-    private FlightRecorder getRecorder() throws SecurityException {
+    private FlightRecorder getRecorder() {
         // Synchronize on some private object that is always available
         synchronized (streamHandler) {
             if (recorder == null) {
-                recorder = AccessController.doPrivileged(new PrivilegedAction<FlightRecorder>() {
-                    @Override
-                    public FlightRecorder run() {
-                        return FlightRecorder.getFlightRecorder();
-                    }
-                }, null, new FlightRecorderPermission("accessFlightRecorder"));
+                recorder = FlightRecorder.getFlightRecorder();
             }
             return recorder;
         }
     }
 
@@ -423,17 +372,11 @@
     @SuppressWarnings("removal")
     @Override
     public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) {
         MXBeanListener mxbeanListener = new MXBeanListener(listener, filter, handback);
         listeners.add(mxbeanListener);
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run(){
-                FlightRecorder.addListener(mxbeanListener);
-                return null;
-            }
-        }, null, new FlightRecorderPermission("accessFlightRecorder"));
+        FlightRecorder.addListener(mxbeanListener);
         super.addNotificationListener(listener, filter, handback);
     }
 
     @Override
     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
diff a/src/jdk.management.jfr/share/classes/jdk/management/jfr/MBeanUtils.java b/src/jdk.management.jfr/share/classes/jdk/management/jfr/MBeanUtils.java
--- a/src/jdk.management.jfr/share/classes/jdk/management/jfr/MBeanUtils.java
+++ b/src/jdk.management.jfr/share/classes/jdk/management/jfr/MBeanUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,12 +23,10 @@
  * questions.
  */
 package jdk.management.jfr;
 
 import java.io.IOException;
-import java.lang.management.ManagementPermission;
-import java.security.Permission;
 import java.time.DateTimeException;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.format.DateTimeParseException;
 import java.util.List;
@@ -41,37 +39,18 @@
 import jdk.jfr.Recording;
 import jdk.jfr.internal.management.ManagementSupport;
 
 final class MBeanUtils {
 
-    private static final Permission monitor = new ManagementPermission("monitor");
-    private static final Permission control = new ManagementPermission("control");
-
     static ObjectName createObjectName() {
         try {
             return new ObjectName(FlightRecorderMXBean.MXBEAN_NAME);
         } catch (MalformedObjectNameException mne) {
             throw new Error("Can't happen", mne);
         }
     }
 
-    static void checkControl() {
-        @SuppressWarnings("removal")
-        SecurityManager secManager = System.getSecurityManager();
-        if (secManager != null) {
-            secManager.checkPermission(control);
-        }
-    }
-
-    static void checkMonitor() {
-        @SuppressWarnings("removal")
-        SecurityManager secManager = System.getSecurityManager();
-        if (secManager != null) {
-            secManager.checkPermission(monitor);
-        }
-    }
-
     static <T, R> List<R> transformList(List<T> source, Function<T, R> function) {
         return source.stream().map(function).collect(Collectors.toList());
     }
 
     static boolean booleanValue(String s) {
diff a/src/jdk.management.jfr/share/classes/jdk/management/jfr/RemoteRecordingStream.java b/src/jdk.management.jfr/share/classes/jdk/management/jfr/RemoteRecordingStream.java
--- a/src/jdk.management.jfr/share/classes/jdk/management/jfr/RemoteRecordingStream.java
+++ b/src/jdk.management.jfr/share/classes/jdk/management/jfr/RemoteRecordingStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2020, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,23 +30,20 @@
 import java.nio.channels.FileChannel;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
-import java.security.AccessControlContext;
-import java.security.AccessController;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.Future;
 import java.util.function.Consumer;
-import java.security.AccessControlException;
 import javax.management.JMX;
 import javax.management.MBeanServerConnection;
 import javax.management.ObjectName;
 
 import jdk.jfr.Configuration;
@@ -147,12 +144,10 @@
 
     final Path path;
     final FlightRecorderMXBean mbean;
     final long recordingId;
     final EventStream stream;
-    @SuppressWarnings("removal")
-    final AccessControlContext accessControllerContext;
     final DiskRepository repository;
     final Instant creationTime;
     final Object lock = new Object();
     volatile Instant startTime;
     volatile Instant endTime;
@@ -203,13 +198,11 @@
 
     @SuppressWarnings("removal")
     private RemoteRecordingStream(MBeanServerConnection connection, Path directory, boolean delete) throws IOException {
         Objects.requireNonNull(connection, "connection");
         Objects.requireNonNull(directory, "directory");
-        accessControllerContext = AccessController.getContext();
-        // Make sure users can't implement malicious version of a Path object.
-        path = Paths.get(directory.toString());
+        path = directory;
         if (!Files.exists(path)) {
             throw new IOException("Download directory doesn't exist");
         }
 
         if (!Files.isDirectory(path)) {
@@ -217,11 +210,11 @@
         }
         checkFileAccess(path);
         creationTime = Instant.now();
         mbean = createProxy(connection);
         recordingId = createRecording();
-        stream = ManagementSupport.newEventDirectoryStream(accessControllerContext, path, configurations(mbean));
+        stream = ManagementSupport.newEventDirectoryStream(path, configurations(mbean));
         stream.setStartTime(Instant.MIN);
         repository = new DiskRepository(path, delete);
         ManagementSupport.setOnChunkCompleteHandler(stream, new ChunkConsumer(repository));
     }
 
diff a/test/jdk/jdk/jfr/jcmd/TestJcmdConfigure.java b/test/jdk/jdk/jfr/jcmd/TestJcmdConfigure.java
--- a/test/jdk/jdk/jfr/jcmd/TestJcmdConfigure.java
+++ b/test/jdk/jdk/jfr/jcmd/TestJcmdConfigure.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,16 +23,16 @@
 
 package jdk.jfr.jcmd;
 
 import java.io.File;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.Options;
 import jdk.test.lib.Asserts;
 import jdk.test.lib.Utils;
 
 /**
@@ -129,21 +129,21 @@
     private static void testRepository(){
         final String findWhat = "[info][jfr] Same base repository path " + REPOSITORYPATH_1 + " is set";
 
         try {
             JcmdHelper.jcmd("JFR.configure", REPOSITORYPATH_SETTING_1);
-            SafePath initialPath = Repository.getRepository().getRepositoryPath();
+            Path initialPath = Repository.getRepository().getRepositoryPath();
 
             JcmdHelper.jcmd("JFR.configure", REPOSITORYPATH_SETTING_1);
-            SafePath samePath = Repository.getRepository().getRepositoryPath();
+            Path samePath = Repository.getRepository().getRepositoryPath();
             Asserts.assertTrue(samePath.equals(initialPath));
 
             List<String> lines = Files.readAllLines(Paths.get(JFR_UNIFIED_LOG_FILE));
             Asserts.assertTrue(lines.stream().anyMatch(l->l.contains(findWhat)));
 
             JcmdHelper.jcmd("JFR.configure", REPOSITORYPATH_SETTING_2);
-            SafePath changedPath = Repository.getRepository().getRepositoryPath();
+            Path changedPath = Repository.getRepository().getRepositoryPath();
 
             Asserts.assertFalse(changedPath.equals(initialPath));
 
         } catch(Exception e) {
             testExceptions.add(e);
diff a/test/jdk/jdk/jfr/jvm/MyCommitRegisteredFalseEvent.java b/test/jdk/jdk/jfr/jvm/MyCommitRegisteredFalseEvent.java
--- a/test/jdk/jdk/jfr/jvm/MyCommitRegisteredFalseEvent.java
+++ b/test/jdk/jdk/jfr/jvm/MyCommitRegisteredFalseEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,11 +26,11 @@
 
 // Class used by TestGetEventWriter
 @Registered(false)
 public class MyCommitRegisteredFalseEvent extends E implements Runnable {
     public void myCommit() {
-        PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter.getEventWriter();
         throw new RuntimeException("Should not reach here");
     }
 
     @Override
     public void run() {
diff a/test/jdk/jdk/jfr/jvm/MyCommitRegisteredTrueEvent.java b/test/jdk/jdk/jfr/jvm/MyCommitRegisteredTrueEvent.java
--- a/test/jdk/jdk/jfr/jvm/MyCommitRegisteredTrueEvent.java
+++ b/test/jdk/jdk/jfr/jvm/MyCommitRegisteredTrueEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,11 +26,11 @@
 
 // Class used by TestGetEventWriter
 @Registered(true)
 public class MyCommitRegisteredTrueEvent extends E implements Runnable {
     public void myCommit() {
-        PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter.getEventWriter();
         throw new RuntimeException("Should not reach here");
     }
 
     @Override
     public void run() {
diff a/test/jdk/jdk/jfr/jvm/NonEvent.java b/test/jdk/jdk/jfr/jvm/NonEvent.java
--- a/test/jdk/jdk/jfr/jvm/NonEvent.java
+++ b/test/jdk/jdk/jfr/jvm/NonEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,11 @@
 package jdk.jfr.jvm;
 
 // Class used by TestGetEventWriter
 public class NonEvent implements Runnable {
     public void commit() {
-        PlaceholderEventWriter ew = PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter ew = PlaceholderEventWriter.getEventWriter();;
         throw new RuntimeException("Should not reach here " + ew);
     }
 
     @Override
     public void run() {
diff a/test/jdk/jdk/jfr/jvm/PlaceholderEventWriter.java b/test/jdk/jdk/jfr/jvm/PlaceholderEventWriter.java
--- a/test/jdk/jdk/jfr/jvm/PlaceholderEventWriter.java
+++ b/test/jdk/jdk/jfr/jvm/PlaceholderEventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,6 +28,10 @@
 //
 // When the class is loaded "jdk.jfr.jvm.PlaceholderEventWriter"
 // will be replaced with "jdk.jfr.internal.event.EventWriter"
 public class PlaceholderEventWriter {
 
+    public static PlaceholderEventWriter getEventWriter() {
+        return null;
+    }
+
 }
diff a/test/jdk/jdk/jfr/jvm/PlaceholderEventWriterFactory.java b/test/jdk/jdk/jfr/jvm/PlaceholderEventWriterFactory.java
--- a/test/jdk/jdk/jfr/jvm/PlaceholderEventWriterFactory.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package jdk.jfr.jvm;
-
-// Purpose of this class is to have something to
-// statically link against for TestGetEventWriter.
-//
-// When the class is loaded "jdk.jfr.jvm.PlaceholderEventWriterFactory"
-// will be replaced with "jdk.jfr.internal.event.EventWriterFactory"
-public class PlaceholderEventWriterFactory {
-
-    public static PlaceholderEventWriter getEventWriter(long value) {
-        throw new RuntimeException("Test error, PlaceholderEventWriterFactory class should have been replaced with EventWriterFactory");
-    }
-}
diff a/test/jdk/jdk/jfr/jvm/RegisteredFalseEvent.java b/test/jdk/jdk/jfr/jvm/RegisteredFalseEvent.java
--- a/test/jdk/jdk/jfr/jvm/RegisteredFalseEvent.java
+++ b/test/jdk/jdk/jfr/jvm/RegisteredFalseEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,9 +26,9 @@
 
 // Class used by TestGetEventWriter
 @Registered(false)
 public class RegisteredFalseEvent extends E {
     public void commit() {
-        PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter.getEventWriter();
         throw new RuntimeException("Should not reach here");
     }
 }
diff a/test/jdk/jdk/jfr/jvm/RegisteredTrueEvent.java b/test/jdk/jdk/jfr/jvm/RegisteredTrueEvent.java
--- a/test/jdk/jdk/jfr/jvm/RegisteredTrueEvent.java
+++ b/test/jdk/jdk/jfr/jvm/RegisteredTrueEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,9 +26,9 @@
 
 // Class used by TestGetEventWriter
 @Registered(true)
 public class RegisteredTrueEvent extends E {
     public void commit() {
-        PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter.getEventWriter();
         throw new RuntimeException("Should not reach here");
     }
 }
diff a/test/jdk/jdk/jfr/jvm/StaticCommitEvent.java b/test/jdk/jdk/jfr/jvm/StaticCommitEvent.java
--- a/test/jdk/jdk/jfr/jvm/StaticCommitEvent.java
+++ b/test/jdk/jdk/jfr/jvm/StaticCommitEvent.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,11 @@
     String message;
 
     int value;
 
     public static void commit(long start, long duration, String message, int value) {
-        PlaceholderEventWriterFactory.getEventWriter(4711L);
+        PlaceholderEventWriter.getEventWriter();
         throw new RuntimeException("Should not reach here");
     }
 
     @Override
     public void run() {
diff a/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java b/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
--- a/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
+++ b/test/jdk/jdk/jfr/jvm/TestGetEventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -44,11 +44,10 @@
  * @library /test/lib
  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *
  * @compile PlaceholderEventWriter.java
- * @compile PlaceholderEventWriterFactory.java
  * @compile E.java
  * @compile NonEvent.java
  * @compile RegisteredTrueEvent.java
  * @compile RegisteredFalseEvent.java
  * @compile MyCommitRegisteredTrueEvent.java
@@ -78,11 +77,10 @@
  * @library /test/lib
  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *
  * @compile PlaceholderEventWriter.java
- * @compile PlaceholderEventWriterFactory.java
  * @compile E.java
  * @compile NonEvent.java
  * @compile RegisteredTrueEvent.java
  * @compile RegisteredFalseEvent.java
  * @compile MyCommitRegisteredTrueEvent.java
@@ -103,14 +101,14 @@
             r.start();
             // Unlocks access to jdk.jfr.internal.event
             InitializationEvent e  = new InitializationEvent();
             e.commit();
         }
-        // Make sure EventWriterFactory can be accessed.
-        Class<?> clazz = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
+        // Make sure EventWriter class can be accessed.
+        Class<?> clazz = Class.forName("jdk.jfr.internal.event.EventWriter");
         if (clazz == null) {
-            throw new Exception("Test error, not able to access jdk.jfr.internal.event.EventWriterFactory class");
+            throw new Exception("Test error, not able to access jdk.jfr.internal.event.EventWriter class");
         }
         testRegisteredTrueEvent();
         testRegisteredFalseEvent();
         testMyCommitRegisteredTrue();
         testMyCommitRegisteredFalse();
@@ -120,11 +118,11 @@
         testNonEvent();
     }
 
     // The class does not inherit jdk.jfr.Event and, as such, does not implement the
     // API. It has its own stand-alone "commit()V", which is not an override, that
-    // attempts to resolve and link against EventWriterFactory. This user implementation
+    // attempts to resolve and link against EventWriter. This user implementation
     // is not blessed for linkage.
     private static void testNonEvent() throws Throwable {
         Runnable e = newEventObject("NonEvent");
         try {
             e.run(); // invokes commit()
@@ -176,11 +174,11 @@
             // methods in jdk.jfr.Event
         }
     }
 
     // The user has implemented another method, "myCommit()V", not an override nor
-    // overload. that attempts to resolve and link EventWriterFactory. This will fail,
+    // overload. that attempts to resolve and link EventWriter. This will fail,
     // because "myCommit()V" is not blessed for linkage.
     private static void testMyCommitRegisteredTrue() throws Throwable {
         Runnable e = newEventObject("MyCommitRegisteredTrueEvent");
         try {
             e.run(); // Invoking the user-defined method throws.
@@ -228,14 +226,13 @@
 
     static class MethodHandleEvent extends Event {
         public void myCommit() throws Throwable {
             try {
                 Class<?> ew = Class.forName("jdk.jfr.internal.event.EventWriter");
-                MethodType t = MethodType.methodType(ew, List.of(long.class));
-                Class<?> factory = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
-                MethodHandle mh = MethodHandles.lookup().findStatic(factory, "getEventWriter", t);
-                mh.invoke(Long.valueOf(4711)); // throws IllegalAccessException
+                MethodType t = MethodType.methodType(ew, List.of());
+                MethodHandle mh = MethodHandles.lookup().findStatic(ew, "getEventWriter", t);
+                mh.invoke(); // throws IllegalAccessException
             } catch (ClassNotFoundException | SecurityException e) {
                 throw new RuntimeException(e);
             }
         }
     }
@@ -260,12 +257,12 @@
 
     static class ReflectionEvent extends Event {
         public void myCommit() throws Throwable {
             Class<?> c;
             try {
-                c = Class.forName("jdk.jfr.internal.event.EventWriterFactory");
-                Method m = c.getMethod("getEventWriter", new Class[] {long.class});
+                c = Class.forName("jdk.jfr.internal.event.EventWriter");
+                Method m = c.getMethod("getEventWriter", new Class[0]);
                 m.invoke(null, Long.valueOf(4711)); // throws InternalError
             } catch (ClassNotFoundException | SecurityException e) {
                 throw new RuntimeException(e);
             }
         }
@@ -281,11 +278,11 @@
             e.myCommit(); // throws
             throw new RuntimeException("Should not reach here");
         } catch (InternalError ie) {
             if (ie.getCause() instanceof IllegalAccessException iaex) {
                 if (iaex.getCause() instanceof IllegalAccessError iae) {
-                    if (iae.getMessage().contains("getEventWriter(long)")) {
+                    if (iae.getMessage().contains("getEventWriter()")) {
                         // OK, as expected
                         return;
                     }
                 }
             }
@@ -343,11 +340,10 @@
             throw new Exception("Test error, could not located class file for " + name);
         }
         byte[] bytes = is.readAllBytes();
         is.close();
         bytes = replace(bytes, "jdk/jfr/jvm/E", "jdk/jfr/Event");
-        bytes = replace(bytes, "jdk/jfr/jvm/PlaceholderEventWriterFactory", "jdk/jfr/internal/event/EventWriterFactory");
         bytes = replace(bytes, "jdk/jfr/jvm/PlaceholderEventWriter", "jdk/jfr/internal/event/EventWriter");
         BytesClassLoader bc = new BytesClassLoader(bytes, fullName);
         Class<?> clazz = bc.loadClass(fullName);
         Constructor<?> constructor = clazz.getConstructor(new Class[0]);
         System.out.println("About to invoke " + fullName + ".commit()");
@@ -370,19 +366,19 @@
         }
         checkJVMCI(eventClass, commitName);
     }
 
     /**
-     * Checks that JVMCI prevents unblessed access to {@code EventWriterFactory.getEventWriter(long)}.
+     * Checks that JVMCI prevents unblessed access to {@code EventWriter.getEventWriter()}.
      */
     private static void checkJVMCI(Class<?> eventClass, String commitName) throws Throwable {
         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
         ResolvedJavaMethod commit = findCommitMethod(metaAccess, eventClass, commitName);
         ConstantPool cp = commit.getConstantPool();
 
         // Search for first INVOKESTATIC instruction in commit method which is expected
-        // to be the call to jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long).
+        // to be the call to jdk.jfr.internal.event.EventWriter.getEventWriter().
         final int INVOKESTATIC = 184;
         byte[] code = commit.getCode();
         for (int bci = 0; bci < code.length; bci++) {
             int b = code[bci] & 0xff;
             if (b == INVOKESTATIC) {
diff a/test/jdk/jdk/jfr/tool/TestAssemble.java b/test/jdk/jdk/jfr/tool/TestAssemble.java
--- a/test/jdk/jdk/jfr/tool/TestAssemble.java
+++ b/test/jdk/jdk/jfr/tool/TestAssemble.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -33,11 +33,10 @@
 import jdk.jfr.Name;
 import jdk.jfr.Recording;
 import jdk.jfr.consumer.RecordedEvent;
 import jdk.jfr.consumer.RecordingFile;
 import jdk.jfr.internal.Repository;
-import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.test.lib.Asserts;
 import jdk.test.lib.process.OutputAnalyzer;
 
 /**
  * @test
@@ -78,11 +77,11 @@
             Path tmp = dir.resolve("chunk-part-" + i + ".jfr");
             recordings[i].dump(tmp);
             expectedCount += countEventInRecording(tmp);
         }
 
-        SafePath repository = Repository.getRepository().getRepositoryPath();
+        Path repository = Repository.getRepository().getRepositoryPath();
         Path destinationPath = Paths.get("reconstructed.jfr");
 
         String directory = repository.toString();
         String destination = destinationPath.toAbsolutePath().toString();
 
